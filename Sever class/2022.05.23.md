# 2022/05/23 수업내용
# 멀티 스레드
## 설계
### 헤테로 설계
1. 완전히 별도의 기능(컨텐츠)으로 나누어 스레드를 설계하는 형태
    1) 로비, PVP, 던전으로 스레드를 구분할 수 있다
        * 스레드를 늘려서 성능을 높일 수 있는 
        * 유저가 어느 컨텐츠를 하고 있느냐에 따라 메시지를 구분할 수 있다. 하지만 
    2) 이 구조는 이전 시간에 언급했던 하나의 Update를 호모로 가져가는 형태보다 조금 더 복잡하다.
        * 첫 번째 이유로는 '항상' 유저의 컨텐츠를 확인하여 스레드에 전달하여 실행해야 하기 때문이다.

# 비동기 IO
## Overlap 모델
### Interrupt와 IO 의 처리
1. Interrupt가 발생할 때 나의 스레드는 Block 상태가 되지 않는다. 
    * Interrupt 또한 커널 코드이지만 나의 스레드에서 할 수 있는 코드이기 때문에 코드를 마치고 빠질 수 있는 형태이다.
2. IO는 퀀텀 타임을 포기하고 Block 상태가 된다.
    * IO는 해당 장치의 드라이버가 해야하는 작업이기 때문이다.
3. 이제는 어떤 코드가 나의 스레드에서 도는 것인지 커널에서 도는 것인지 경계를 허물기 힘들다.
    1) 최근 L4와 L3에서 만들던 TCP, IP헤더와 MSS 크기만큼 데이터 자르는 것을 이더넷 카드(드라이버) 수준에서 해결해주는 형태로도 나온다. 이러한 이더넷 카드들을 대상으로 패킷 캡쳐를 해보면 패킷이 MSS보다 크거나 TCP헤더, IP헤더가 없는 모습을 볼 수있다.
        * 이더넷 드라이버는 IO작업이므로 나의 스레드는 Block이 걸리는 작업이다.

### 동기와 비동기
1. Block과 Non-Block과 혼동해서는 안된다.
    1) Block:         
    3) Non-Block: 그저 Block이 안 걸린다는 의미이다. 일의 완료여부에 상관없이 
2. (**중요**)어떤 함수의 기능이 Block이 걸리지 않는다면 100% 그 작업은 디바이스 IO작업이 아니다.
    1) Block이 걸리는 두 가지 상황이 있다. IO작업을 하거나 작업을 완료할 수 없어서 커널 모드로 전환하여 해당 스레드를 Block 상태로 변경하는 것이다.

### Overlap
1. Overlap의 대상: Block이 걸려야하는 상황에서 Block이 걸리지 않는 것이다.
2. Overlap은 새로운 방식이 아니다. 그저 일의 "완료 여부에 상관없이 Block이 걸리지 않을게"의 의미이다.
3. 동작
    1) 비동기 입출력을 지원하는 버퍼(소켓)을 생성해야 한다. WSA 함수를 사용하는 경우 flagOverlaped 라는 플래그를 .일반 socket은 기본적으로 비동기 소켓을 지원함
    2) 기존에 제공되던 소켓 함수들은 비동기를 지원하지 않는다. WSARecv, WSASend가 주력이다.
4. Overlap의 목적
    1) 나의 스레드와 상관없이 해당 장치에서 작업을 완료
5. 모든 Overlapped IO는 Polling 방식이 아닌 Event 방식으로 처리가 된다.
    1) 그래서 우리는 Accept 전용의 스레드를 분리한다. 우리는 굳이 AcceptEx를 사용하지 않는다. 그저 Accept가 해당 스레드를 제어할 수 있게 할 것이다.

### WSA 함수
1. WSASend
    1) 인자 정보
        * WSABUF: 길이와 버퍼 포인터로 구조되어 있다. 이로 인해 분산 버퍼가 가능해진다. 이로 인해 우리가 링버퍼를 사용할 때 
        * Overlap 구조체는 memset(0)으로 초기화해서 전달해주면 된다.
        * WSABUF를 2개 이상 쓰지않는 경우가 있는데 지금은 몇백개씩 갖다 쓴다.
2. WSARecv
    1) 인자 정보
        * WSAOVERLAPPED 구조체에 Event 방식에서는 event 변수를, Callback 방식인 경우 IOCP를 전달해야 한다.
3. WSACreateEvent
    1) 이벤트 객체를 생성한다. 우리가 일반적으로 생각하는 커널 이벤트 오브젝드이다.
4. 이제는 WSA_WOULDBLOCK이 아닌 WSA_IO_PENDING 오류가 반환된다.
5. WSAOVERLAPPED 구조체
    1) Event 방식을 사용하는 경우 WSAOVERLAPPED 구조체에 Event 객체를 전달해야 한다.
    2) WSAOVERLAPPED와 그냥 OVERLAPPED 구조체는 완전히 똑같은 구조체이다.
6. WSAGetOverlappedResult 
    1) Overlapped 방식에서는 Event numberOfBytesSent, numberOfBytesRead 
    2) lpcbTransfer: 이 수는 리시브, 샌드에 대한 바이트 수이다. 이때 리시브, 샌드에 대한 것인지는 우리가 판단해야할 몫이다.
    3) fWait: 작업이 완료될 때 까지 Block이 걸릴 것이냐 안 걸릴 것이냐를 결정하는 플래그이다.
7. 전달할 실제 버퍼와 WSAOVERLAPPED 구조체는 장치가 사용하기 때문에 절대 삭제시키면 안 된다. 그래서 항상 보존할 수 있는 형태로 버퍼와 Overlapped 구조체를 가져가야 한다. (ex: 전역 변수)
    1) WSABUF는 보존할 대상이 아니다. 그저 껍데기일 뿐이다. 우리가 보존해야 할 것은 실제 데이터가 들어있는 버퍼 포인터이다.


### 윈도우 시스템 프로그래밍 도서
1. 윈도우 시스템 도서 예제에서 파일과 관련한 예제가 나오는데 이것에 대한 문제점을 이야기한다. 이때 이 문제점이 무엇인지 소켓과 어떤 다른점이 있는지 파악하기
2. 예제 분석
    1) WSARecv
    2) 더미 이벤트를 생성한 이유:
    3) 소켓에 대한 이벤트는 AutoReset을 지원하지 않기 때문에 WSAResetEvent 함수로 수동으로 풀어줘야한다. 의도 자체가 소켓에 대한 작업들을 나누어
    4) 크리티컬 섹션의 용도: Remove와 Addsockeinfo 스레드에 대한 동기화 처리를 하고 있다.
    5) 종료 처리: 
    6) 예제처럼 하프 듀플렉스 방식에서는 작업당 Overlapped와 Event 객체 대한 추가적인 리소스가 나와야 한다.

### Event 방식
1. 완료 통지를 Event 방식으로 받는 것이다.
2. 통지: 작업당 Event 객체를 만들어 작업의 완료를 해당 시그널을 확인하는 방식이다.
3. 항상 새로운 세션에 대한 처리를 할 때 WSARecv를 항시 걸어놓아야한다. 작업을 마치고 바로 WSARecv를 걸어놓아야 한다.
4. 이벤트의 방식의 문제점
    1) 새로운 소켓이 Accept 되었을 때 새롭게 소켓 배열에 추가해야하는 추가 작업이 있어야 한다.
5. 우리는 Event 방식은 사용하지 않는다.
    1) 이유1: 작업(Send, Recv)당 Overlapped 구조체와 Event 객체가
    2) 이유2: Send와 Recv 작업 시 반환되는 바이트 개수가 
7. 함수 반환 AlerTableWait


### Callback 방식
1. 작업
    1) 작업의 완료를 콜백 함수를 호출하는 형태로 전달하는 방식이다.

### APC 큐


# 기타 키워드
## 윈도우 시스템 프로그래밍 숙제
1. 예제1: 뒷부분 예제에서 파일과 관련한 예제가 나오는데 이것에 대한 문제점을 이야기한다. 이때 이 문제점이 무엇인지 소켓과 연결하여 어떤 점의 차이점이 있는지 직접 테스트하여 파악해보기
2. 예제2: 에코 서버 예제의 예상 동작의 분석과 실제 결과 비교해보기

## Overlapped의 잘못된 역사
1. Microsoft press에서 잘못된 연설로 인해 

해시 테이블
	1. Hash: 일정한 규격으로 결과가 도출되는 알고리즘 (난수적 요소가 존재하지 않고 같은 입력에 같은 결과가 나와야 함)
	2. 암호화?복호화? X 그냥 해시
		=> 원본으로 복호화 하지못하는 해쉬테이블이 좋은 해시테이블이다. 때문에, 암호를 서버에 저장할 때 해쉬테이블을 통해 저장해야 안전하다.
		=> 계정을 복구할 때 새로 발급해주는 것이 아닌 기존 패스워드를 알려주면 해시 테이블로 저장하는 것이 아닐 확률이 높다.
		=> decrypt: 해쉬 테이블에 대한 결과를 추적하는 프로그램
	3. 파일을 해시 테이블 정보로 변환하여 위,변조된 파일을 검증할수도 있다.
	4. 브루트포스(brute force) 방지하는 방법
		1) 사용자가 쉬운 패스워드를 지정하였을 경우 salt를 덧붙여 해시 테이블의 안정성을 높인다 (ex: 사용자가 입력한 패스워드가 1234일 때 1234k(*3 과 같이 서버에 저장하는 것)
		2) 2^n번 해시테이블화 시켜 brute force 시간을 늘려버림
	5. bcrypt 함수: 
	6. 해시 테이블은 Key-Value 자료구조를 사용한다. 특정 Key를 가지고 Value를 찾는 방법을 가진다. 
		=> 시간복잡도는 O(1)이다. Key를 해시하여 특정 값이 나올 때 그 값을 이용하여 Array index로 사용하여 value를 찾는다. 이 때 Array index의 충돌이 적은 해시 알고리즘을 만든는 것이 관건이다.
		=> 충돌하는 경우의 방법 중 대표적인건, 충돌 시 같은 Index에 리스트를 생성하여 여러개의 key에 대한 value를 관리한다.
		=> 해시 테이블은 배열형태이기 때문에 메모리 사용성에서 비효율적이다.
	7. Unordered Map - 해시 테이블 형태의 자료구조의 STL
	*. sha512가 제일 많이 활용됨(crc32도 자주 쓰임). checksum을 통해 전송된 데이터에 대한 검증이 필요하다.
	*찾아보기: Unordered Map STL
	
컴파일러 변경의 문제점
	1. 각기 다른 컴파일러가 같은 코드의 메모리, 데이터에 대한 사용 방법이 달라질 수 있어 변경하기가 어렵다. (alignas와 같이 메모리 참조에 대한 연산에 관한 것이 대표적이다.)
	2. 컴파일러가 바뀌면 지원하는 기능이 없어질수도 있다.

과제
	1. 해시 테이블 구현
		1-1) 같은 Key에 다수의 value 리스트 구조로 만들기
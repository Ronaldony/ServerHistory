# 2022.01.17 수업
## 윈도우 GDI
### 마우스 십자 그리기
1. 원래는 DirectX에서 제공하는 Direct Input를 이용하여 구현해야함 

### DC
1. GDI 개체: DC 공간에 들어가는 GDI 객체 속성, 1개 씩만 연결된다. Pen, Brush, Font, Bitmap 등의 개체가 있다.
    * 최대 9,999개 까지 생성된다.
    * 개체는 커널 영역에 저장이 되어 프로세스의 메모리 공간이 증가하지 않는다.
2. SOEN에서는 렌더링이 끝난 후 DC를 Delete하는데 권장하는 방법은 아님
3. 사용하지 않는 DC를 물고있으면 있을수록 성능에 영향이 있다.
4. 두개의 패턴을 DC에 그리는 방법
      1) 모든 좌표를 저장하여 렌더링(제한 개수 지정)
      2) 그리기에 대한 액션을 저장하여 

### BitBlt, PatBlt
1. PatBlt: 지정 색으로 DC 밀어버리기
2. BitBlt: 메모리에 있는 DC를 클라이언트 DC에 복사하기(화면에 출력하기)
    * 마지막 인자 DWORD rop은 그리기 속성 지정

### SetPixel

### GetSysColorBrush
1. 이미 존재하는 브러시 개체를 얻어오는 함수(생성 X)

## switch-case문
### 변수 선언
1. switch-case문에서 변수를 선언하려면 블록을 지정하여 선언해야 한다.

## BMP 파일
### Pitch (뭔지 헷갈림 다시 공부할 것!!!!)
1. 비트 색상의 한 줄의 단위, 기본적으로 4byte로 한다.
    * 메모리 계산으로 인한 4byte 경계를 기본으로 한다. ColorByte가 늘어나면 4단위로
    * Width w, ColorByte c = W 일 때 Pitch 경계 => (W + 3) & (~3)

## 게임
### Winmain 구조
1. PeekMessage() 함수를 활용하여 메시지 처리가 우선되어야 한다. 
    * 이에 따른 게임 처리는 메시지 처리가 된 후에 이루어진다. 메시지 처리가 먼저 되어도 게임 처리에는 큰 영향이 없다. 메시지 처리는 부하가 크지 않기 때문이다.

### 2D와 3D
1. 스프라이트: 게임 화면 출력 이미지가(캐릭터, 배경 등) 한 장, 한 장 존재하여 는 이미지 파일
2. 2D와 3D 차이
    1) 2D: 스프라이트를 연달아 출력하여 애니메이션 구현
    2) 3D: 행동 중간 중간 키 프레임을 좌표로 설정하여 해당 위치에서 직접 계산하여 그린다. 시간의 흐름대로 키 프레임 계산을 수행한다.
    3) 3D는 프레임이 떨어져도 그때마다 계산하여 큰 상관은 없다. 하지만 2D는 프레임이 항상 일정해야 한다.
    4) 2D는 최대 프레임이 제한되어야 하지만(스프라이트 때문), 3D에서는 상관이 없다.
        * 3D는 
3. Frame Skip: 2D에서 목표 FPS가 있을 때 느린 컴퓨터가 동작할 때 렌더링을 포기하고 로직을 50FPS로 맞추는 것
4. Fixed Update: 3D에서는 충돌처리 등의 로직이 정상적으로 이루어지는 것을 위하여 최하 프레임이 보장하는 것
5. Frame Skip와 Fixed Update의 차이점
    1) Frame Skip: 언제 렌더링을 버려야하는 시점을 찾는 방법
    2) Fixed Update: 로직이 목표 FPS 이하가 되는 순간 로직을 더 밀어넣어 프레임을 맞추는 것 (로직을 추가하는 느낌)
        * 유니티에서는 이 방법을 채택하고 있다.

### 시간 기준 처리
1. 프레임 기준 게임 처리는 예전 방식이고 최근에는 시간 기준으로 로직을 처리한다.

* 베어메탈

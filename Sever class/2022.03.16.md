# 2022/03/16 수업내용(복습 완료)
## 직렬화 버퍼
### 입력 데이터의 타입
1. 입력 데이터 타입 설계 방법
    1) 방법1: 직렬화 버퍼에 입력되는 데이터를 단일 된 컨텐츠 형식으로 전달하는 방법
        <pre><code>
        // 기본 구조
        void 메시지 생성 함수(CPacket* clpPacket)
        {
            ...
            *clpPacket << CPlayer;
        }

        CPacket operator << (CPlayer& player)
        {
            // 연산자 오버로딩 자체가 컨텐츠에 따라 하나의 프로토콜이 된다.
            unsigned char len = sizeof(CPlayer);
            
            *buff = len;
            
            *(buff + 1) = player.x;
            *(buff + 2) = player.y;
            ...
        }
        
        // 응용 사례
        아이템목록
        {
            unsigned char itemcnt;
            {
                int itemid;
                int item1;
                int item2;
                int item3;
            } * itemcnt;
        }
        
        MakePakcetItemList(list<ITEM*> ItemList)
        {
            Packet << ItemList;
        }
        </code></pre>
        * 특징: 직렬화 버퍼 자체가 하나의 프로토콜의 역할을 하게 된다. 사용자 입장에서는 메시지 입력이 자동화가 된 느낌
        * 장점: 단일 된 프로토콜로 같은 컨텐츠는 직렬화 버퍼에 한 번만 입력하면 된다.
        * 단점: 같은 컨텐츠라도 상황 혹은 유저마다 필요한 정보가 다를 수 있는데 프로토콜이 통일되다보니 필요없는 정보가 전달되는 경우가 있다.(통신비용 증가)

### 연산자 오버로딩
1. 연산자 오버로딩을 template로 구현하면 안 된다. 버퍼에 들어갈 데이터로 모든 타입을 허용하는 것인데 그렇게되면 정해진 프로토콜이 의미가 없다.

## RPC(Remote Procedure Call)
### RPC의 구조
1. RPC를 정한다는 것은 호출할 **함수**를 정하는 것이다. 이것 자체가 프로토콜이 되는 것이고, 보내는 데이터의 크기가 뭐다 순서가 어떻게 된다 라는 언급자체를 할 필요가 없다.
2. RPC가 포함하는 부분
    1) proxy 측: 메시지 생성 함수 호출 + 네트워크 송신
    2) stub 측: 네트워크 수신 + 메시지 파싱 후 메시지 프로시저 함수 호출
3. 보내는 측을 proxy, 받는 측을 stub이라 지칭한다.
4. RPC 사용자 측에서 stub과 proxy에 대한 정보를 관리하는 객체에 등록하여 사용할 수 또 다른 Library가 나와야 한다.
    * 여기서 Library가 나오는 이유는 RPC는 stub과 proxy 간에 네트워크 송수신까지 역할하기 때문이다.

### 직렬화 버퍼와 RPC의 관계
1. 직렬화 버퍼와 RPC의 관계: RPC의 개념은 proxy 에서 함수를 호출하면 stub 에서 특정 함수가 호출되는 것이다. 이러한 입장에서보면 프로시저 함수 혹은 메시지 생성 함수에서 메시지 프로토콜을 하나하나 입출력하는 방식은 맞지 않다. 즉, 컨텐츠 데이터 타입을 입력하면 직렬화 버퍼의 연산자 오버로딩 함수 내에서 프로토콜을 생성 혹은 출력하는 방법이 맞다.

### 구글, 프라우드넷 등의 회사에서 제공하는 RPC 코드 생성
1. RPC 코드는 애플리케이션의 함수 호출(switch-case포함) 부터 네트워크 송수신 부분을 모두 포함한다.
    1) 장점: 사용하기 간편하다.
    2) 단점: 네트워크 송수신까지 포함되어 있기 때문에 성능상에 한계가 있다. 따라서 우리는 안 쓴 다!
2. 프라우드 넷의 RPC 코드 생성
    1) IDL 컴파일러가 IDL 파일을 읽어 stub과 proxy의 .cpp, .h를 생성한다.
        * IDL 파일을 우리 프로젝트에 포함하여 RPC 코드(.cpp, .h)를 생성할 수 있다.(빌드 이벤트 수정)
    2) 고민해 볼 사항
        * 새로 빌드할 때마다 수신측 즉 stub.cpp에 프로시저 함수의 내부가 새로 덮어질텐데 어떻게 해결할 것인가? -> stub.h에서 Stub 클래스를 생성하고 내부에 프로시저 함수를 가상 함수로 정의를 해놓는다. 우리의 코드에서 이 Stub 클래스를 상속하여 함수 내부를 구현하는 방법이 있다. 이는 프라우드넷에서 이용하는 방법이다.
3. gRPC: 구글의 RPC 시스템으로 크래스 플랫폼으로 송신-수신측 언어에 상관없이 RPC를 생성해준다. **프로토콜 버퍼**를 사용하여 데이터가 전달된다.

### 동기 RPC, 비동기 RPC
1. 동기 RPC: 송신측 입장에서 메시지 생성부터 네트워크 송신을 하고 수신측으로부터 결과를 기다리는 형태
    * 절대 안 씀!
2. 비동기 RPC: 송신측 입장에서 메시지 생성 후 **송신 요청**까지만 하고 수신측의 결과를 기다리지 않고 다른 동작을 하는 형태

## 기타 키워드
### 패턴
1. 프록시 패턴
    1) Virtual 프록시: 주체(정보or리소스 관리)측과 요청(정보or리소스 요청)측 사이에 프록시 클래스를 두어 요청의 부하(적은 리소스 요청 등)가 적은 경우 프록시 클래스에서 해당 요청을 처리한다. 그러나 프록시 클래스가 판단하기에 요청의 부하가 큰 경우 해당 요청을 주체 측에서 처리하도록 하는 구조
    2) Protection 프록시: 안전 장치를 넣는 방법. 요청측이 주체측에 접근 시 중간에 있는 프록시 클래스가 접근에 대한 제어를 하는 역할
    3) Remote 프록시: 원격지에 있는 다른 컴퓨터의 함수가 호출되는 것(디자인 패턴 입장에서는 Remote 프록시, 구현의 입장에서 보면 RPC)

### GPG(Game programming gems)
1. 배현직 대표가 작성한 RPC 기고문 찾아보기

### 빌드 이벤트
1. 명령줄: 실행 파일 실행 시 commanline에 입력하는 옵션 지정
2. 빌드 전 이벤트: VS 프로젝트가 빌드 되기 전에 실행할 명령 입력
3. 빌드 전 이벤트: VS 프로젝트가 빌드 후 실행할 명령 입력. 보통 빌드 결과를 특정 서버에 자동으로 올리는 스크립트를 작성하여 사용하는 형태이다. 공식적으로 정해진 스케줄에 따라 빌드를 하게 되는데 이때 특정 컴퓨터 폴더나 svn, git에 commit 시키는 동작을 수행한다.
    * 이렇게되면 항상 정해진 곳에 최신 빌드된 실행파일이 있다.

### 포트폴리오
1. RPC 구조 자동화하는 것을 구현하면 포트폴리오에 작성 할 만 하다.
    * RPC 코드 생성은 메시지 생성부터 네트워크 송수신 메시지 수신까지 자동화시키는 것까지 하는 것이 기본이다.

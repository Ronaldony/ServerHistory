함수
 1. 호출규약
  1) 자료형 뒤, 함수명 앞에 선언되는 규약 키워드(__cdecl, __stdcall, WINAPI, CALLBACK 등), 0x86 호출규약이라고 검색할 것
  2) 스택 위 매개변수 순서: RTL(파라미터에 함수르 호출하여 값을 전달하는 경우를 대비하기위한 순서)
  3) 스택 정리 주체: 호출자(Caller가 스택을 정리), 피호출자(Callee가 스택을 정리)
   3-1) _stdcall: 정리 주체는 피호출자이며 피호출자가 ret할 때 ret imm 로 호출하여 파라미터에 대한 Stack을 정리한다.
   3-2) _cdecl: 정리 주체는 호출자이며 호출자이며 호출한 함수 계산이 끝나면 호출자가 파라미터에 대한 Stack을 정리한다.
   3*) WINAPI: 표준적인 호출규약을 호출하여 실행파일 제작 주최자가 다른 경우에도 호환성을 유지시켜준다.
   3**) 컴파일 제작자가 다를 경우 Caller-Callee의 호출규약이 서로 상이하여 Stack이 꼬일 수 있다.
  4) ret imm(특정 값): pop을 하여 돌아갈 주소로 Jump 및 ESP에 +1한 후 imm만큼 ESP 증가시킨다.
  5) 프로젝트 속성->C/C++->고급->호출규칙 수정 가능
  
 2. 함수의 리턴과 파라미터
  1) 함수 리턴 값에 대한 복사는 함수 호출이 끝나기 전 특정 레지스터에 저장 후 호출이 끝나고 호출자 영역에서 EAX 레지스터를 MOV한다.
  2) 파라미터의 메모리 크기가 크지않은경우(일반 변수) Call by value가 일반적으로 성능이 좋다.
  
매크로
 1. #error, #line, #pragma(컴파일러 옵션 지정), #(널 멸령어)
 2. 프로젝트 속성에서 전처리기 정의 살펴보기
 3. 국가별로 서비스하는 코드가 다를 경우 매크로를 잘 활용해야함
 4. 시스템 정의 매크로: __DATE__, __FILE__, __LINE__, __TIME__
 
typdef
 1. 형식: typedef [기존 자료형] [대표 문자열];
 2. 보통 '언어'의 호환성을 위해서 정의됨

enum
 1. enum도 type을 선언할 수 있음
 2. 문제점: enum의 요소들이 전역으로 정의가 되어 같은 이름의 enum값 선언 불가 => 해결방법: enum class 자료형(modern cpp에서 새로 등장함)
 
void형 포인터
 1. 어떠한 포인터도 형 변환 없이 대입할 수 있음
## 해시 테이블
1. Hash

		1) 일정한 규격으로 결과가 도출되는 알고리즘 (난수적 요소가 존재하지 않고 같은 입력에 같은 결과가 나와야 함)
		2) sha512, crc32 등이 주로 사용된다. (crc32의 경우에는 Checksum을 통해 전송된 데이터에 대한 검증이 필요할 때 사용)
		* https://www.php.net/manual/en/function.hash.php

2. 암호화?복호화? X 그냥 해시

		1) 원본으로 복호화 하지못하는 해쉬테이블이 좋은 해시테이블이다. 때문에, 암호를 해시화 한 후 서버에 저장하는 것이  안전하다.
		2) 유저가 계정 복구 요청 시 새로운 암호를 발급해주는 것이 아닌 기존 패스워드를 제공하면 해시 테이블로 저장하는 것이 아닐 확률이 높다. (즉, 저장 방식이 안전하지 않음)
		3) 해시 decryption의 원리: 찾고자하는 입력 데이터에 대한 해시 값을 단순히 해시 테이블과 비교하여 일치하는 값을 찾는 것이다. (따라서, 저장되어 있지않은 데이터는 찾을 수가 없음)

3. 파일을 해시 테이블 정보로 변환하여 위,변조된 파일을 검증할수도 있다.
		=> 의문점: 해시 테이블에는 중복되는 Key의 값이 있을 수 있는데 이것은 어떻게 해결?

4. 브루트포스(brute force) 방지하는 방법
		1) 유저가 입력한 패스워드에 salt를 덧붙여 해시 테이블에 저장한다. (ex: 사용자가 입력한 패스워드가 1234일 때 1234k(*3과 같이 데이터를 덧붙여 Hash 한다.)
		2) 해시를 2^n번하여 해시 테이블을 저장하여 brute force 시간을 늘려버림

5. 해시 테이블

		1) Key-Value 자료구조를 사용한다. Key를 가지고 Value를 찾는다.
		2) 시간복잡도는 O(1)이다.(배열 구조) 해시된 값 Key를 배열의 최대 개수로 나눈 값을 Array index로 사용하여 value를 찾는다. 이 때 Array index의 충돌이 적은 해시 알고리즘을 만드는 것이 관건이다.
			=> Index 충돌 시 대표적으로 같은 Index에 리스트를 생성하여 여러개의 key에 대한 value를 관리하는 방법이 있다.
		3) 해시 테이블은 배열형태이기 때문에 메모리 사용성에서 비효율적이다.

6. Unordered Map - 해시 테이블 형태의 자료구조의 STL

* bcrypt 조사해보기(TODO: 조사)

## 컴파일러 변경의 문제점

1. 서로 다른 컴파일러는 같은 코드를 컴파일 시 메모리, 데이터에 대한 사용 방법이 달라질 수 있다. 따라서 컴파일러 변경에는 신중을 기해야 한다. (메모리 참조에 대한 연산에 관한 것이 대표적이다.)

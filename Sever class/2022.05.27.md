# 2022/05/27 수업내용
# 비동기 IO
## Alertable wait IO (APC 큐)
## 비동기 IO
1. 비동기 IO 방법 - Event, Alertable wait, IOCP 방법은 모두 동일하게 완료 통지를 Block 상태로 기다리게 된다. 애초에 완료 통지를 수행해야 하는 스레드에서 다른 작업을 하게 설계한 것이 잘못된 것이다.

## TCP 예제 분석
### ACP 큐
1. 뺑뺑이를 돌리는 이유: 시그널 반환과 완료 통지를 구분하기 위해서
2. Overlapped 구조체를 가지고 IO에 대한 결과를 분석해야 한다.
    1) 예제에서는 OVERLAPPED 구조체를 세션의 첫 번째 요소로 삽입하여 완료루틴의 인자로 입력되는 OVERLAPPED를 세션으로 마샬링을 통해 세션 정보에 접근ㅂ마샬링을 통해 세션 정보를  구조체의 첫 




# 기타 키워드
## 비동기 IO
1. 비동기 IO  

## 과제
### 스레드 관련
1. 첫 번째 과제
    1) 과제: 멀티 스레드 환경에서 하나의 링버퍼를 대상으로 하나는 EnQ, 하나는 DeQ를 할 때 Lock 동기화 없이 정상적인 수행을 할 수 있도록 링버퍼를 수정하고 링버퍼에 멤버 변수로 SRWLOCK을 추가하고 멤버함수로 Lock과 Unlock을 추가한다.
    2) size와 같은 부가적인 요소는 Interlocked의 대상이지 Lock의 대상이 아니다.
    3) 만약 DeQ를 시도했을 때 
    4) 두개 이상의 스레드가 EnQ, 두개 이상의 스레드가 DeQ를 했을 때 
    5) 우리는 EnQ하는 상황과 DeQ하는 상황을 
2. 두 번째 과제: 이전에 했던 멀티 스레드로 헤테로 지니어스 구조로 숫자 순서대로 출력, 데이터 입력 등의 기능을 구현했다. 이번에는 호모 지니어스 구조의 Actor 패턴을 이용하여 생산자 스레드가 워커 스레드에 잡을 던져 하나의 스레드에서 모든 일을 하게 설계한다. 워커 스레드는 여러개가 될 수 있다.
    1) DB와 관련된 워커 스레드가 느린 경우 워커 스레드의 큐에 메시지가 쌓일 수가 있다. 이때 어떤 방안으로 대처할 수 있나? 
        * 방안1: 중요한 메시지는 처리하고 중요하지않은 메시지는 버려야 한다. 그리고 메시지 큐에는 애초부터 중요한 것과 중요하지 않은 메시지를 큐로 분리되어야 한다. => 그래서 잡 큐는 모니터링의 대상이다. 상승 곡선의 그래프가 나오면 결국에는 메모리가 가득차게 되어 있다.
        * 방안2: 
        * 메모리를 계속해서 늘리는 방법은 좋은 방법은 아니다. 그러나 이 상황은 이후에도 메시지 큐는 계속해서 발생한다.
        * 극단적인 방법1: 생산 자체를 줄이는 방법이다. 특정 유저들을 끊어버리거나 의도적으로 프레임을 줄이는 것.
        * 극단적인 방법2: 서버를 죽이는 것
3. 세 번째 과제: 디버깅, 문제되는 상황을 파악하고 그것이 어떤 상황에서 벌어질 수 있는가를 역추적하여 어떤 코드인지 파악하기
    1) 적어올 상황: 어디를 수정했는지, 어느 코드가 어떤 문제를 발생시킨 것인지
4. 멀티 스레드에서 문제가 발생했을 떄 절대 코드를 수정하지 않는다. 문제가 발생하는 순간을 정확히 로그를 남겨 
    1) 그 상태에서 값 확인, 원인 파악 정확히 한 후 코드를 수정하고 테스트까지 완료하기

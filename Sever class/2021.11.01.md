## 확률
1. rand() 사용 시 문제점: rand() % 100 에서 100을 나머지 연산으로 계산하면 난수의 분포도가 흐트러진다. -> 처음부터 seed의 값을 100이하로 설정
2. 확률 아이템 뽑기 구현 방법(일명 가차)
    1) 각 아이템과 확률(일정 회수를 기준으로 하는 확률 값)을 배열로 구성한 후 rand()의 결과 값을 배열에 저장되어 있는 확률 값과 비교하여 아이템 출력
    2) 뽑기 회수를 카운트하여 지급. 예를 들어 확률이 1%이면 100번째에 지급
    3) 아이템의 확률에 따라서 임의 배열에 미리 무작위로 아이템을 배치한다. 이후 뽑기마다 순서대로 배열에서 아이템을 출력한다.
    4) 매 뽑기마다 나온 아이템에 대한 확률을 감소시킨다. (모든 아이템에 대한 확률 소진 시 초기화)
* 확률에 대한 결정은 기획자와 협의하여 결정

## 공용체(union)
1. 각 요소가 같은 메모리를 할당한다.
2. LARGE_INTEGER 구조체에 사용된다. (현재는 QuadPart만 사용되는 정도)
3. 비트필드: 자료들이 비트 단위로 구성된다.

## 메모리 영역
1. OS는 가상메모리 체계를 지원한다.
    1) Page In: 가상메모리에서 Commit 상태의 Page를 실제 RAM에 할당한. (Page 상태는 Free, Reserve, Commit 3가지)
        * 디버그 메모리 창에서 ?? 값은 Free 혹은 Reserve 상태를 나타내고, 특정 값 (0도 모함) -> Commit 상태의 메모리 공간이다.
        * Reserve을 하는 이유: Page의 기본 단위인 4KB 이후 연속적인 일부 공간에 reserve 상태를 부여하여 다른 프로세스가 사용하지 못하게 하기 위함이다. (Stack의 경우 한 번에 기본 1MB를 모두 할당하지 않고 초기 4KB를 제외한 나머지 공간을 Reserve 상태로 전환)
    2) Page Out: RAM에서 많이 참조되지 않는 메모리 공간을 Disk에 내려 RAM 공간을 최대한 확보한다. (가상 메모리의 안전성과 연관있음)
    3) RAM의 1/2 크기는 유저 모드 메모리이다. 나머지 1/2은 OS 커널 모드 메모리에 할당된다. (32bit의 경우이고 64bit 운영체제의 경우에는 다름)
       * 32bit 에서는 하위 2GB가 유저, 상위 2GB는 커널 영역이다. 64 bit에서는 과거 유저와 커널 모두 8TB였지만 현재는 모두 128TB이다.
    4) 0x86에서는 페이지를 4KB 기본 단위로 설정한다.(12bit) 따라서, 가상메모리와 RAM 단위에서 페이지의 단위의 주소는 0x1000 단위로 나누어진다.
        * 가상 메모리 Page의 주소 정보(Page Table Entry)는 커널 메모리에 존재한다. Page를 4KB 단위로 할당하기 때문에 주소값 크기에 대한 부담을 아낄수 있다.
        * offset: Page(12bit) 아래 세부적인 주소
2. Heap은 영역이라고 보기보다는 메모리 관리자라고 보는게 맞다.
    1) C++에서 new 동적 할당 시 내부적으로 malloc(), HeapCreate(), HeapAlloc(), virtualAlloc()을 호출하여 힙 할당을 구현한다.
    2) Heap, Stack 영역의 reserve, commit 크기 설정은 VS의 프로젝트 속성->링커->시스템에서 수정 가능하다.
3. Stack의 경우에는 CPU에서 프로세스의 동작에 따라 커널에서 예외적인 동작으로 인식하여 확보하는 공간이다. (메모리 할당 과정을 코드 단에서 분석할 수 없음)
4. 가상 메모리를 4Kb 단위로 Page를 나누는 것은 캐시 메모리와 연관이 있다.
    1) 이후에 배우게 될 캐시 메모리 내부에서 캐시 라인을 관리하는 Tag, Index, Offset 등의 내용과 연관지을 수 있다.

# 2022/03/14 수업내용
## 소켓 프로그래밍
### 네트워크 구조체 설계
1. 네트워크 데이터 프로토콜로 문자열을 사용 시(ex: 채팅 프로그램)
    1) 단점: 무조건 길이를 명시하는 데이터가 들어가야 한다.
2. 가변적인 구조체 설계
    1) 기법 1(옛날 기법)
        <pre><code>
        // 채팅
        struct stChatMessage
        {
            char len;
            char message[0];    // 실제 구조체에 존재하지 않지만 이 공간 뒤에 침범해서 뭔가 데이터가 올 것이다 라는 아이디어의 방법이다. 
                                // 항상 이 방법은 구조체의 끄트머리에만 넣어야 한다.
        }
        
        struct stITEM
        {
            short   itemid;
            int     itemCount;
            stItemList  itemList[0];
        }
        struct stItemList
        {
            
        }
        </code></pre>
    2) 기법 2
        <pre><code>
        // 아이템 목록 정보 메시지 시작
        struct stItemList_begin
        {
            short msgType;
        }
        // 아이템 정보
        struct stItemList
        {
            short   msgType;
            stITEM  item;
        }
        // 아이템 목록 정보 메시지 끝
        struct stItemList_end
        {
            short msgType;
        }        
        </code></pre>
        * 단점: 이 방법을 사용하는 경우 클라이언트 입장에서 동기적(시작과 끝까지 한 번에)으로 이 메시지를 처리하는 것에는 문제가 있다. 동기적으로 처리한다는 것은 이 메시지를 처리하는 것외에 모든 동작을 멈추는 것이기 때문이다.
    * 서버와 클라이언트가 메시지 처리를 비동기적으로 할 수 있게 설계를 한다면 좀 더 유연하게 서로 독립적인 동작이 가능하다.
    * 네트워크 구조체의 경우는 클라측과 상의를 통해 결정해야 한다.

### 직렬화 버퍼
1. 구조체를 없애버리고 전송할 버퍼에 요청한 타입의 크기만큼 데이터를 밀어넣는 방법이다.
2. 구조
    <pre><code>
    아이템 목록 생성
    {
        PacketBuffer << (short)ItemList.size();
        for(...)
        {
            Item *p = *iter;
            PacketBuffer << p->Itemid;
            PacketBuffer << p->attr1;
            PacketBuffer << p->attr2;
            PacketBuffer << p->attr3;
            ...
        }
    }
    </code></pre>
3. 링버퍼와 직렬화 버퍼
    1) 링버퍼 Enqueue함수를 오버로딩하여 직렬화 버퍼 타입을 매개변수로하는 함수 만들기(선택 사항)
4. 직렬화 버퍼는 링버퍼와 달리 Resize 기능을 추가하는 것이 좋은 방법일 수 있다.
    * Resize여도 한계치가 존재하여야 하고, Resize가 너무 빈번히 일어나면 성능에 영향을 끼친다. (하루에 한 두번이면 OK)
* 직렬화 버퍼에서 데이터가 뽑히지 않았다는 것을 어떻게 인지하고 예외처리를 어떻게 할 것인가 고민해보기

## 기본 자료형 (20일 이어서)
1. 비트 단위로 데이터르 쪼개는 이유 => 네트워크 트래픽 비용
2. 회선 데이터 서버 비용이 대부분의 비용을 차지함.  windows 서버의 경우 스풀라라는 라이센스를 사서 서비스한다.
3. 처음 서버 설계 시 동접자수를 기준으로 설계한다. 최적화를 지속적으로 하지 않으면 성능이 계속 하락한다.
4. do{}while(0); 문의 활용
	1) 하나의 작업에 대한 동일한 코드가 여러 군데 사용될 경우 do{}while(0) 문에 하나의 단일 작업을 묶어 매크로로 정의하여 사용한다.
	2) 여러개의 조건문(if 문)이 동일한 분기점으로 이동하여야 하는 경우 사용
<pre>
<code>
do {
	if(cond1)
		break;
	if(cond2)
		break;
}while(0);
</code>
</pre>
5. continue 문은 예외적인 목적에만 사용하는 것을 권장.(ex: 입력의 오류, 계산의 오류 등)

## 함수
1. Release 빌드 모드에서는 증분 링크가 적용되지 않는다. Debug 빌드 모드에서는 증분 링크가 사용된다. (프로젝트 속성->링커->일반)
	1) 증분링크: 디버깅 중 코드가 변경될 시 프로그램이 꺼지지않고 빌드를 시도하여 다시 디버깅을 시작한다. (실패할 수도 있다.)
		* 증분링크의 해결점 1: 추가 혹은 삭제된 코드 뒤 코드에 대한 명령 주소값들을 재정렬 (함수간 어셈블리 명령 주소값들의 간격을 충분히 확보해놓음으로써 주소 밀림 해결)
		* 증분링크의 해결점 2: Stack 크기에 대한 재정렬 (스택 용량을 충분히 확보하여 변동 Stack 크기 커버)
	2) 증분링크의 또 다른 기능은 각 함수에 대한 번지(주소) 지점을 정해놓은 Jump Table을 생성하여 링크 시간을 단축시킨다. (예를 들어 함수 A,B,C가 순서대로 호출될 때 B함수 코드를 수정하여 다시 빌드하면 C의 함수 번지가 바뀌어 빌드 시간이 길어진다. 이를 해결하는 것이 Jump table)
2. call과 ret 어셈블리 명령어
	1) call: 자기가 돌아갈 지점을 Stack에 push하고 원하는 지점으로 Jump
	2) ret: Stack에서 pop을 하여 call이 push했던 주소값을 IP로 가져와 Jump
3. ret 주소가 깨졌을 경우 해결절차
	1) 메모리 내 ESP 인근 주소에서 ret해야 할 것으로 간주되는 주소값을 따와 디스어셈블리 디버깅창 주소(A)에 입력한다.
	2) 주소(A)에 표시되는 함수 이름을 바탕으로 분석한다.
4. 라이브 서비스 중에 함수 호출 간 메모리 누수가 발생되면, 일단 서비스 후 로그를 남겨 분석하며 해결 범위를 좁혀나가야 함.

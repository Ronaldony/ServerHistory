# 2022/04/29 수업내용
## 스레드 프로그래밍
### 프로세스
1. 프로세스 커널 객체에 대한 참조 개수가 0이면 파괴된다.
2. 메인 스레드가 종료되면 

### 프로세스 종료 옵션
1. endthreadex나 eixt 시 런타임에 해결되지 않는 부분이 있기 때문이다.
    1) endthreadex나 eixt 호출 시 해당 함수에서의 소멸자 호출 기회를 잃어버리게 된다. 컴파일러는 해당 함수의 마지막에 소멸자를 호출시키기 때문
    * 예전에는 컨테이너와 iterator가 서로 바라보고 있다. 컨테이너가 자신을 참조하고있는 iterator의 참조 개수를 저장하고 있다. 이렇게 했던 이유는 해당 컨테이너의 iterator가 존재하는데 컨테이너가 소멸되었다면 예외를 발생시킴

### 생성자와 소멸자 등록
1. 런타임 라이브러리가 소멸자를 atExit에 등록하여 main 문 리턴 시 소멸자가 호출됨
    * 컴파일러는 전역객체의 소멸자를 호출하기 위해 소멸자를 호출하는 코드를 직접 작성한다.
    * main문 리턴 시 소멸자에 break point를 걸고 분석하기
2. 소멸자가 호출되기 위한 필요한 요소: this 파라미터(this 콜)
3. 프로세스는 종료가 될 때 마지막에 atExit에 등록된 함수를 호출한다.

### 스레드
1. 1회용 스레드
    1) 아파치 서버
    * 잦은 스레드 생성과 소멸의 반복으로 많은 오버헤드가 발생한다. -> 그래서 우리는 스레드 풀을 사용한다.
2. 메인 스레드 종료와 여부 스레드들의 종료 시점
    1) 서브 스레드(사용자에 의해 생성된 스레드)가 전역 객체 혹은 싱글톤과 같은 객체를 사용하고 있는 와중에, main 스레드가 다른 스레드보다 먼저 종료되면 전역 혹은 싱글톤 객체의 소멸자가 먼저 호출될 가능성이 있다. 이렇게 되었을 때 서브 스레드가 더 돌게되면 메모리 Dump가 남게된다.(예외가 발생)
    2) 우리의 규칙: main 스레드의 리턴은 모든 스레드의 종료가 판단되었을 때 종료시킬 것이다. 따라서 스레드 생성 시 스레드 핸들을 보관하고 커널 오브젝트 상태를 확인하여 판단할 것이다.
3. TerminateThread
    1) 서브 스레드가 종료되어야하는 상황인데 아무리 기다려도 종료가 되지 않을 때 사용

## 동기화 객체
### interlocked
1. interlocked은 동기화 객체가 아니라 코드 레벨에서의 Atomic 연산자 기능이다.
2. 어셈블리 분석
    1) lock: Atomic 연산을 하기 위한 lock이다. 이는 동기화라고 보지 않는다. 그저 Atomic 연산자인 것이다. 
        * 두개 이상의 코어에서 lock이 수행되면 후발주자로 lock을 호출한 코어는 정지가 되고 선발 주자 lock 명령이 끝날 때 까지 기다린다.(OS 입장에서는 이 상황을 알지 못한다.)
        * lock 시 해당 캐시 라인 자체를 잠궈버린다.
        * NUMA 시스템: 멀티 프로세서에서 동기화를 구현하기 위한, 각 CPU의 옆에 각자의 RAM 슬롯이 있다. 이 상황에서는 똑같은 번지의 똑같은 메모리를 사용할 때 어떤 CPU의 RAM 정보인지 참조를 해가며 동기화 작업을 하게 된다.
3. interlocked 함수에 들어가는 인자의 주소는 해당 변수는 자신의 크기 주소 경계에 서야 한다.
    * 만약 이 조건을 충족하지 않으면 정상적으로 처리되지 않을 수 있다. (=Atomic을 보장하지 못한다!)
4. interlocked 사용 시 주의사항
    1) 해당 캐시 라인 단위로 잠구는 것이기 때문에, 서로 다른 변수를 interlocked 하는 동작이더라도 같은 캐시 라인에 있다면 같이 잠궈져버려 성능 저하로 이어진다. 이 사항을 완전 주의해야 한다.
    2) interlocked 사용 시 항상 interlocked 함수의 반환 값을 결과 값으로 사용할 것이다.
5. InterlockedExchange의 쓰임새
    1) 결과적으로는 일반적인 변수 = value의 동작과 똑같다. 하지만 
    <pre><code>
    // 두 스레드가 Proc에 진입하는 상황
    Proc(...)
    {
        // InterlockedExchange 리턴값은 변경되기 이전 Flag에 저장된 값을 반환시킨다.
        if(0 == InterlockedExchange(&Flag, 1))
        {
            시스템 초기화..
            Flag = 1;
        }
    }
    * 문제점: 후발 주자가 시스템 초기화되지 않은 상태에서 스레드를 돌리게 된다. 이 때문에 싱글톤에서는 이러한 방법을 사용할 수 없다.
    </code></pre>
6. 유저 동기화 객체는 내부적으로 Interlocked으로 도배가 되어 있다.

### malloc
1. malloc 시 32bit에서는 8, 64bit에서는 16 byte 경계로 메모리를 반환시켜준다. 즉 시스템의 2배를 주소 경계로 제공한다. 그 이유는 활용면을 고려한 값이다.

### 스레드 동기화
1. C 코드만으로는 문제를 발견하고 해결하기 힘들다. 어셈블리 단에서 Out Of Ordering을 파악하여 해결할 수 있다.

### Load와 Store
1. Load: 메모리 -> 레지스터 이동
2. Store 레지스터 -> 메모리 저장

## 기타 키워드
### TCP 파이터 서버
1. 주변 섹터 구하는 로직 개선 방법 생각해보기

### 스마트 포인터
1. 위크 PTR, 쉐이크 PTR

### Opcode
1. CISC: 명령어 길이가 가변적이고, 명령어 개수가 많다.
2. RISC: 명령어 길이가 고정적이고, 명령어 개수가 적다.

### Interlocked 
1. double checking locking

# 2021.12.20
## 시간함수
### timeGetTime 
1. getTickCount 함수가 timeGetTime 함수보다 명령이 훨씬 더 가볍고 64버전이 있어 유용한 경우도 있다.
    * 최근 Windows11에서 프로세스마다 독립적으로 0번 타이머 Current 주기를 설정한다는 소문이 있다.

### Chrono
1. C++ 표준 시간함수 템플릿

### rdtsc
1. CPU의 clock 진동횟수를 반환한다. (시간의 개념이 아니다)
2. rdtsc는 오차가 크다. 때문에 QPC도 이 함수를 사용하여 오차를 줄여 계산한 값을 반환한다.
3. 시스템마다 rdtsc 값이 모두 달라서 사용하기가 어려움
4. 예전에는 멀티코어 환경에서 문제가 발생했지만(CPU) CPU 계층에서 해결되었다.

## 프로파일
### 프로파일링
1. 프로파일링: 성능 검사. 이의 목적은 구현한 프로그램의 CPU 사용 빈도, RAM 사용량 등을 확인하는 것에 있다.
2. 1ms 혹은 100us 단위로 프로파일링한다. (최대 해상도인 100ns로도 가능)
3. CPU 선호도를 사용하여 하나의 코어에서 측정을 하여야 정확한 진단을 할 수 있다.
4. 대상
    1) 코드         : 확인하고자하는 코드를 제외한 프로파일링
    2) 물리 메모리   : Page fault에 대한 프로파일링
    3) 캐시 메모리   : 캐시 히트율에 대한 프로파일링
    4) 위 세 가지를 한 번에 확인하기 위해서는 실제 상황에서의 프로파일링을 해야한다.
5. 프로파일링은 코어 하나만을 대상으로 하는 것과 실제 상황(서버 붙인상태 등..)에서 프로파일링하는 것 두 가지로 나눌 수 있다. 

### 프로파일의 요소
1. 실행시간(평균, 최소, 최대), Call 횟수로 나뉜다. 최소, 최대 실행시간은 평균치를 계산할 때 버린다.(최소, 최대 값을 1단계 2단계 정도 까지만 버려도 된다.)
2. 최소 100만 건에 대한 샘플을 베이스로 프로파일링이 이루어져야 한다.

### 프로파일 후 개선 사항
1. Call 횟수가 많은 것, 수행 시간이 짧은 것을 기준으로 1차적으로 개선이 이루어진다.

### 프로파일 구조
1. 코드 구조
    1) Case 1
    <pre><code>
    Begin("Tag");
    TestCode...
    End("Tag");
    </code></pre>
    2) Case 2
    <pre><code>
    Begin("Tag");
    TestCode1...
        Begin("Tag2");
        TestCode2...
        Begin("Tag2");
    TestCode1...
    End("Tag");
    </code></pre>
2. 프로파일링 데이터 구조
    1) struct
    <pre><code>
    Struct Sample
    {
        TagName,
        Min,
        Max,
        Call,
        TotalTime,  // 원본 값(시간함수 결과) 그대로 저장 출력 시에 변환. 오차를 줄이기 위한 것
        StartTime
    }
    </code></pre>
    2) class
    <pre><code>
    class Profile
    {
        public:
        Profile(const char* tag) : _tag(tag)
        {
            Begin(tag); 
        }
        ~Profile(){
            End(_tag);
        }
        const char* _tag;
    }
    </code></pre>    
3. 프로파일 내부
    1) Begin
    <pre><code>
    Begin("tag")
    {
        // Tag 유무 확인
        // StartTime 업데이트
    }
    </code></pre>
    2) End
    <pre><code>
    End("tag")
    {
        // Tag 유무 확인
        // 소비 시간 = QPC(현재) - StartTime;
        // Tag Call 횟수 증가
    }
    </code></pre>
    * Tag가 중첩되는 구간에 대해서는 무시하고 측정이 이루어져야 한다. 중첩되는 구간에 대해서까지(Depth) 프로파일링이 이루어지면 더 복잡해진다.
4. 예외 처리
    1) Case 1  
    <pre><code>
    void Func()
    {
        Begin("Tag");
        if(...)
            return; -> 이 경우에는 아예 프로그램을 종료시켜야 한다.(프로파일 전용으로 프로그램을 실행시키고 있기 때문)
        End("Tag");        
    }
    </code></pre>
    만약 테스트 구간에서 End에 진입하지 않고 Begin을 2번 진입하는 경우에 
5. #ifdef, #endif 전처리기를 사용하여 프로파일링 여부 구조
6. 프로파일 리셋
    1) 실제 프로파일 시작 전 동작에 대한 초기화

##조사
wow64, boost asio(IOCP 대체 C++ 표준)

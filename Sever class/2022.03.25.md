# 2022/03/25 수업 내용
## 트리
### 포트폴리오
1. 검증하는 절차와 결과를 포함하여 포트폴리오에 기술한다.

### 사용처
1. STL 라이브러리인 Map이 레드블랙트리로 구현되어 있기 때문에 공부하는 것

## Pool(풀)
### 메모리 풀
1. 풀의 정의: 미리 할당된 공간(객체 등)을 필요할 때 해당 공간을 사용하는 방법
2. 목적: 힙보다 빠르게 메모리를 할당받기 위한 것이 목적이다.
    * 하지만 힙도 어떻게 보면 메모리 풀이다. 이유는 우리가 malloc 혹은 new 시 HeapAlloc으로 디폴트 힙에서 할당 받기 때문이다. 하지만 힙은 사용자의 요청 크기에 따라서 그때마다 가변적으로 크기를 계산하여 할당해주기 때문에 성능이 안 좋다. 
    * 이런 힙의 단점을 보완하기 위하여 오브젝트 풀(= 일정 크기로 나누어진 메모리 풀)을 사용하여 구현한다.

### 오브젝트 풀
1. 오브젝트 풀의 정의: template으로 특정 타입(객체 덩어리)을 대상으로 관리하는 메모리 풀의 형태이다. 
    * 나중에는 직렬화 버퍼도 오브젝트 풀로 구현할 것이다.
2. 노드 구조와 자료 구조
    1) 기본적으로 아래와 같은 노드를 List 형태로 가변적으로 관리한다.(Resize가 지원된다.) 이때 Queue 방식과 Stack 방식으로 관리할 수 있다.
        <pre><code>
        // 기본적인 형태의 노드
        struct st_BLOCK_NODE
        {
            Data data;      // 사용하자 template 인자로 입력한 데이터 타입
            stNODE* next;   // 다음 카리키는 노드 포인터
        }
        </code></pre>
    2) Queue 방식: 유니티는 이 방법을 사용한다.
        * 멀티스레드 환경에서는 이 방법이 성능면에서 나아질 수 있다. Alloc()과 Free() 시 head와 tail 서로 다른 주소를 접근하기 때문이다.(캐시 일관성 규칙에 의한)
    3) Stack 방식: Queue보다 캐시히트율이 높아질 확률이 높다.
        * 멀티스레드 방식에서는 성능이 더 안 좋아질 수 있다. Alloc()과 Free() 시 항상 같은 주소인 Top에 접근하기 때문이다.
    * 유니티 C#에서는 Dictionary나 리스트 형태로 구현한다. 유니티는 오브젝트 생성이 너무 느리기 때문에 이정도만해도 성능이 좋아진다.
    * NODE 생성 시에는 malloc이 아닌 VirutalAlloc을 사용하여 구현 (VirutalAlloc 사용 시 페이지 락을 걸수도 있다. 하지만 강사님은 사용하지 않음. 이유는 정말 쓰지않는 메모리라 판단하여 페이지 아웃이 되었기 때문에)
3. 위의 st_BLOCK_NODE에서 NODE의 Data와 next를 분리하여 Alloc 시 Data가 가리키는 주소를 건네주는 방식은 좋지않다. 이러한 방법은 Alloc, Free 할 때마다 NODE를 동적으로 할당 및 해제를 해야한다. 그래서 우리가 사용할 방법은 NODE 덩어리(next 포함) 자체를 크기로 동적 할당 후 Alloc 시 해당 NODE의 주소를 넘겨줄 것이다.
    * Data만이 아닌 NODE 자체를 할당해버린다면 NODE를 동적으로 해제 및 할당하지 않아도 된다.
4. Alloc과 Free 설계
    1) Alloc: Stack 자료 구조형태라면 Top NODE의 주소, Queue라면 tail NODE의 주소를 반환한다.
    2) Free
        * 잘못된 주소 입력: 입력된 해제 요청 주소가 잘못된 주소인 경우에 대비해야 한다. NODE에 유니크한 검사 코드를 넣어 대비할 수 있다.
        * Underflow, Overflow 대비: NODE 앞과 뒤에 특정 데이터를 추가하여 Underflow, Overflow 검사
    3) 오브젝트풀 생성자에 bPlacementNew 매개변수를 두어 true인 경우 Alloc 시 호출자를, Free 시 소멸자를 매번 호출할 수 있는 옵션을 마련해두어야 한다. (Placement new를 이용)
        * 만약 사용자가 bPlacementNew를 true로 설정하면 NODE 최초 할당 시 생성자 호출이 되지 않아야 한다.
5. 오브젝트 풀이 해제될 때 NODE List에 대한 정리를 해야 한다면? => NODE List 생성 시 모든 주소를 저장해두고 소멸자에서 모두 해제
6. 오브젝트 풀을 사용하는 것을 꺼려하는 개발자가 있다. 클래스가 너무 많이 있으면 풀이 너무 많이 생성되기 때문이다. => 강사님은 오브젝트 풀을 선호하심(메모리 관리 측면에서 좋기 때문)
* Garbage Collector(필요없는 메모리를 정리)를 구현하면 더 멋있음. Garbage Collector를 하는 시점에 대한 연구가 필요하다. (간단히는 Alloc 혹은 Free 시점, 복잡하게는 시간 계산 기준)
* 오브젝트 풀의 진정한 장점은 모니터링이다.(=디버깅) 일반적인 new, malloc으로 동적 할당 시 메모리가 어디에서 세는지 감도 잡지 못한다.

### 오브젝트 풀과 메모리 풀
1. 오브젝트 풀은 하나의 고정 크기의 풀이 아닌 사용자가 요청한 크기만큼 유동적으로 할당해줄수 있는 구조를 가질 수 있다.
    * 방법: 여러 단위의 크기별로 풀을 만들어놓고 사용자가 요청한 크기보다 큰 가장 가까운 크기의 공간을 해당 풀에서 제공해줄 수 있다.

### Free List
1. Free List: 반환된 것을 보관하고 있다가 재사용하자! (Pool과의 차이점: Free List는 미리 공간을 확보하지 않고 필요 시에 생성)
    * Pool의 경우 할당 개수를 정의하는 것이 어렵다. 항상 사용자 수가 다르기 때문이다.(패키지 게임은 Pool이 유리) 강사님은 Free List를 선호한다. 이유는 처음 Free List 방식으로 인한 성능 저하는 몇십초 내에 정리되기 때문이다.

## 기타 키워드
### 힙
1. 최소 힙, 최대 힙

### 메모리 풀
1. 구글, 페이스북에서는 tcmalloc. jemalloc이 있다.

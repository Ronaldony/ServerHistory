# 2022/02/18 수업내용
# 소켓 프로그래밍
## Chapter05
### 응용 프로그램 프로토콜과 데이터 전송
1. L3-pakcet, L4-Segment, L7-Message 로 구분한다.

### 게임 메시지 구조(통신) - 구조체 방식
1. 메시지 구조는 가능한 최소 크기의 단위로 설계해야 한다.
    * 일본은 비트 단위로 하지만, 한국은 편의상 그렇게 하지 않는다.
    * 메시지 구조체는 #pragma pack(1)로 packing 되어야 한다.
    * 예전 PC 게임은 서버-클라가 같은 구조체를 사용하여 문서화하였다. 하지만 최근에는 C#, C++ 등등 클라와 서버의 개발 환경이 다르기 때문에 데이터에 대한 문서화만 시킨다.
2. 메시지 구조체에는 항상 메시지를 구분할 수 구분자가 있어야 한다.
    1) TYPE 방식: 가변 길이의 구조체에 대한 대응, 각각 메시지에 대한 길이 정의 등의 문제가 있다. 2byte
    2) 메시지 길이: TYPE의 단점을 보완하는 방법으로 가변 길이 메시지에 대한 대응이 가능하다. 2byte
    3) 코드 고유값: 메시지에 대한 고유값. 1byte
3. 메시지 구조
    1) 보낼 데이터 크기를 고정 길이 헤더를 전송하고, 이어서 가변 길이 데이터를 보내는 방식이 되어야 한다.
4. 메시지 내 실제 게임 데이터 값을 검증하는 과정이 추가되어야 한다.

### 게임 메시지 구조(통신) - 직렬화 방식
1. 메시지 내 checksum의 목적: 네트워크의 문제가 아닌 중간에서 하이재킹 문제에 대해 대응하기 위한 목적이다.

### 네트워크 라이브러리
1. 게임 단계에서의 프로토콜과 네트워크 라이브러리 단계에서의 프로토콜이 분리되어야 한다.
    * 데이터의 검증 checksum, 시퀀스 등..
2. 네트워크 프로토콜이 추가되어야 하는 이유
    1) 게임 메시지가 잘못된 데이터가 차서 들어왔는데 우연찮게 맞는 경우가 있기 때문에 1차 방어같은 느낌이다.

### UDP
1. UDP는 데이터그램 형식이기 때문에 sendto 측과 recvfrom의 송수신 크기를 딲딲 맞춰야한다.

## Chapter08 소켓 옵션
### 소켓 옵션의 종류와 관련 함수
1. getsockopt에서 반환하는 값은 신뢰할 수 없으니 무시하자.
2. 볼만한 옵션
    1) SOL_SOCKET: SO_KEEPALIVE(잘 사용하지 않음, 이유는 밑에), SO_LINGER, SO_SNDBUF, SO_RECVBUF
    2) IPPROTO_TCP: TCP_NODELAY (네이글 작동 여부)
    * IPPROTO_IP, IPV6는 사용하지 않음
3. 게임 서버의 KeepAlive 목적(Heartbeat)
    1) 현재 접속이 클라이언트 프로그램이 맞는지
    2) 방법
        * 보통 클라쪽에서 서버로 주기적인 Heartbeat를 보내는 것(분 단위)
4. SO_KEEPALIVE를 쓰지 않는 이유
    1) L7(게임 서버)에서 HEARTBEAT로 L4와 L7 동시에 검사하기 때문에 불필요한 동작이 된다.

## 기타 키워드
### 해킹 방어 
1. 게임서버 앞단에 패킷을 필터링하는 서버를 하나 두어 게임서버의 IP와 포트를 감출 수 있다.
    * 그러나 SYN flooding, DrDOS와 같은 공격은 원천적으로 막지 못한다. (단순히 경유하는 것이기 때문)
    * 이점: 여러 대의 앞단 서버를 두고 공격받은 서버는 버리고 다른 서버로 대처할 수 있는 이점이 있다.
    * 단점: 유저의 정보(IP, Port)를 구분해야 하는 로직이 부담이 된다.

### 더미 테스트
1. 서버가 잘못된 연결을 정확히 파악하여 정확한 유저의 
2. 모든 연결이 끊어졌는데 서버측에 세션 정보가 남아있다.(=유령 세션) 원인은 다음과 같다.
    1) TCP가 인식하지 못한 것(패킷 유실 등의 이유)
    2) 서버측 로직의 오류
    3) 해결 방법: HEARTBEAT만 잘 체크하면 된다.
3. 멀티 스레드 환경에서는 연결을 함부로 

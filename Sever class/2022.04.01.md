# 2022/04/01 수업내용
## 길찾기
### 길찾기
1. 2차원 배열로 그리드를 만들어 출발 지점에서 도착지점까지의 찾아가는 경로, 과정을 드로잉한다. 추가적으로 방해물을 만들어 줘야하는데 이것은 마우스를 드래그 하였을 떄 설치되는 방법으로 드로잉한다.
    * 타일이 너무 크면 갈 수 있는 경로가 별로 없기 때문에 적당한 크기의 적당한 크기로 지정해야 한다.
2. 모든 길찾기의 기본은 내가 왔던 길인가 안 왔던 길인가를 아는게 기본이다.
3. 길찾기 시 지나왔던 경로를 파악하기 위해서는 월드좌표를 그리드 형태로 변환해서 지나온 경로를 저장해야 한다.

### 탐색
1. 깊이 우선 탐색과 너비 우선 탐색(구글링 해보기)
    1) 깊이: 일단 최종 목적지까지 끝까지 가보고 아니면 다른 경로를 찾는 방법
        * 예시: 이동 방향을 스택에 순서대로 넣어놓고 방식으로 일단 한 측에서 
        * 일반적으로 너비보다 더 좋은 성능이 좋은 결과가 나온다.(일단 목적지 끝까지 그려보기 떄문)
    2) 너비: 매번 주변을 검사하여 가능한 방향을 순서대로 경로를 찾는 방법
        * 예시: 이동 방향을 큐에 순서대로 넣어놓고 
2. 출발지점에서 도착지점까지 선을 긋는 것도 고민이 필요하다.

### 최적해 탐색
1. 어떠한 조건(어디서 어디로 가는게 정해진 상태, 그래프, 가중치 등의 조건이 주어진 상황)에서 가장 최적화된 방법을 선택하여 가는 방법이다. 
2. 모든 최적해 탐색은 CloseList, OpenList를 가진다.
    1) CloseList: 지나온 경로의 타일 모음
    2) OpenList: 앞으로 가려고 하는 방향, 실제적으로는 타일 노드를 리스트로 저장하고 있으면 항상 F값이 가장 적은 타일을 선택하여 반환할 것이다.
    3) List에서 전체를 훑어서 더 좋은 자리를 선택할 것이다. 타일의 X, Y 검색이 되어야 한다.
3. 더 좋은 자리의 조건 후보
    1) 목적지에 가까운 타일
    2) 출발지점부터 이동 지점까지의 이동한 횟수(이동 거리)
        * 타일 하나하나마다 구조체로 만들어 그리드를 밟을 때마다 카운팅을 한다.
    * 이 두 조건을 가중치로 두어 경로를 결정할 것이다.

### 타일
1. 타일은 주변으로 생성하는 개념으로 만들어진다.
2. parent의 용도: 마지막 목적지 타일이 만들어지는 순간 경로 찾기는 끝난것이다. 이때 목적지 타일을 기준으로 parent를 타고가며 출발지점까지 경로를 결정하는데에 목적이 있다.
    <pre><code>
    NODE
    {
        *parent;    // 나의 타일을 생성한 타일 노드(부모 타일)
        TileX;
        TileY;
        H;      // 목적지와의 거리
        G;      // 출발점부터의 이동횟수(8방향 이동)
        F;      // G+H (이 값이 적은 경로로 이동할 것이다.)
    }
    </code></pre>
    * H를 구하는 방식: 맨하탄(가장 권장, 목적지까지 x와 y를 더한 값), 유클리드(직선 거리), 옥타일, 쳬비셰프
    * H와 G에 가중치(임의의 값을 +하거나 곱하기하든)를 주어 F를 판단하는 기준이 달라진다.
3. 경로를 생성하는 과정(장애물의 유무와 상관없이 동일하다)
    1) 최초 출발지점 타일 생성
    2) 주변 8방향에 타일 생성(이때 G 값은 부모 G + 1), OpenList에 저장됨
        * 생성 전에 openList, closeList에 타일 X,Y가 있는 경우 타일을 생성하지 않음
    3) F값이 가장 적은 방향으로 지점을 기준으로 주변 8방향 타일 생성
    4) 3을 반복하다가 목적지 지점에 타일이 생성되는 순간 길찾기는 종료된다.
    5) 목적지 타일에서부터 부모 타일을 타고 올라가며 경로를 결정짓는다.
    * 장애물이 있는 경우 OpenList에 있는 타일들의 정렬, 타일 지정 방법에 따라 타일 생성 순서가 달라질 수 있다.
4. 목적지 타일까지 만들어 경로를 결정할 때 출발지점까지 대각선으로 돌아가는 것을 해결해야 한다.
    * 이미지 추가할 것
    1) 방법 1: 대각선 방향에 타일을 생성할 때 G에 가중치를 준다.(직선은 1, 대각선은 1.5와 같은 방법으로)
    2) 방법 2: 특정 방향으로 타일을 생성하려고 할 때 이미 만들어진 상태라면, 내가 만들려고 했을 때의 G값과 해당 타일의 G값을 비교하여 해당 타일이 내가 만드는 경우일 때 G값이 더 작은 경우 의 부모를 끊고 해당 타일을 부모로 재설정한다.
5. 코드
    <pre><code>
    시작 SX, SY, EX, EY
    시작 노드 생성 -> openList
    
    // 이 방법은 목적지를 찾아갈 때까지 먹통이 된다.
    while(1)
    {
        p = opList F 값 작은 노드 POP
            closeList push
            if(P가 목적지?)
            {
                부모타고 경로 확인
                return;
            }
            
            p 기준 주변 8방향 노드 생성(속성 체크 open, close 여부) 및 openList에 추가            
    }
    </code></pre>

### 브러쉬
1. 특정 경로를 패턴(서로 조합으로 경로가 될 수 있는) 그리드를 미리 만들어놓고 이것을 조합하여 

### 다 익스트라 알고리즘
1. 이미 무수히 많은 경로가 정해진 상태에서 현재 웨이 포인트에서 어느 경로로 가는 것이 좋은 방법이냐를 선택하는 방법이다. 보통 길찾기의 기본이다.
    * 하지만, 유저에게 적용하는 것에는 무리가 있다.(이동 지점을 예측할 수 없기 때문에, 전략 시뮬레이션)
    * 중간에 경로가 바뀌면 이 방법을 적용할 수 없다. 예를 들어 전략 시뮬레이션, 유저의 움직임
2. 이 알고리즘은 FPS의 AI를 구현할 때 적합하다. 웨이 포인트(이동 지점)간의 경로를 정해놓은 상태에서 
    * 보통 깊이, 너비 우선 탐색의 기본이 된다. 

### 에이스타 알고리즘
1. 다 익스트라와는 반대로 아무런 경로가 정해지지 않은 상태에서 실시간으로 경로를 찾아가는 방법이다.
2. 깊이와 너비를 짬뽕하고 경로에 가중치를 추가하여 에이스타 알고리즘을 만드는 방향으로 할 것이다.
3. 개선 방식
    1) 에이스타 자체를 개량한다기 보다는 주변의 도구를 추가하여 개선하는 방향으로 간다.

## 기타 키워드
### 길찾기 방법
1. 점프 포인트 서치(에이스타 개선 방식), 에이스타, 다 익스트라
2. 깊이 우선 탐색, 너비 우선 탐색

### 길찾기 포트폴리오
1. 검증 항목
    1) 최적의 길을 찾았냐는 것은 확인할 방법이 없다. 따라서, 모든 경로에 대해서 에러 없이 길을 찾아갈 것이냐를 검증해야 한다.
        * 깊이 우선 탐생르 미로 생성 알고리즘으로 사용(길을 뚫어버림)
    2) 성능: 멀티스레드 방식, List를 제거하는 방식, 캐시히트율 개선 등
        * 성능을 비교할 때 어떤 기준으로 성능을 테스트하느냐가 문제이다. 다른 사람이 만들어놓은 것? 표준적인 방법? 아니다. 내가 기준을 만들어 성능을 비교해보아야 한다. 예를 들어 가설을 세우는 것이다. 동접자들이 몇명이고 이동 행위를 x초에 몇 번 시도할 때 문제가 없는 길찾기의 방식이냐

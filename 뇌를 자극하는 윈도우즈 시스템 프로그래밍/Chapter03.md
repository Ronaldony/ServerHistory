# Chapter03 64비트 기반 프로그래밍
## Section01 WIN32 vs WIN64
### 들어가는 말
* 저자는 Chapter03에 들어가기에 앞서 다른 개발자들의 코드를 활용할 때, 구현 원리와 기능에만 관심을 둔다고 한다. 세련된 코드보다는 보다 **직관적이고 명확한 인터페이스가 정의된 코드**를 좋아한다고 한다. 그렇지 않으면 코드를 분석해야하는 일이 발생하기 때문(?)이라고 한다.


### 64비트와 32비트
1. 32비트와 64비트 컴퓨터를 구분하는 방법에는 2가지가 있다. 첫 번째는 I/O 버스를 통하여 **한 번에** 전송 및 수신할 수 있는 데이터의 크기, 두 번째는 **한 번에** 처리하는 데이터의 크기이다.
    
### 프로그래머 입장에서의 64비트 컴퓨터
1. 32비트에서 64비트로 늘어나면 메모리에 대한 주소값을 표현할 수 있는 크기가 커져 메모리 활용에 이점이 있다.
2. 각 64비트 컴퓨터에서 주소 값은 64비트로 표현되는게 가장 좋다.

## Section02 프로그램 구현 관점에서의 WIN32 vs WIN64
* 마이크로소프트에서 제시하는 프로그래밍 스타일에 대한 가이드를 따르는 것이 64비트 기반 프로그래밍 스타일의 기본이 된다.

### LLP64 vs LP64
1. 64비트 Windows에서는 LLP64모델을 따른다.
    * 참조: https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models

### 64비트와 32비트 공존의 문제점
1. 64비트 주소 값을 32비트 변수에 저장할 때 주소 값에 대한 손실 문제가 발생한다. 예시는 다음과 같다.
<pre>
<code>
#include <stdio.h>
int main(void)
{
    int arr[10];              // LLP64에서는 arr가 64비트의 값을 갖는다.
    int arrAddr = (int)arr;   // int의 크기가 32bit여서 arr의 주소 값이 32비트만큼 손실된다.

    printf("arrAddr: %d\n", arr);
    return 0;
}
</code>
</pre>
* 따라서, 64비트 시스템에서는 주소 값을 32비트 크기 변수에 저장하지 않아야 한다.

### Windows 스타일 자료형
1. Microsoft C/C++ 에서는 __int8, __int16, __int32, __int64로 타입을 선언할 수 있다.
    
## Section03 오류의 확인
1. GetLastError 함수와 에러코드
    1) Windows 시스템 함수를 호출하는 과정에서 오류가 발생하면, GetLastError 함수를 통해 오류의 원인을 확인할 수 있다.
        * 단, 성공여부와 상관없이 시스템 함수가 호출될 때마다 GetLastError 함수 반환 에러코드가 갱신된다.
        * 참조: https://docs.microsoft.com/ko-kr/windows/win32/debug/system-error-codes--0-499-

## Section04 System Programming Project Design
* 저자는 해당 챕터3 부터 일반적인 프로그램 예시가 아닌 프로젝트 형식의 명령 프롬프트 프로그램을 구현하여 배운 내용에 대한 이해를 높이고자 한다. 이에 따라 일부 챕터의 마지막 섹션에는 이 섹션과 같은 프롬프트 프로그램 구현에 관한 섹션이 구성되어 있다.

### 명령 프롬프트 프로젝트의 제안과 EXIT 명령어의 구현
* 구현 내용: 명령 프롬프트에서 "exit" 기능 구현
* 코드 파일 경로: Pompt_prj/prompt03

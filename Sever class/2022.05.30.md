# 2022/05/30 수업내용
# 과제 분석
## 잡 워커 스레드
### 메시지
1. 하나의 메시지는 짤라서 보내면 안 된다.
    1) 상황: 본 과제에서는 헤더만 보내는 메시지와 헤더+데이터(문자열)를 보내는 형태의 메시지로 설계
    2) 헤더+데이터를 2번 나누어 EnQ 했을 때, DeQ 쪽에서 헤더+데이터가 아닌 헤더에 대한 길이만 고려하여 DeQ를 하게되면 데이터를 EnQ 하지도 않았는데 DeQ를 하여 이상한 값을 읽어올 수가 있다. 따라서 EnQ 동작 시에는 직렬화를 쓰던 해서 헤더+데이터를 한 번에 꽂아넣어야 한다.
2. 메시지에 대한 처리
    1) 워커 스레드는 한 번 깨어났을 때 큐에 있는 모든 메시지를 처리하려고 해야 한다. 메시지의 개수가 쌓이면 스레드 제어 이벤트와 처리해야 할 메시지 개수가 일치하지 않아 이벤트 발생이 씹힐 수가 있다.
        * 이 방법이 아쉬운 점: 개발자의 의도는 메시지 큐에 많이 쌓여있을 때 여러개의 스레드가 협동하여 메시지를 처리하는 형태이다. 그러나 이 방법은 실제로 남아있는 하나의 스레드가 모든 메시지를 처리하는 형태가 된다.(그러나 실제로 이렇게 동작하는지는 모름)
3. 종료 메시지
    1) 첫 번째: 워커 스레드만큼 종료 메시지 생성
    2) 두 번째: 종료 메시지를 받은 워커 스레드가 종료 메시지를 다시 EnQ 하며 다른 스레드에 전파하는 방법

## 코드 디버깅
### 힙
1. 힙 오류
    1) 상황: 힙 영역을 오염시킴
    2) Debug 모드: 힙이 할당 영역 앞뒤로 fd를 넣기 때문에 해제 시 문제가 될 수 있을 가능성이 크다. 그러나 다음 번 할당시에도 문제가 나올 수 있다.
    3) Release 모드: 앞뒤로 fd가 없기 때문에 힙이 깨질 가능성이 크다. 힙이 깨지면 다음 번 동적 할당 시 에러 날 확률이 높음

### Lock
1. 라이브러리와 컨텐츠 파트
    1) 라이브러리 파트는 항상 성능이 우선이기 때문에 문제가 일어날 법한 부분이 있다면 주석, 별개의 멘트를 남겨 코드에 대한 주의를 남긴다. 그래서 소수 정예로 간다. 
    2) 컨텐츠 파트는 여러 명이 거치는 자리이기 때문에 문제가 있을 만한 부분들은 확실하고 안전한 방법으로 동기화를 걸어 버려야 한다. (같은 자원에 대해 어디를 빼고 어디를 걸고하는 방식이 아닌 통째로 걸어버리는 방법) 

### WaitForMultipleObjects 함수
1. WaitForMultipleObjects 호출 시 입력된 스레드 핸들 배열보다 더 큰 수의 스레드 핸들 수를 입력하게 되면 WAIT_FAILED가 반환될수도 있고 성공할 수도 있다. 이는 WaitForMultipleObjects 내부에서 핸들 배열을 초과한 메모리의 값에 따라 결정된다. 초과된 메로리의 값이 유효하지 않은 핸들이라고 판단되면 함수가 실패할 것이고 우연찮게 유효한 값이라면 함수가 성공할 것이다.

# 비동기 IO
## IOCP
### IOCP
1. 프로세스 공유 목적이 아니라 SECURITY_ATTRIBUTES를 입력하는 인자가 없다.
2. 입출력 완료 포트: IOCP가 관리하는 완료 통지 결과, 입출력 완료 패킷가 쌓여있는 큐. 완료 통지 개수에 대한 제한이 없다.
    1) 어떤 Overlapped
3. IOCP의 스레드 풀(IOCP의 가장 큰 특징이다.)
    1) 작업자 스레드 중 대기(GQCS를 호출), 러닝, 블락 상태인 스레드들을 실시간으로 관리한다.
    2) 작업자 스레드 중 블락 걸린 스레드가 있다면 대기->러닝로 스레드를 깨워준다. (CPU를 놀리지 않겠다.) => 이 상황에서 블락된 스레드가 러닝 상태로 전환이 되면 그 순간 만큼은 NumberOfConcurrentThreads를 초과하여 스레드가 수행될 수 있다.
    3) Stack 방식으로 스레드를 깨운다. (컨텍스트 스위칭과 캐시 히트율을 높이기 위함)

### 워커 스레드
1. GetQueuedCompletionStatus(GQCS)를 한 번 이상 호출한 경우 IOCP의 워커 스레드로 지정된다. (즉, IOCP 객체가 관리한다는 의미)
2. 워커 스레드 내부에서는 비동기 IO를 걸어도 되고 안 걸어도 된다.
3. 워커 스레드에는 OVERLAPPED 구조체와 Key 값이 전달되는 것을 가지고 어떤 IO 작업인지를 판단할 수 있다.
4. 설계
    1) 최대한 IO 바운드를 하단부로 짜는 것이 좋다. (CPU를 최대한 사용 후 IO에 들어가는 것이기 때문)

### 함수
1. CreateIoCompletionPort
    1) 기능: IOCP 객체를 생성하고 디바이스를 IOCP에 등록하는 기능 두 가지가 있다. (소켓이라면 모든 소켓을 등록)
    2) 구조
        <pre><code>
        HANDLE WINAPI CreateIoCompletionPort(
            _In_     HANDLE    FileHandle,
            _In_opt_ HANDLE    ExistingCompletionPort,
            _In_     ULONG_PTR CompletionKey,           // 
            _In_     DWORD     NumberOfConcurrentThreads
        );
        </code></pre>
        * CompletionKey: 소켓마다 Key를 등록하여 찾을 수 있다.
        * NumberOfConcurrentThreads: 동시에 실행할 수 있는 최대 작업자 스레드 개수.
    3) 인자 NumberOfConcurrentThreads
        * 0을 지정한 경우 CPU 개수와 같은 수로 설정된다 => 논리 프로세서 
    4) 스레드의 생성 개수와 NumberOfConcurrentThreads 개수
        * NumberOfConcurrentThreads는 코어 개수 이하로 지정하는 것이 맞다. (왜인지 잘 고민해볼 것)
        * 스레드의 생성 개수: 답은 없다. 그러나 워커 스레드가 블락 걸릴 일이 많다면 워커 스레드를 애초에 많이 생성하는 방법을 생각할 수 있다.
2. GetQueuedCompletionStatus
    1) 구조 
        <pre><code>
        BOOL GetQueuedCompletionStatus(
            [in]  HANDLE       CompletionPort,
            [out] LPDWORD      lpNumberOfBytesTransferred,
            [out] PULONG_PTR   lpCompletionKey,
            [out] LPOVERLAPPED *lpOverlapped,
            [in]  DWORD        dwMilliseconds
        );
        </code></pre>
        * FALSE 상황: 디큐잉을 실패한 경우와 작업이 실패한 경우에 FALSE가 반환된다. 중간에 연결이 끊겼을 때는 lpNumberOfBytesTransferred가 0 이어도 TRUE를 반환한다.
3. PostQueuedCompletionStatus
    1) 
    2) 워커 스레드에 함수 종료 값으로써 0,0,0을 전달해주는 역할을 할 수 있다.

## 소켓 프로그래밍 도서
### 예제 분석
1. 보통 소켓에 대한 작업의 Key를 소켓으로 하지 않는다.
2. WSARecv에서의 lpNumberOfBytesRecvd에 대한 논의 recv, send에 대한 반환 크기
    1) Overlapped IO로 사용되는 경우 NULL을 입력하여도 된다.
        * 그러나! NULL을 입력하지 않게되면 또 다른 문제가 발생한다. 이는 추후에 설명해주신다 함
3. GetQueuedCompletionStatus
    1) dwMilliseconds를 INFINITE가 아닌 timeout 처리를 해놓았다면 문제가 생길 수가 있다.
        * 문제: out 파라미터인 lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped는 IO 완료 통지로 디큐잉 됐을 때 값이 반환된다. 디큐잉이 되지 않았다라면 혹은 실패했다면 값이 변경되지 않는다. 즉, 아예~ 건드리지를 않는다. Overlapped가 NULL이라면 디큐잉이 되지 않는 것이다.(MSDN 문서 참조할 것)
        * 그래서 lpNumberOfBytesTransferred, lpCompletionKey를 무조건 초기화(값 0)으로
        * 따라서 GetQueuedCompletionStatus 호출 시 함수의 리턴 값이 아닌 lpOverlapped가 NULL인지 아닌지를 검사하여 작업의 완료 여부와 소켓 여부를 판단할 것이다.(?!)
4. 테스트 방식
    1) 스레드들이 Block 되었을 때 실제로 대기 상태의 스레드가 Running 상태가 되는지 확인
    2) 깨어나는 스레드가 어떤 스레드가 되는지

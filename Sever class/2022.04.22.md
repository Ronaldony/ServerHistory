# 2022/04/22 수업내용(복습 완료)
## TCP 파이터 서버
### 프레임 관련 문제
1. 싱크 메시지가 발생한 시점에 비정상적인 싱크인지 정상적인 싱크인지 확인하기 위하여 싱크 메시지가 발생할 때 로그를 남겨야 한다.
    1) 프레임이 떨어져서 싱크가 발생한 경우는 정상적인 상황이다. 다만 현재 로직이 성능이 안 좋을뿐이다.
    2) 프레임이 떨어지지도 않았는데 싱크가 발생한 경우는 비정상적인 상황이다. 이 경우 문제를 파악하여 해결하면 된다.
2. 프레임 드랍
    1) 정확한 프레임 문제 발생 시점을 알기 위해서는 프레임 횟수와 같이 프레임의 최소, 최대 간격도 보아야 한다.
        * 예를 들어 프레임 횟수만 찍는 상태라면 서버 과부하로 인해 1초 동안 900ms동안 로직이 못 돌다가 100ms내에 갑자기 프레임을 채워지는 경우 이것 또한 정상적인 프레임으로 볼 수 있기 때문이다. 이 상황에서는 싱크가 발생한다.
3. 프레임 드랍 대처 - 클라의 방식
    1) 느려지면 느려진대로 프레임을 돌리는데 이때 지나온 시간(델타타임)만큼 이동과 충돌처리에 값을 곱하여 "한 번"에 처리하는 방법
    2) Fixed update: 앞의 방법과 같이 델타타임 기준이지만 프레임이 떨어졌을 때 기회가 있을 때 부족분을 지금 당장 채우는 것 => 하지만 프레임 부족분을 채울 때 단순하게 실제 시간 간격으로 처리를 하게되면, 정말 작은 시간 간격으로 처리되기 때문에 델타 타임이 0이 되어버린다. 때문에 이 상황에서는 충돌 및 이동처리는 정상적으로 처리되지 않는다.
        * 위 문제를 해결하기 위해 유니티에서는 Fixed Update에 프레임마다의 시간을 실제 시간이 아닌 원래 정상적이어야하는 프레임 간격의 시간으로 고정시켜 충돌 및 이동 처리를 맞춰준다.
        * 유니티는 위 방법에서 프레임 시간 간격인 Time이라는 전역 객체에서 Delta를 이용하여 구현한다. 또한 시스템 설정 중 Speed라는 것이 있는데 이것을 x배수로 하면 모든 것이 빠르게 돌아간다. 0이 되면 정지가 된다.
    3) 위 2번의 방법은 어떻게보면 프레임 기준 처리와 같아보인다. 하지만 정말 프레임 드랍이 심할 때 시간을 기준으로 이동 및 충돌 처리를 하기 때문에 어느정도 보정이 가능하다!
4. 프레임 드랍 대처 - 서버의 방식
    1) 이제는 클라가 좌표를 실수로 가기 때문에 서버도 실수로 처리가 되어야 한다. 이 때문에 프레임 기준으로 처리하기가 애매하다. 때문에 델타 타임만큼 "한 번에" 이동 및 충돌처리로 가야한다.(Fixed update X)
    2) 이동 및 충돌처리 위치 계산만 시간과 속도로 가고, 시간을 프레임 고정 간격 값으로 가는것이다. => 이 방식은 서버의 프레임이 떨어지면 게임 월드 자체의 시간이 느리게 가는 것 같은 효과가 난다. 이 방법에 문제는 없다. 그냥! 세계가 느려진 것이다.
5. 서버가 느려졌을 때의 처리 기준
    1) 애초에 프레임이던 델타타임 기준이던 서버가 느려지면 느려진대로 게임이 진행되는 건 어쩔 수 없다.

## 스레드 프로그래밍
### 최소 단위 오퍼레이션(=Atomic 연산자)
1. 정의: 연산 중 스레드 컨텍스트 스위칭이 일어나지 않는 최소 단위
    * 보통 어셈블리어 명령어에 해당하는데, 모든 명령어가 최소 단위 오퍼레이션은 아니다. 예를 들어 rep 같은 명령어
2. 스레드가 한 번 스케줄링(Running 상태)되면 최소한 Atomic 연산자를 1번 이상 완료한다.

### 스레드와 스케줄링
1. Block된 스레드 관리
    1) 의문: Block 스레드는 스케줄러의 관리 대상이 아니다. 하지만 어떻게 관리 되길래 Block 스레드의 개수가 어떻게 되든 시간 복잡도가 1일까? 또한 Sleep, IO 작업 등의 작업을 마친 후 어떻게 Block 상태가 해제되는 것일까?
        * Block 시간: Block 스레드를 관리하는 리스트에 삽입되는 순간부터 짧은 시간 순서대로 정렬하여 삽입하고 꺼낼때는 맨 앞단만 바라봄.
        * IO 작업: 커널 오브젝트가 Signal이 된다 라는 것을 처리하는 커널 스레드가 해당 오브젝트를 대기하는 스레드들의 Block된 상태를 해제 시킬 것이다. 해당 커널 스레드가 Signal 상태를 기다리는 스레드의 Block 관련 정보를 바꾼다.
        * 위에서 언급한 시간, IO 작업 등의 조건을 확인하는 스레드는 분명 커널 스레드이다. 이것밖에 없다.
2. 스케줄링을 포함하여 보통 커널 코드 자료구조들은 시간복잡도가 1이다.
3. 스레드의 개수는 제한이 없다. 물리메모리의 제한이 있을 뿐!

### 레디 큐와 우선순위
1. 한 번 레디큐에 들어간 스레드는 나올 수 없다. 또한 CPU가 100%가 아니면 대부분 레디큐가 비어있는 상태이다.
2. 현재 CPU에서 돌고있는 스레드보다 우선순위가 높은 스레드가 등장하면 레디큐에 들어가지 않고 바로 CPU할당을 받아 Running 상태가 된다. (돌던 스레드는 레디큐로 들어감)
3. 기아현상과 우선순위 부스팅
    1) 기아현상을 방지하기 위하여 강제적으로 OS가 개입하여 돌지못하는 스레드들을 돌린다. 방법은 다음과 같다.
        * 1초에 한 번 식 밸런스 셋 매니저 스레드(커널 스레드)가 레디큐를 스캔하여 준비 상태에서 4초이상 머물고 있는 스레드가 있는지 살펴본다. 이런 스레드가 있다면 우선순위를 최대치로 올리고 수행 후 다시 본래의 우선순위로 돌아온다. 밸런스 셋 매니저는 모든 레디 스레드를 검사하지는 않으며, 16개씩만 검사한다.(모든 스레드를 하면 부담이 되기 때문에) 또 한번에 최대 10개의 스레드에 대해서만 우선순위를 상승시킨다.
        * 이 정책의 수치는 암기하지 말고 개념만 익힐 것!

### 타임 슬라이싱
1. 스케줄러는 방금 작업이 끝난 스레드의 작업이 끊나면 레디 큐에 넣은 후 같은 우선순위의 스레드를 CPU에 할당한다. => 애초에 자신(CPU에 선점되었던)보다 높은 우선순위의 스레드는 레디큐에 존재하지 않기 때문
    * 같은 우선순위의 스레드가 없다면 같은 스레드가 또 다시 CPU를 할당받는다.
2. CPU 이용률이 낮다 => 레디 큐가 대부분 비어 있다.

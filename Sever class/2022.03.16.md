# 2022/03/16 수업내용
## 직렬화 버퍼
### 입력 데이터의 타입
1. 입력 데이터 타입 설계 방법
    1) 방법1: 직렬화 버퍼에 입력되는 데이터를 단일 된 컨텐츠 형식으로 전달하는 방법
        <pre><code>
        // 기본 구조
        void 프로시저 함수(CPacket* clpPacket)
        {
            ...
            *clpPacket << CPlayer;
        }

        CPacket operator << (CPlayer& player)
        {
            // 연산자 오버로딩 자체가 컨텐츠에 따라 하나의 프로토콜이 된다.
            unsigned char len = sizeof(CPlayer);
            
            *buff = len;
            
            *(buff + 1) = player.x;
            *(buff + 2) = player.y;
            ...
        }
        
        // 응용 사례
        아이템목록
        {
            unsigned char itemcnt;
            {
                int itemid;
                int item1;
                int item2;
                int item3;
            } * itemcnt;
        }
        
        MakePakcetItemList(list<ITEM*> ItemList)
        {
            Packet << ItemList;
        }
        </code></pre>
        * 특징: 직렬화 버퍼 자체가 하나의 프로토콜의 역할을 하게 된다. 사용자 입장에서는 메시지 입력이 자동화가 된 느낌
        * 장점: 단일 된 프로토콜로 같은 컨텐츠는 직렬화 버퍼에 한 번만 입력하면 된다.
        * 단점: 같은 컨텐츠라도 상황 혹은 유저마다 필요한 정보가 다를 수 있는데 프로토콜이 통일되다보니 필요없는 정보가 전달되는 경우가 있다.(통신비용 증가)

### 연산자 오버로딩
1. 연산자 오버로딩을 template로 구현하면 안 된다. 버퍼에 들어갈 데이터로 모든 타입을 허용하는 것인데 그렇게되면 정해진 프로토콜이 의미가 없다.

## RPC(Remote Procedure Call)
### RPC의 구조
1. RPC를 정한다는 것은 호출할 **함수**를 정하는 것이다. 이것 자체가 프로토콜이 되는 것이고, 보내는 데이터의 크기가 뭐다 순서가 어떻게 된다 라는 언급자체를 할 필요가 없다.
2. RPC가 포함하는 부분
    1) proxy 측: 메시지 생성 함수 호출 + 네트워크 송신
    2) stub 측: 네트워크 수신 + 메시지 파싱 후 메시지 프로시저 함수 호출
    * 위 기능들에 대한 처리는 내부적으로 알아서 구현
3. 보내는 측을 proxy, 받는 측을 stub이라 지칭한다.

### 직렬화 버퍼와 RPC의 관계
1. 직렬화 버퍼와 RPC의 관계: RPC의 개념은 proxy 에서 함수를 호출하면 stub 에서 특정 함수가 호출되는 것이다. 이러한 입장에서보면 프로시저 함수 혹은 메시지 생성 함수에서 메시지 프로토콜을 하나하나 입출력하는 방식은 맞지 않다. 즉, 컨텐츠 데이터 타입을 입력하면 직렬화 버퍼의 연산자 오버로딩 함수 내에서 프로토콜을 생성 혹은 출력하는 방법이 맞다.

### 구글, 프라우드넷 등의 회사에서 제공하는 RPC 코드 생성
1. 이렇게 제공되는 코드들은 애플리케이션의 함수 호출(switch-case포함) 부터 네트워크 송수신 부분을 모두 포함하고 있다.
    1) 장점: 사용하기 간편하다.
    2) 단점: 네트워크 송수신까지 포함되어 있기 때문에 성능상에 한계가 있다.
2. RPC 코드는 IDL 파일로 출력이 되어 이를 우리 프로젝트에 포함해야 한다.
    1) IDL 파일을 읽고 송신측과 수신측에 각각 함수의 .cpp, .h 가 생성되고 .cpp에는 호출까지 생성이 된다.
    2) 고민해 볼 사항
        * 새로 빌드할 때마다 수신측 즉 stub.cpp에 프로시저 함수의 내부가 새로 덮어질텐데 어떻게 해결할 것인가? -> stub.h에서 Stub 클래스를 생성하고 내부에 프로시저 함수를 가상 함수로 정의를 해놓는다. 우리의 코드에서 이 Stub 클래스를 상속하여 함수 내부를 구현하는 방법이 있다. 이는 프라우드넷에서 이용하는 방법이다.
    
### 동기 RPC, 비동기 RPC
1. 동기 RPC: 송신측 입장에서 메시지 생성부터 네트워크 송신을 하고 수신측으로부터 결과를 기다리는 형태
    * 절대 안 씀!
2. 비동기 RPC: 송신측 입장에서 메시지 생성 후 **송신 요청**까지만 하고 수신측의 결과를 기다리지 않고 다른 동작을 하는 형태

## 기타 키워드
### 패턴
1. 프록시 패턴
    1) Virtual 프록시: 주체(정보or리소스 관리)측과 요청(정보or리소스 요청)측 사이에 프록시 클래스를 두어 요청의 부하(적은 리소스 요청 등)가 적은 경우 프록시 클래스에서 해당 요청을 처리한다. 그러나 프록시 클래스가 판단하기에 요청의 부하가 큰 경우 해당 요청을 주체 측에서 처리하도록 하는 구조
    2) Protection 프록시: 안전 장치를 넣는 방법. 요청측이 주체측에 접근 시 중간에 있는 프록시 클래스가 접근에 대한 제어를 하는 역할
    3) Remote 프록시: 원격지에 있는 다른 컴퓨터의 함수가 호출되는 것(디자인 패턴 입장에서는 Remote 프록시, 구현의 입장에서 보면 RPC)
2. 옵저버 패턴
    1) 

### GPG
1. 배현직 대표가 작성한 RPC 기고문 찾아보기

### 빌드 이벤트
1. 명령줄: 실행 파일 실행 시 commanline에 입력하는 옵션 지정
2. 빌드 전 이벤트: 여기서는 컴파일에 포함할 소스코드를 지정한다.

### 포트폴리오
1. RPC 구조 자동화하는 것을 구현하면 포트폴리오에 작성 할 만 하다.
    * RPC 코드 생성은 메시지 생성부터 네트워크 송수신 메시지 수신까지 자동화시키는 것까지 하는 것이 기본이다.

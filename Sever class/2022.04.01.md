# 2022/04/01 수업내용
## 길찾기
### 길찾기
1. 구현: 2차원 배열로 그리드를 만들어 출발 지점에서 도착지점까지의 찾아가는 경로, 과정을 드로잉한다. 추가적으로 방해물(지나가지 못하는 길)은 마우스를 선택하거나 드래그 하였을 때 생성되도록 구현한다.
    * 타일이 너무 크면 갈 수 있는 경로가 별로 없기 때문에 적당한 크기의 적당한 크기로 지정해야 한다.
2. 모든 길찾기의 기본은 내가 왔던 길인가 안 왔던 길인가를 판단할 수 있는 기준이 있어야 한다.
3. 길찾기 시 지나왔던 경로를 파악하기 위해서는 월드좌표를 그리드 형태로 변환해서 지나온 경로를 저장해야 한다.
2. 보통 RPG는 길찾기의 비중이 크게 성능에 영향을 주지는 않는다.(비중을 무겁게 두지 않는다.)

### 탐색
1. 깊이 우선 탐색과 너비 우선 탐색
    1) 깊이: 일단 한 방향으로 끝까지 가보고 아니면 다른 방향으로 경로를 탐색하는 방법
        * 예시: 이동 방향을 스택에 저장하여 매 이동 시 첫번째 이동 방향이 항상 같은 방향이다.
        * 일반적으로 너비보다 더 좋은 결과가 나온다.(일단 목적지 끝까지 그려보기 떄문)
    2) 너비: 이동 시에 내 주변을 모두 훓어가면서 전체적으로 탐색해가는 방법(한 방향이 아닌 전체 방향을 순서대로 탐색)
        * 예시: 이동 방향을 큐에 순서대로 넣어놓고 이동 시에 매번 다른 방향으로 이동한다.

### 최적해
1. 어떠한 조건(경로가 정해진 상태, 그래프, 가중치 등의 조건이 주어진 상황)에서 가장 최적화된 방법을 선택하여 가는 방법이다.
2. 모든 최적해 방법은 CloseList, OpenList를 가진다.
    1) CloseList: 지나온 경로의 타일 모음(1번 이상 OpenList에서 꺼내진 타일)
    2) OpenList: 앞으로 가고자하는 타일 모음(생성되었지만 아직 밟지 않은), OpenList가 타일 노드를 리스트로 저장한 상태에서 이동하려는 x,y 좌표의 타일을 요청 시 F값이 가장 적은 타일을 전달할 것이다.
    3) List에서 전체를 훑어서 더 좋은 자리를 선택할 것이다. 타일의 X, Y 검색이 되어야 한다.
3. 더 좋은 자리의 조건 후보
    1) H: 목적지와의 거리가 가장 가까운 타일.
        * 해당 타일에서 목적지까지 거리를 구하는 방법에는 맨하탄(단순히 목적지까지 x 거리와 y 거리를 더한 값), 유클리드(직선 거리), 옥타일, 쳬비셰프가 있다.
        * 맨하탄을 제외한 나머지 방법은 상하좌우만 이동할 수 있는 경우에는 이득을 볼 수 있지만 대각선으로 이동할 수 있는 경우라면 오히려 성능이 떨어진다.(조사 필요)
        * 우리에게 H는 타일이 한 좌표라도 바뀌었더라도 값의 차이가 명확하게 나타나야 하는데 유클리드 방식은 삼각함수 방식이므로 차이가 없어진다. 이때 G와 더하여 F 값을 판단할 때 H의 가중도가 떨어지게 된다. 이렇게되면 오히려 최적해 탐색이 나오지 않는 경우가 생기게 된다.
    3) G: 출발지점부터 이동 지점까지의 거리가 짧은 타일. 프로그램 입장에서는 출발 지점에서 해당 지점까지 이동하는데 걸리는 횟수가 작은 것
        * 타일 하나 하나 마다 구조체로 만들어 그리드를 밟을 때마다 카운팅을 한다.
    * H와 G에 가중치(임의의 값을 +하거나 곱하기하든)를 주어 좋은 자리를 판단하는 기준이 달라질 수 있다.

### 브러쉬
1. 특정 경로를 패턴(서로 조합으로 경로가 될 수 있는) 그리드를 미리 만들어놓고 이것을 조합하여 

### 다익스트라 알고리즘
1. 이미 경로가 정해진 상태에서 현재 위치에서 어느 경로로 가는 것이 좋은 방법이냐를 선택하는 방법이다. 보통 NPC의 웨이 포인트 지점 길찾기의 기본이다.
    * 하지만, 유저나 전략 시뮬레이션에 적용하는 것에는 무리가 있다.(이동 지점을 예측할 수 없기 때문 => 매번 경로가 바뀜)
2. 이 알고리즘은 FPS의 AI를 구현할 때 적합하다. 이미 정해진 웨이 포인트(이동 지점)간의 이동 경로를 결정하게 된다.
    * 보통 깊이, 너비 우선 탐색의 기본이 된다.

### 에이스타 알고리즘
1. 다 익스트라와는 반대로 아무런 경로가 정해지지 않은 상태에서 실시간으로 경로를 찾아가는 방법이다.
    * 실시간으로 경로를 찾아가는 방법이기 때문에 다익스트라보다 훨씬 성능이 좋지 않다. 따라서, 두 방법을 상황에 따라 섞어 사용한다.
2. 목표 구현: 기본은 깊이 우선 탐색이지만 현재 타일의 주변 타일에 특정 속성을 추가하여 너비 탐색을 짬뽕할 것이다. 결국 경로에 가중치를 두어 최적해를 찾아가는 에이스타 알고리즘으로 만들 것이다.
3. 개선 방식
    1) 에이스타를 개선한 방식이 점포인트 서치이다.
    2) 에이스타 자체를 개량한다기 보다는 주변의 도구를 추가하여 개선하는 방향으로 간다.

### 에이스타 알고리즘-타일(최적해 적용)
1. 에이스타 알고리즘에서 타일은 다음과 같은 구조체 형태로 구성된다.
    <pre><code>
    NODE
    {
        *parent;    // 나의 타일을 생성한 타일 노드(부모 타일)
        TileX;
        TileY;
        H;      // 목적지와 내 타일의 거리
        G;      // 출발점으로부터의 해당 타일까지의 이동횟수(대각선 포함)
        F;      // G+H (이 값이 적은 경로로 이동할 것이다.)
    }
    </code></pre>
    * parent의 용도: 마지막 목적지 타일이 만들어지는 순간 경로 찾기는 끝난것이다. 이때 목적지 타일부터 parent를 거슬러 올라가며 출발지점까지 경로를 그려 나가는데 목적이 있다.
    * 해당 요소들은 부모로 인하여 타일이 생성되는 시점에 모두 정해진다.
    * 기본적으로 G는 부모의 G 값 + 방향에 대한 값(가중치를 둘 수도 있음)으로 정해진다.
    * H를 계산할 때 중간에 장애물이 없다 가정하고 값을 매긴다.
2. 경로를 생성하는 과정(장애물의 유무와 상관없이 동일하다)
    1) 최초 출발지점 타일 생성
    2) 주변 8방향에 타일 생성(이때 G 값은 부모 G + 1), OpenList에 저장됨
        * 생성 전에 openList, closeList에 타일 X,Y가 있는 경우 타일을 생성하지 않음
    3) F값이 가장 적은 방향으로 지점을 기준으로 주변 8방향 타일 생성
    4) 3을 반복하다가 목적지 지점에 타일이 생성되는 순간 길찾기는 종료된다.
    5) 목적지 타일에서부터 부모 타일을 타고 올라가며 경로를 결정짓는다.
    * 장애물이 있는 경우 OpenList에 있는 타일들의 정렬, 타일 지정 방법에 따라 타일 생성 순서가 달라질 수 있다.
3. 목적지 타일까지 만들어 경로를 결정할 때 출발지점까지 대각선으로 돌아가는 것을 해결해야 한다.
    * 이미지 추가할 것
    1) 방법 1: 대각선 방향에 타일을 생성할 때 G에 가중치를 준다.(직선은 1, 대각선은 1.5와 같은 방법으로)
    2) 방법 2: 특정 방향으로 타일을 생성하려고 할 때 이미 만들어진 상태라면, 내가 만들려고 했을 때의 G값과 해당 타일의 G값을 비교하여 해당 타일이 내가 만드는 경우일 때 G값이 더 작은 경우 의 부모를 끊고 해당 타일을 부모로 재설정한다.
4. 알고리즘 코드
    <pre><code>
    시작 SX, SY, EX, EY
    시작 노드 생성 -> openList
    
    // 이 방법은 목적지를 찾아갈 때까지 먹통이 된다.
    while(1)
    {
        p = opList F 값 작은 노드 POP
            closeList push
            if(P가 목적지?)
            {
                부모타고 경로 확인
                return;
            }
            
            p 기준 주변 8방향 노드 생성(속성 체크 open, close 여부) 및 openList에 추가            
    }
    </code></pre>

## 기타 키워드
### 길찾기 방법
1. 점프 포인트 서치(에이스타 개선 방식)

### 길찾기 포트폴리오
1. 검증 항목
    1) 최적의 길을 찾았냐는 것은 확인할 방법이 없다. 따라서, 모든 경로에 대해서 에러 없이 길을 찾아갈 것이냐를 검증해야 한다.
        * 깊이 우선 탐생르 미로 생성 알고리즘으로 사용(길을 뚫어버림)
    2) 성능: 멀티스레드 방식, List를 제거하는 방식, 캐시히트율 개선 등
        * 성능을 비교할 때 어떤 기준으로 성능을 테스트하느냐가 문제이다. 다른 사람이 만들어놓은 것? 표준적인 방법? 아니다. 내가 기준을 만들어 성능을 비교해보아야 한다. 예를 들어 가설을 세우는 것이다. 동접자들이 몇명이고 이동 행위를 x초에 몇 번 시도할 때 문제가 없는 길찾기의 방식이냐


# 2022/04/11 수업내용
## 시험 풀이
### 메모리 함수
1. VirtualAlloc, HeapCreate 함수 이리저리 사용해보기

### 소켓 모델 단점
1. AyncSelect
    1) 메인 스레드가 네트워크 통신으로 빠져버려 **멀티 스레드 환경**에서는 적합하지 않다. (즉, Winmain 루프 안에서 네트워크가 처리됨)
2. Select 모델의 단점
    1) 소켓 셋을 64개밖에 사용하지 못한다.
    2) Polling 방식

### RUDP
1. Unreliable한 부분을 커버해야 한다. 면접 시 언급 순서는 다음과 같다.
    1) 패킷의 재전송 및 순서 보장
    2) 토큰 발행을 통한 세션에 대한 구분. 세션에 대한 구분이 필요한 이유도 같이 언급해야 한다. (모바일 환경...)
2. UDP는 송신 버퍼가 없다. 그러나 수신 버퍼는 존재하기 때문에 하나의 소켓으로 여러 호스트로부터 데이터를 보내면 부하가 커져 부담이 된다.
    1) 멀티 스레드 환경에서 하나의 소켓으로 많은 유저의 정보를 받게되면, 멀티 스레드로 작동되기가 힘들어진다. 그래서 UDP를 쓰더라도 포트를 나누어 I/O를 등록하여 부하를 줄여서 쓰는 방법이 있다.
    * 우리는 TCP로 멀티 스레드 환경에서 하나의 소켓에 하나의 I/O를 등록하여, 소켓이 1000개라면 1000개의 I/O를 걸 수 있다. 우리는 이를 멀티스레드로 처리할 수 있게끔 만들 것 이다. (IOCP, overlap I/O) 
3. RUDP의 목적
    1) 예전: 홀펀칭의 용도로 사용되었다. (TCP는 세션 정보를 가지고 있기 때문에 홀펀칭이 불가능)
    2) 최근: 모바일 환경에서는 IP, Port가 유동적으로 바뀌기 때문에 IP, Port를 가지고 유저를 구분할 수 없다. 따라서, TCP의 연결 기준을 버리고 우리가 연결 기준을 만들어 원하는 수준까지 만들자 라는데 목적이 있다. (이 기준을 토큰, 세션이라 부름)

### 클라-서버가 연결이 안될 때
1. 클라-서버가 연결에 실패했을 경우 크게 백로그가 찼을 때와 3 Handshake 실패로 나눌 수 있다.
    1) 만약 클라와 서버 둘 다 가지고 있다면 우선적으로 클라의 상태를 확인해보는 것이 편하다.
    2) 백로그가 차서 실패: 클라 측 소켓 상태에 대한 아무런 정보도 없다.
    3) 3 Handshake 실패: 클라 측 소켓 상태가 SYN-SENT에서 한동안 머물다가, 사라진다. (한동안 머무는 이유: 연결 재시도)
    * 이후 서버에서 확인해야하는 사항은 Listen 소켓->방화벽->Ping 순으로 확인

## 길찾기
### 경로
1. 이동 불가능 지역
    1) 지형, 지물로 인한 것이 아닌 유닛 길막, 건물 건설 등의 이유로 인해 이동이 불가능한 지역이 생겼을 때를 고민해보아야 한다. LOL의 경우 길이 막혔을 때 막힌 지점에서 계속 비빔
        * 고정 지형, 지물로 이동할 수 있는 실제 경로가 하나 나오고, 오브젝트 유닛이 이동할 때 충돌 처리하는 대상이 경로를 막고있는 것에 대한 처리 두가지 Layer가 나오게된다. 
2. 막힌 경로를 이동하는 방법
    1) 이동 중에도 해당 경로가 뚫려있는지 지속적으로 길찾기를 해나가며 갑자기 유닛 등으로 인해 경로가 막힐 시 다른 길로 우회하는 방법
        * 이 경우에 유닛, 건물들의 위치까지 파악을 하여 경로를 설정해야하기 때문에 좀 짱구를 굴려야한다.
        * 이렇게 구현하려면 유닛, 건물은 지형지물과 같은 속성의 타일로 판단되어야 한다.
    2) 결정된 경로로 가다가 유닛들과의 충돌로 인해 길막이라고 판단되면 그때서야 다른 경로를 찾는 방법
        * 이 경우에 처음에는 고정 지형, 지물로만 길을 찾아 목표지점으로 가보아야 한다. 그러다 막히는 순간 다시 길찾기~
3. 완전히 막힌 경로 이동
    1) 방법1: 최초 고정 지형, 지물을 대상으로 경로를 찾아 이동을 하다가 막힌 길, 즉 유닛 혹은 건물로 인해 경로 이동을 불가능한 경우 다른 경로로 이동
    2) 방법2: 첫 번째와 반대로 최초 유닛 혹은 건물 오브젝트 대상 길찾기 -> 고정 지형, 지물 대상 길찾기
    * 이때는 기획자와 협의를 하여 결정해야 한다. 마냥 목적지를 향해 간다거나 애초에 출발을 하지 못하는 동작 등..
4. 경로 이동
    1) 전략 시뮬레이션 게임에서 미니맵을 클릭하거나 RPG에서 자동퀘스트하며 이동하는 경우에 해당 지점까지 정해져 있는 경로로 이동을 한다.(다익스트라)
        * 이 경우에 각 구간을 테이블화 시켜 정해진 구간에서 구간으로 이동시킨다. 하지만 구간과 구간 사이에서는 길찾기를 하여 자연스러운 이동을 구현한다.
        * 따라서, 대부분 길찾기를 하는 경우에는 근거리를 대상으로 하게 된다.
    2) 필드에서 땅을 클릭해서 이동하는 경우에는 길찾기

### 탐색
1. 탐색 범위 제한
    1) 필드를 기준으로 테스트를 통해 OpenList를 방문하는 횟수를 제한하여 무한 루프로 빠지는 위험을 예방
    2) 탐색하는 지역을 제한하여 그 범위안에서만 길찾기를 하는 것
    * 이 외에도 타일 노드의 개수 등의 특정 제한 기준을 만들어 특수한 상황에 대한 대비를 해두어야 한다.
    * 이렇게 제한하는 이유 중 하나는 마냥 맵을 키워 성능이 떨어지는 상황에 대한 대비를 하는 것도 있다. 
2. 구간 경로 테이블 
    1) 정의: 맵을 구간별로 나누어 미리 경로에 대한 테이블을 만들어 캐릭터를 이동시키는 방법
    2) 구간의 모든 경로를 저장하는 형태가 아닌, 현재 위치에서 갈 때 다음 경로로 가는 하나의 구간만 정하여 테이블을 만들어 놓는다.(모든 구간을 중복되지 않게 단 하나의 경로상에 놓는 것) 
        * 이때 구간-구간 이동 시 어떻게 자연스럽게 이동할 지 고민해보아야 한다. 예를 들어 다음 구간 이동 경로에 장애물이 있을 때 중심점이 아닌 자연스러운 경로로 이동하는 방법을 강구해야 한다.
        * 구간이 사각형이 아니어도 상관 없다. 곡선의 형태여도 구간마다의 경로 테이블만 정해지면 된다.
3. 지형 지물 길찾기는 큼직, 유닛 선택은 작은 그리드를 사용하여 
* 리니지는 아예 길찾기를 안 한다. 장애물 충돌 시 비비는 범위를 넓혀가며 뚫린길을 찾아간다.

## STL
### 공부
1. STL의 구현 내부 구조와 사용법
2. 도서: C++ STL 프로그래밍(최흥배, 한빛미디어) - 최신판 이전 판은 무료로 E-Book 다운로드 할 수 있다.
3. STL 종류
    1) list: list
    2) vector: 배열
    3) map: 레드블랙트리(key-value, pair를 사용하여 구현) => 정렬 시 선택
    4) set: 레드블랙트리(key) - Key밖에 없어 해당 정보가 있냐, 없냐만 확인이 가능하다.
    5) multimap: map + 다중키
    6) multiset: set + 다중키
    7) unordered map: 해시 테이블 => 정렬 필요없는 삽입과 탐색, 요즘 선택지는 이거
    * 면접 준비: 시간 복잡도는 무작정 외우고, 각각의 구조에 맞게 사용처나 장단점을 파악해두기!
    * priority_queue, Deck 등..
4. vector
    1) 가변적으로 배열 공간을 사용할 수 있다. 새로운 데이터 push 시 이전에 할당된 배열을 해제하고 
    2) capacity: 메모리의 확보량(size와는 다르다). vector에서는 미리 capacity만큼 할당하여 사용할 수 있지만 이건 고정 배열과 유사하게 돌아가는 것이다. 물론 인덱스에 대한 안정 장치 등이 있지만..
        * 강사님은 성능을 선호하기 때문에 vector를 선호하지 않는다. 하지만 요즘 프로그래머들은 안전과 편리성을 선호한다.
5. STL은 최적화 컴파일을 기준으로 설계되었다. 따라서, 성능 테스트를 한답시고 결과가 느리다고 할 수 없는 것이다.

### 구분자
1. list에서 sort 시 같은 값을 찾을 때 비교하고자 하는 두 수를 
2. map이 노드를 찾는 방법
    1) 비교자 함수(A, B)가 있을 때 마지막으로 비교한 경우가 false인 경우 해당 노드를 저장한 후에 왼쪽으로 이동 후 오른쪽 리프노드로 이동한다. 해당 리프노드와 비교한다 (수정 필요, 제대로 이해 안 됨)

### 플레이어 구분
1. 보통 플레이어 관리를 Account 번호(회원 번호)를 가지고 하지만 ID 등의 정보를 더하여 2중, 3중 정보 구조로 플레이어 관리를 하여도 된다.
    <pre><code>
    unorderedmap<__int64, CPlayer*> PlayerMap;
    unorderedmap<wstring, __int64> NickMap;
    unorderedmap<wstring, __int64> idMap;
    
    * 삽입, 삭제와 검색 빈도를 파악하여 다중 구조를 가져가야 한다.
    * 실제 예시: 로그인 처리 시, 중복 로그인..
    </code></pre>

### 이동 생성자
1. vector의 생성자 생성을 줄이고자 나온 개념이다.
    1) 
3. 포인터를 대상으로하는 객체는 아무런 의미가 없다.

## 기타 키워드
### Modern C++
1. 도서
    1) 전문가를 위한 C++(개정판-검은색) - 
    2) C++ 2020
2. 현재는 14, 17 정도까지만 적용하여 사용하고 있다.

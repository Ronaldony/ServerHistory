# 2022/05/02 수업내용(복습 완료)
## 스레드 프로그래밍
### 크리티컬 섹션
1. 크리티컬 섹션이 동기화 커널 오브젝트와 다른 점
    1) 완전한 유저 동기화 객체이다. 이전에는 이벤트 동기화 객체를 사용하여 스레드를 Block하였지만, 현재는 WaitOnAddress를 Wrapping하여 스레드 Block 전환을 구현하였다.
    2) 크리티컬 섹션이 점유당하지 않았다면 커널 모드 전환없이 해당 자원을 얻을 수 있다. 이게 가능한 이유는 가장 먼저 점유 상태를 유저 모드 단에서 확인하기 때문이다. 이때 스핀락을 사용하는데 일정 수만큼 스핀락을 하며 점유 상태를 확인한다.
        * 만약 일정 스핀락 횟수 이후에도 점유 상태라면 스레드를 Block 상태로 전환시킨다.
        * 스핀락을 활용하였을 때의 장점: 퀀텀 타임을 임의로 포기(임의로 Block되지 않고)하지 않고 퀀텀 타임 내(혹은 스핀락 횟수 내)에 자원의 소유권을 획득하였을 때 컨텍스트 스위칭 없이 유저 모드에서 자원 획득이 가능하다.
        * 스핀락 중에는 컨텍스트 스위칭이 일어날 수 있다! => 스핀락은 Atomic 연산이 아니기 때문 
    2) 대기 시간이랑 개념이 없다. 유저 동기화 객체들은 대기 시간이란 개념이 없다. 그래서 데드락에 걸리면 영원히 빠져나올수 없다.
    3) 특정 스레드가 자원의 소유권을 얻은 상태에서 같은 스레드가 다시 한번 더 같은 자원에 Lock 행위(자원 획득)를 하는 경우에도 데드락에 걸리지 않는다. (크리티컬 섹션 객체가 자원을 획득한 스레드를 기억하고 있기 때문)
2. TryEnterCiricalSection
    1) 사용중이 아니라면 자원 획득, 사용중이라면 자원을 획득하지 못하고 함수 리턴
3. 크리티컬 섹션의 역사가 깊다. 구조의 변경이 많이 일어났다. 그 이유는 크리티컬 섹션은 동기화 커널 오브젝트를 Wrapping한 녀석이기 때문에 성능을 개선시키기 위하여 작동 방식이 변경되었기 때문이다.
4. CRITICAL_SECTION 객체
    <pre><code>
    LONG LockCount;         // 점유 상태 여부
    LONG RecursionCount;    // 스핀락 카운트
    HANDLE OwningThread;    // 강사님 기억에 스레드 ID
    HANDLE LockSemaphore;   // 이벤트 동기화 커널 오브젝트(예전에 사용되었다, 지금은 내부적으로 WaitOnaddress를 사용하여 동기화)
    ULONG_PTR SpinCount;
    </code></pre>
    * LockSemaphore: 최초에는 생성되지 않고 있다가, 레이스 컨디션이 발생하면 CreateEvent을 호출하여 커널 오브젝트를 생성한다. 이 때문에 DeleteCriticalSection이 있는 것이다.
    * LockSemaphore의 문제점: 이미 크리티컬 섹션이 만들어진 상황에서 커널 오브젝트 생성에 실패하는 문제가 발생된다.
    * 위 LockSemaphore의 문제점을 해결하기 위하여 윈도우7부터 아예 커널 오브젝트를 사용하지 않은 유저 동기화 객체를 내놓기 시작하였다. 그것이 Kid event와 WaitOnAddress이다. 그러나 현재 Kid event는 사라졌다.

### 유저 동기화 객체
1. 모든 유저 동기화 객체는 자원의 점유 상태를 확인하기 위하여 InterLocked 함수를 사용한다.
2. 모든 동기화 객체는 선택적으로 커널 모드에 진입한다.
    * 스레드가 Block되는 동작도 커널 모드로의 전환이 일어난다.

### WaitOnAddress
1. 커널 오브젝트를 사용하지 않은 완전한 유저 동기화 객체이다. MS는 이 기법을 특허냈다.
2. 객체가 존재하지 않고, 주소 값을 가지고 동기화하는 방법이다. 당연히 스레드가 Block 상태로 전환할 때 커널 모드로의 전환은 일어난다. 그러나 지금 어떤 스레드를 잠재우고 깨울 것이냐 결정하는 것은 유저 모드에서 일어난다.

### 스핀락
1. 스핀락은 Busy waiting 기법이다. (Bysy waiting: CPU를 할당해가며 퀀텀 타임을 포기하지 않고 어떠한 동작을 대기하는 상태)
2. 사용처: 최근에는 유저 프로그램 수준에서는 스핀락을 사용하지 않는다. OS 쪽에서만 이 기법을 사용하여 구현한다. OS는 성능을 위하여 굉장히 단순한 자료구조를 바탕으로 만들어져있기 때문이다.
3. 스핀락의 장점과 단점
    1) 장점: 이게 당장 최우선인 상황에서 사용한다면 빠른 처리를 기대할 수 있다.
    2) 단점: 불필요하게 CPU를 점유한다.
4. 최근 유저 동기화 객체는 모두 스핀락 구조로 설계되어있다.
5. CriticalSection 내부에서 스핀락
    1) SpinLock을 하는 중간에 Pause 명령을 하여 CPU 레벨에서 옆 스레드에 명령어 처리 권한을 넘겨준다.
        * 위와는 달리 Sleep(0)을 사용하는 경우, 스핀락이라고 볼 수 없다. 스핀락은 퀀텀 타임을 포기하지 않고 퀀텀 타임 내에 실행 권한을 뺏자가 목적이기 때문이다.

### WaitForSingleObject 함수와 WaitForMultipleObjects 함수
1. 두개 이상의 스레드가 같은 동기화 객체를 기다리고 있는 상황에서 어느 스레드를 깨울 것인지 보장받지 못한다.(OS 마음)
    * MS에서도 깨우는 순서에 의존한 프로그래밍을 하지 말라고 권장한다. 계속해서 동기화 객체 동작 방식이 바뀌기 때문
2. WaitForSingleObject와 WaitForMultipleObjects
    1) 리턴값: WAIT_FAILED => 애초에 핸들 값이 이상한 경우
3. WaitForMultipleObjects 사용 시 유의 사항
    1) bWaitAll 매개변수에 FALSE를 입력하면 입력된 핸들 중 하나만 확인이 된다. 이 결과는 리턴 값 WIAT_OBJECT_x를 통해 알 수 있다.
        * 핸들 배열의 앞에 배치된 것부터 우선적으로 확인 시켜주기 때문에 중요한 오브젝트 핸들을 앞에 배치해야 한다. 빈번하거나 중요하지 않은 오브젝트 핸들을 뒤로 배치한다.
4. 커널 오브젝트의 상태를 확인하는 동작만으로도 커널 모드로의 전환이 필요하다.

### 세마포어와 뮤텍스
1. 뮤텍스는 클라이언트가 중복 실행되었는지 확인하는 목적으로 커널 오브젝트 동기화 객체를 생성할 수 있다.
2. 뮤텍스 관련 함수
    1) CreateMutex 함수를 사용하여 뮤텍스의 생성 여부를 확인하거나 생성할 수 있다.
3. 세마포어: 뮤텍스, 이벤트 동기화와는 달리 카운트 방식
    * 뮤텍스, 세마포어 동기화 객체는 아무도 절대 안씀!!!

### 스레드 디버그
1. 디버그 메뉴->스레드 메뉴를 통해 스레드의 정보를 모니터링 할 수 있다.
    1) 주의 사항: 브레이크 포인터를 걸고 F10을 눌러 진행하다가도 컨텍스트 스위칭이 일어난다. 해결 방법은 스레드 창에서 다른 스레드를 중지 상태로 변경한다. 만약 다시 동작해야하는 경우 재개 선택
2. gs: 스레드 정보와 관련한 데이터를 사용할 때 사용되는 세그먼트
3. 64비트에서의 호출 규약: 매개변수 전달을 스택에 하는 것이 아닌 레지스터에 저장한다.
4. 어셈블리 명령어
    1) pause(=nop): 하이퍼 스레딩 시스템에서 옆 스레드에 명령어 처리 권한을 양보하는 명령어(CPU 차원의 동작). 이는 해당 스레드의 동작이 멈춘다는 것이 아니다!!
        * 하이퍼 스레딩에서는 스레드마다 레지스터셋을 각자 갖지만, pause 명령은 OS 입장에서 컨텍스트 스위칭이라고 보지 않는다!!!
        * Sleep(0)과는 완전 다른 동작이다. Sleep(0)은 퀀텀 타임을 포기하고 컨텍스트 스위칭이 일어난다.
        * yieldprocessor 함수는 inline 처리되어 pause로 전환된다.
            <pre><code>
                YieldProcessor();
            00007FF6F51729E3  pause  
            </code></pre>

### 기타
1. printf, fwrite, fread 등 커널 모드로 전환하는 함수들은 '선택적'으로 커널 모드로 전환한다. 임시 버퍼에 저장을 해놓고 필요할 때 커널 모드로 전환하여 목적을 달성한다.
    * 우리도 이와 유사하게 링버퍼를 만들어 send와 recv를 수행한다.
2. 윈도우7 부터 크리티컬 섹션을 없애자!해서 나온 동기화 기법
    1) Kid Event(지금은 없어짐, 프로세스에만 속해있는 동기화 객체처럼 사용할 수 있는)
    2) Wait on Address: 모든 동기화는 이것으로 대체되었음
3. CriticalSection 함수 어셈블리로 분석해보기(+CriticalSectionContented)

## 기타 키워드

# 2022/05/18 수업내용
## 멀티 스레드
### 멀티 스레드 설계
1. 병렬 처리와 공유 자원
    1) 공격, 이동, 섹터 처리 등은 캐릭터 맵을 공유하기 때문에 병렬 처리가 불가능하다.
    2) 섹터 맵과 캐릭터 맵은 서로 독립적인 데이터 같이 보인다. 하지만 캐릭터 맵은 섹터의 정보를 내포하고 섹터를 계산하기 위해서는 캐릭터 맵에서의 좌표가 필요하다.
    3) 네트워크와 컨텐츠의 분리
        * 중간에 SendQ와 RecvQ가 있음으로서 서로 병렬적인 처리가 이루어질 수 있다. 네트워크는 RecvQ에 넣기만하고 빠지고 컨텐츠 쪽은 SendQ에 넣기만하고 빠지는 형태로 설계되어야 한다.
    * 잘못된 공유 자원에 대한 동기화는 CPU 사용률을 떨어뜨리고 스레드들이 서로 Block 걸리는데 시간을 허비한다.
2. 컨텐츠와 네트워크의 분리
    1) 컨텐츠 로직과 네트워크 중간에 Actor 패턴 구조로 RecvQ와 SendQ 자원을 동기화시켜 서로 분리시킬 수 있다.
        * 인큐의 경우 컨텐츠->네트워크, 네트워크->컨텐츠 어떤 방향이든 넣고 빠지는 비동기 방식으로 이루어져야 한다. 디큐 또한 데이터 검사 및 디큐 동작까지만을 동기화시키고 디큐한 데이터를 가지고 컨텐츠 로직 처리 부분은 비동기적으로 가야 한다.
3. 멀티 스레드 설계에는 어떠한 답은 없다. 단지 상황에 따라 최선의 방법을 선택해야 한다. => 암기가 아닌 원리의 이해가 필요

### 네트워크의 멀티 스레드
1. 네트워크 파트: 소켓 모델에 따라서 멀티 스레드 설계 방법이 달라져야 한다. (예시: eventselect는 소켓 셋 64개 씩을 전담하는 쓰레드를 다수 개를 생성하여 각각의 다른 세션 64개씩을 맡아 네트워크 동작을 수행하였다.) 
    * 네트워크 IO 스레드는 IOCP, Callback 방법 Overlap 등의 방법이 있다.
2. 최소한 보장되어야하는 사항: 하나의 세션은 하나의 스레드에 의해서만 처리되어야 한다. 즉 한 순간에 하나의 세션이 아닌 하나의 스레드에 의해서만 세션이 접근이 되어야한다는 것이다. 같은 세션의 SendQ와 RecvQ 서로간에는 동기화할 필요는 없다.
    1) SendQ나 RecvQ를 여러 스레드에서 접근하는 상황에서는 동기화가 이루어졌다 하여도 순서를 보장할 수 없다. 예를 들어 Q 진입 전 혹은 Q 내부에서 EnterCriticalSection을 호출하였다해도 EnterCriticalSection가 호출된 직후에 컨텍스트 스위칭이 일어날 수 있기 때문에 순서를 보장할 수 없다.
    * 이러한 특징은 멀티 스레드라서 나타나는 현상이다. 멀티 코어, 멀티 프로세서라서 생기는 문제가 절대 아니다! 싱글 코어에서도 똑같은 현상이 나타난다.
3. Stateless에서는 로직과 로직안에서 공유하는 자원이 없기 때문에 멀티 스레드 처리가 굉장히 쉽다.
    1) 아차피 서버의 고전적 모델은 1유저 1스레드이다. 새로운 유저가 연결되면 스레드를 생성하여 로직처리하고 파괴한다.
        * 아주 옛날 스레드 개념이 없던 시절 아파치 서버는 프로세스 스케줄링 모델이었다.

### 스레드 모델
1. 호모 지니어스와 헤테로 지니어스 
    1) 호모: 같은 일의 스레드를 여러개 생성하여 성능을 향상시키는 것을 목표로 함=> Stateless가 이 모델
    2) 헤테로: 다른 일의 스레드를 여러개 생성하여 성능을 향상시키는 것을 목표로 함=> Stateful은 이 모델
    3) 게임에서는 호모보다는 헤테로 지니어스 구조를 많이 활용한다.
2. Actor 패턴
    1) 메시지 전달 시 중간에 Q를 두어 생산자와 소비자가 따로 나뉘어져 일을 하는 형태

### 게임 서버 모델
1. 게임 서버 모델 1 (게임 로직은 하나의 스레드, 네트워크 IO는 여러개의 스레드로 설계, 이러한 구조를 싱글 스레드라고 부르기도 함)
    1) 모델 1
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169481374-60342890-c115-4351-8254-c6dae5385d87.png">
        * 게임 로직에서의 할 일: 수신 메시지에 대한 처리, 원래 프레임 로직
        * 이와 같은 구조는 코어 활용을 잘 하지 못한다. 그래서 옛날 게임들 중 이 구조를 가져가고 있다면 한 서버 컴퓨터에서 로그인 서버, DB 서버 등 여러 프로세스를 켜놓은 경우가 있다.
        * 이 구조는 멀티 스레드의 효과를 보기가 힘들다. 게임 로직이 하나여서 대부분의 부하가 게임 로직으로 치우쳐진다. 따라서 네트워크 IO가 아무리 빨라도 게임 로직 속도가 느리다면 소용이 없다. -> 게임 로직을 멀티 스레드로 설계가 되어야 한다는 결론이 나온다.
    2) 게임 로직을 멀티 스레드로 설계
        * 첫 번째 아이디어: 수신 메시지 처리와 프레임 로직 처리를 다른 스레드로 가져간다. -> 첫 번째로 수신 메시지 처리와 프레임 로직 처리는 공유 자원을 굉장히 많다. 두 번째로 프레임 로직 처리는 정해진 프레임만 돌고 쉴 것이다. 프레임 로직이 쉰다는 건 즉, CPU 레디큐 상태가 여유롭다는 것이다. 이러한 두 가지 이유 때문에 멀티 스레드로 나눌 이유가 없어진다.
        * 두 번째 아이디어: 결과를 도출하는데 오래 걸리는 기능, 함수를 스레드로 분리시키는 것이다. (아래 게임 서버 모델 2로 넘어감)
2. 게임 서버 모델 2 (게임 로직과 네트워크 IO가 여러개의 스레드로 설계)
    1) 게임 로직에서 스레드로 분리할만한 요소들을 찾아 비동기로 처리하는 것이다. Actor 패턴을 사용하여 길찾기 스레드에 일을 요청한다. => 큐잉, 디큐 작업의 부하가 스레드를 분리하는 것보다 더 커지게되면 분리한 의미가 없어진다.
        * 분리할만한 요소는 길찾기, DB 등이 있다. 해결해야할 문제는 길찾기에 대한 마무리 로직 처리가 완료되지 않는 것이다. 길찾기 스레드에 일을 시키고 다른 유저, 다른 컨텐츠 일을 하러 가게 되는데 길찾기가 완료가 되면 그때서야 마무리 작업(걷기 동작, 결과를 어딘가로의 send 등)을 해야 한다. 또한, 길찾기가 완료 되기 전에 유저의 요청이나 외부 요소로 인해 다른 동작을 해야 하는 상황에도 대비해야 한다.
        * 충돌처리는 비동기 처리가 애매하다. 이유로 지금 당장 내가 누굴 때렸는지 알아야 하는데 비동기는 결과가 언제 나올지 모른다. 그리고 이것에 대한 실질적인 로직을 처리할 때 update의 로직과 비동기 로직 측에서 같은 자원을 사용하여 동기화를 해야하는 상황이 된다면 비동기라고 하기엔 맞지않다.
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169502098-51db9959-7044-47f5-a784-7403d1ef5dfc.png">
    2) 비동기 작업을 완료하여 결과를 받을 때 게임 로직의 request 큐는 하나여야 한다. 캐릭터마다 큐를 놓게되면 하나하나 순회하며 결과가 완료되었는지를 검사해야하기 때문이다.
        * 또한 비동기 작업 완료를 확인하는 부분은 Polling 방식이 되어야 한다. 기본적으로 게임 서버는 일반 프레임에 대한 작업이 있기 때문이다. 그래서 이와 같은 구조에서는 비동기 스레드에 요청을 하는 코드와 결과를 받아 마무리하는 코드 두 덩어리가 나와 더러워지고 버그도 많아질 것이다.
    3) 스레드 분리를 하게될 때 이점을 정확히 판단해야 한다. 스레드를 분리함으로서 큐잉 등의 부가적인 작업으로 인해 오버헤드가 생겨 CPU 사용률이 증가하는데, 이러한 점을 감수하고도 할 가치가 있다면 하는 것이다.
3. 서버가 느리다의 의미 => 처리가 느리다의 의미 -> 함수 return이 느리다.
4. 길찾기 스레드 분리
    1) Case 1: 길찾기 결과를 각자의 캐릭터에 존재하는 큐에 적재하는 형태. 단점은 순회를 해야 한다.
    2) Case 2: 길찾기 결과를 하나의 큐에 적재하고 하나의 길찾기를 요청한 마무리 작업 또한 요청자가 해야 한다.
    * 나중에는 DB, 갓챠 등을 분리할 수 있다.

### 네트워크 라이브러리
1. 우리가 네트워크 라이브러리의 성능에 대한 논의를 할 때 recv, send에 대한 수치밖에 없다. 이러한 성능 측적은 echo를 통해 확인한다.

### CPU 사용률
1. CPU가 100%라면 레디큐가 쌓였다는 얘기이고 아니라면 그 반대이다. 100%에 도달하게 되면 다른 스레드에 시간 측정 등의 기능에 영향을 주게 된다.
2. 오해: 동기화 락, 경합으로 인해 CPU 사용률이 오른다? -> 틀렸다. Block이 걸리기 때문에 CPU 사용률은 증가하지 않는다.
    * 애초에 멀티 스레드 설계를 잘못했다면, 아무리 사용량 요청이 많아도 CPU 사용률이 오르지 않는다. => 스레드가 정상적으로 돌지 못하는 상황이다.
    * 예시: 설계가 잘못되면 동접수가 늘어나도 CPU 사용률이 어느정도 오르고 말 것이다. 이 얘기는 스레드들이 Block되고 할 일을 제대로 못하고 있다는 것이다.

### 동기와 비동기
1. Non-block 소켓은 비동기가 아니다. WOULDBLOCK 동작 또한 비동기가 아니다. 비동기라는 것은 요청만 하고 함수를 리턴 받은 상황에서도 일이 다른 곳에서 이루어지고 있는 상황을 이야기 한다.
    1) Non-block 소켓은 그저 할 수 없으면 하지마세요 의 동작이다.
2. Overlap IO를 사용하면 recv, send가 비동기적으로 이루어진다.
    1) Overlap IO를 이용한 IOCP는 어렵다. IOCP가 어려운게 아니라 Overlap IO가 어려운 것이다.
    2) 나중에 결과가 오기 때문에 오작동이 많이 난다. 아까 요청했던게 결과가 나왔는데 다른 애가 덮어 써버린 경우가 즐비하다. 해당 문제를 해결하기 위해 상당한 시간을 쏟아부어야 할 것이다.

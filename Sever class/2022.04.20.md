# 2022/04/20 수업내용
## TCP 파이터 서버
### 캐릭터 동작
1. 피격 판정 시점: 네트워크 환경에 따라
    * 마영전에서는 먼저 클라에서 피격되는 것처럼 렌더링하고 그 이후에 서버에서 충돌에 대한 결과를 보내주면 데미지의 유무, 피격 판정이 최종적으로 결론지어진다.

### 과제
1. TCP 파이터 서버 기능에 30초 타임아웃 넣기
2. 더미 프로그램 - 모니터링 정보
    1) Error: 클라에서 connect 시 오류 횟수
    2) 프레임: 초당 게임 로직 순환 횟수, 루프: 전체 루프 순환 횟수
    3) Discconect from Server: 서버에서 끊은 경우, 현재 더미 프로그램에서는 나와서는 안된다. (Timeout, HP로 인해 끊긴 것은 카운팅되지 않는다.)
    4) Chracter Count: 캐릭터가 생성된 수, Session Count와 정확히 동일한 개수여야 한다.
    5) Waiting for Timeout: 타임아웃 유저 수와 시간
    6) Loop/sec: 초당 더미의 루프백 횟수, 100 이상은 나와야 한다. 
    7) Packet/sec: 초당 서버로 부터 받은 패킷의 횟수(강사님은 1000명 일 때 평균4800 정도가 나왔다.)
    8) Sync Message Count: 더미가 서버로부터 싱크 메시지를 받은 횟수(하루 몇십 건은 괜찮음). 이 수치가 증가되면 
    9) RTT: 서버로부터 받은 에코패킷 RTT. 초당 횟수 측정 4 / 21 / 24 
3. 서버 프로그램 - 모니터링 정보
    1) 프레임, 루프 수
    2) 메시지 개수
    3) 세션 수, 캐릭터 수
        * 1초에 한 번씩 모니터링 정보 출력하기
4. 주의 사항
    1) 로그를 파일로 저장할 떄 디펜더를 꺼야 한다. 가끔씩 디펜더가 랜섬웨어 문제로 해당 파일을 검수하기 때문에 느려진다.
        * 예전에는 서버 OS에는 백신 프로그램이 없었다. 20xx부터 백신 프로그램을 추가하였다.
    2) 모든 플레이어들은 최대 80초를 플레이어하고 게임을 종료한다.
    3) 더미 프로그램을 종료했을 때 서버와 더미 프로그램 모니터링 정보(예를 들면 유령 세션 수..) 다르다면 문제 파악 정확히 할 것
5. 목표치: 7000명

## 스레드
### 하이퍼 스레딩(=논리 프로세서)
1. 프로그램 입장에서는 하이퍼 논리 프로세서를 Core로 보면 된다. 즉, 논리 프로세서를 기준으로 스레드를 설계해야 한다.
    * OS 입장에서는 실제 Core 수를 알 수 없다. OS는 논리 프로세서를 기준으로 스케줄링을 한다.

### 스레드의 사용 목적
1. 향상된 안정성
    1) 책에서 서브시스템이 작동을 멈추는 경우를 대비하여 멀티스레드를 사용한다고 하였는데, 실제 서버에서 일어날 수 있는것인지 생각을 해봐야 한다. 실제적으로 우리가 걱정해야하는 것은 메모리 참조 오류이다. 
        * HA(고 가용률) 시스템: 서비스 되고있는 서버에 오류가 있는 경우 ,가용률 100%이란 24시간 어떤 상황이던 => Master가 죽으면 Slave로 교체하여 가용성을 높일 수 있다. 실제로는 앞단에 Proxy를 두고 Master와 Slave를 Proxy에 연결한다. => 하지만 이 또한 소프트웨어 입장에서는 같은 소프트웨어이기 때문에 똑같은 입장(똑같이 죽을 것)이라고 본다. 이는 하드웨어 입장에서 대비하는
2. 작업의 빈도-스레드 스케줄링
    2) 작업 관리자에서 나오는 CPU 이용률은 OS가 측정한 1초 동안 CPU를 사용한 시간을 구한 비율이다. 하
        * 어셈블리 언어 명령어 중 동기화를 맞추기 위하여 CPU에서 Block(전기를 안 먹는 상태)을 하고 기다리는 상태이다. OS 입장에서는 이러한 상황을 판단하지 못한다.

### 스레드 스케줄링
1. 퀀텀 타임, 타임 슬라이스
    1) 정확한 수치를 언급하는 책이나 자료는 없다. 윈도우 시스템 프로그래밍에서는 약 20ms라고 언급한다.
    2) 서버용 OS가 일반 OS보다 2배 정도 길다.
        * 애초에 일반 OS보다 라이브되는 프로그램이 적기 때문에 굳이 퀀텀 시간이 작을 필요가 없다. 
    3) 퀀텀 타임을 모두 쓴다는 것은 해당 스레드가 퀀텀 타임동안 하나의 코어를 100% 점유했다는 이야기이다.
        * 보통의 스레드들은 I/O 요청으로 인해 퀀텀 타임을 포기한다.
2. OS 스케줄러는 기본적으로 스레드가 어떤 프로세스에 해당하는지 따지지 않고 스케줄링한다.
    1) 프로세스 선호도: 할 수 있다라면 특정 CPU에 할당해주세요 라고 요청은 할 수 있다.
3. 동일한 프로세스의 스레드를 실행하는 경우, 동일한 가상 메모리 테이블을 바라보기 때문에 다른 프로세스의 스레드를 수행하는 것 보다 조금 더 빠른 동작이 이루어진다.(특정 레지스터의 교체로 인해 캐시 메모리가 비워져야 한다.)
4. 컨텍스트 스위칭
    1) 레디 큐에 있는 최상 우선순위의 스레드를 스케줄링한다.
    2) 명령어에 대한 캐시된 구조들이 CPU 내부적으로 저장되어 있는데 스레드 컨텍스트 스위칭이 이 모두가 교체되는 상황이 온다.
    * 강사님의 궁금증: 스케줄링의 정체. 스케줄러 또한 프로그램일텐데 보통 책에서는 그것에 대한 언급이 되지 않는다.
    * 요즘 CPU에서는 고성능, 저전력 코어를 구별하여. 이 기능을 위하여 OS와 CPU가 통신하게 된다.

### 기타
1. 고장
    1) 3년마다 한 번씩 서버를 갈아준다.
2. CPU와 클럭의 관계
    3) 전원 옵션->고급 설정-> 프로세서 전원 관리
    * 최소 프로세서 상태-균형 조정: 이 항목에서 설정 값은 클럭

## 기타 키워드
### 

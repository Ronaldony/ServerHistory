1. 확률
 1) rand() 사용 시 문제점: rand() % 100 에서 100을 나머지 연산으로 계산하면 난수의 분포도가 흐트러진다. => 처음부터 seed의 값을 100이하로 설정하는 방법이 있음.
 2) 아이템 확률 분포 방법
  2-1) 각 아이템과 확률을 배열로 구성한 후 rand()의 결과 값을 배열에 저장되어 있는 확률들과 비교하여 아이템 출력
  2-2) 횟수 카운팅하여 지급. 예를 들어 확률이 1%이면 100번째에 지급
  2-3) 아이템에 대한 확률 분포를 미리 배열에 저장해 놓고 섞는다. 이후 카운트를 사용하여 배열의 인덱스에 입력하여 아이템을 출력한다.
  2-4) 나온 아이템에 대한 확률을 감소시키는 것
  2*) 확률에 대한 결정은 기획자와 협의하여 결정
  2**) 손 코딩이 가능한 수준으로 연습해야함

2. 공용체(union)
 1) 각 요소가 같은 메모리를 할당한다.
 2) 윈도우즈 API에 LARGE_INTEGER 구조체에 사용됨 (현재는 QuadPart만 사용됨)
 *) 잘 사용하지 않음

3. 비트필드
 1) 자료들이 비트 단위로 구성된다.
 
4. 메모리 영역
 1) 지금의 OS에서는 가상메모리 체계를 지원한다.
  1-1) Page In: 가상메모리에서 Commit 상태의 Page를 실제 RAM에 할당된다. (MMU를 통해서?). (Page는 Free, Reserve, Commit 상태가 존재)
  => 메모리에 ?? 값 -> Free, Reserve 상태. 특정 값(0도 모함) -> Commit
  => Reserve을 하는 이유: 4KB 이후 연속적인 일부 공간에 reserve 상태를 부여하여 다른 프로세스가 사용하지 못하게 하기 위함이다. (Stack의 경우 한 번에 기본 1MB를 모두 할당하지 않고 초기 4KB를 제외한 나머지 공간을 Reserve 상태로 전환한다.)
  1-2) Page Out: RAM에서 많이 사용되지 않는 공간은 Disk에 내려 RAM 공간을 최대한 확보한다. (가상 메모리의 안전성과 연관이 있다.)
  1-3) 실제 유저 프로그램으로 사용될 수 있는 공간은 RAM의 1/2 크기이다. 나머지 1/2은 OS 커널에 할당된다. (조사 필요)
  1-4) 0x86에서는 페이지를 4KB 기본 단위로 설정한다.(12bit) 따라서, 가상메모리와 RAM 단위에서 페이지의 단위의 주소는 0x1000 단위로 나누어진다.
  => 가상 메모리 Page의 주소 정보(Entry 정보)는 커널 메모리에 존재한다. Page를 12bit 단위로 할당하기 때문에 주소값 크기에 대한 부담을 아낄수 있다. offset은 Page(12bit) 내 세부적인 주소에 대한 개념이다.
  
 2) Heap은 영역에 대한 지칭이 아닌 메모리 관리자이다.
  2-1) C++에서 new 동적 할당 시 malloc, HeapAlloc, Virtual Alloc을 실행 (가상 메모리 할당. Page의 상태를 변경한다? -> 조사 필요)
  2-2) Heap은 가상 메모리 할당에 대한 관리를 해주는 역할을 한다.
 *) Heap, Stack 영역의 reserve, commit 크기 설정은 프로젝트 속성->링커->시스템에서 수정 가능하다.
 
 3) Stack의 경우에는 CPU에서 프로세스의 동작에 따라 커널에서 예외적인 동작으로 인식하여 확보하는 공간이다. (메모리 할당 과정을 코드 단에서 분석할 수 없음)
 
 64k = 2^16
 4G = 2^32

Reserch 필요
1-1), 1-3), 2-1)


질문
1.alignas에 대한 MSDN 설명 중 "데이터가 맞춰져 있지 않으면 CPU가 더 많은 주소 계산 작업을 수행하여 데이터에 액세스한다." 는 무슨 의미인가?
=> 예를 들어 32bit의 캐시 라인이 있을때 64로 align 되어있는 주소값을 엑세스하기 위해서는 2번으로 나뉘어 주소 계산이 이루어져야 한다.
2. 가상 메모리에 4Kb 단위로 Page를 나누는 것은 32bit OS의 기본인 4byte 경계로 나누는 것과 연관이 있는것인가?
=> 아니다. 캐시 메모리와 연관있는 것이다.
3. Page는 메모리 풀이라고 할 수 있는가?
=> 아니다. 메모리 풀은 메모리 공간을 미리 할당하여 놓고 동적으로 분배하는 개념이다.
4. 프로그래머는 Stack, Heap 공간에서 Offset 공간 내에서 프로그램을 실행시키고 있는것인가?
=> 그렇다. 프로그램의 크기가 커지면 Page의 수도 증가하며, 페이지들마다 Offset에 대한 정보가 주어진다.
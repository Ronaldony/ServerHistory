# 2022/04/06 수업내용
## 길찾기(Jump Point Search)
### 구현
1. 코드
    <pre><code>
    while(1)
    {
        Node = OpenList pop();
        목적지이낙?
        closeList.push(..);
        
        if(Node 부모 == NULL)
        {
            방향 코너 확인(Node.x, Node.y - 1, UP);
            ... // 8방향 코너 확인
        }
    }    
    
    switch(부모로의 방향)
    {
        case UP:
            // 기본 방향 검사
            방향체크(x,y-1,UU); 
            // 속성체크 (inline이나 매크로를 사용할 것)
            오른쪽이 막혔고 오른쪽 위 대각방향 코너 확인
            왼쪽이 막혔고 왼쪽 위 대각방향 코너 확인
            break;
        case RD:
            // 기본 방향 검사
            방향체크(x+1, y+1,RD);  // 오른 아래 대각
            방향체크(x+1, y,RR);    // 오른 
            방향체크(x, y+1,DD);    // 아래
            // 속성체크
            오른 아래, 오른, 아래 방향에 대한 속성 체크
    }
    
    // 방향체크하는 함수와 코너를 검사하는 함수를 분리하는 것이 더 깔끔할 수 있다.
    방향체크(x, y, Dir)
    {
        case RR:
            if(코너확인(x, y, Dir, &MX, &MY)
            {
                노드 생성(MX, MY, Node); // MX, MY에 노드 생성
            }
        break;
        case RU:
            // 대각 방향의 경우에는 코너확인이 수직 수평과 달라진다.
            // 대각 코너를 이 자리에서 확인하고 해당 대각의 수평 수직 방향 확인에 대해서는 코너확인을 들어간다.
            if(코너확인(x,y,Dir,&MX, &MY)
            {
                // 원래의 대각 방향 검사 자리 x, y 자리에 노드를 생성하는 이유는
                // 대각 방향의 수평 수직의 코너에 가 있는 경우 대각 방향 확인 자리에 노드를 생성해야 
                노드 생성(x, y, Node); 
            }
        break;
    }
    
    // 재귀로 만드는 방법이 있는데 이는 좋은 방법은 아니다.
    코너검사(x, y, Dir, *OutX, *OutY) // 오른 아래 대각선 코너 체크
    {    
        switch(Dir)
        {
            case RR:
                // 속성 체크
                위아래 벽과 오른편 위아래 대각 방향 코너 검사
                // 코너 확인 여부
                if(코너 == true)
                {
                    *OutX = x;
                    *OutY = y;
                    return true;
                }
                else
                {
                    x++;
                }
            break;
            case RU:
                // 속성 체크
                위아래 벽과 오른편 위아래 대각 방향 코너 검사
                // 코너 확인 여부
                if(코너 == true)
                {
                    *OutX = x;
                    *OutY = y;
                    return true;
                }
                else
                {
                    x++;
                }
            break;
        }
    }
    </code></pre>
2. 점프 포인터의 문제점
    1) 노드 생성을 줄였지만 속성 체크가 너무 많이 들어간다. 그래서 최대한 속성체크를 매크로나 inline으로 구현해야 한다.

### JPS 개선
1. JPS를 개선시킨 것이 JPS+이다. JPS+는 미리 코너를 만들어둔다.
    * 하지만 이는 코너가 바뀌면 동작하지 않는다.(다 익스트라와 유사)

### 에이스타
1. 에이스타에서의 문제점
    1) 실시간 노드 생성으로 인해 성능이 떨어짐. 맵 전체에 노드를 생성하고 처리한다.
    2) CloseList의 존재여부: 사실 굳이 CloseList가 필요없다. 우리에게 필요한 건 해당 노드를 방문했냐 안했냐이기 때문이다. 따라서, 맵에서 xy좌표를 방문했냐 안했냐만 알려주면 된다.
    3) 부모를 바꿔 최단 경로를 바꿀 때 CloseList를 검사할 필요가 있냐? => 없다. 이미 지나온 결로이기 때문에 OpenList에서만 확인하면 되는 것이다.

### 실제 적용
1. 우리가 만든 8방향의 길찾기를 실제로 적용할 수 있느냐? -> NO, 요즘 게임의 움직임은 8방향이 아닌 전 방향이기 때문에 사용할 수 없다. 따라서, 도착지점 타일 생성 후 경로를 만들 때 다시 최단 경로를 구해야 한다.
    * 방법: 부모 노드를 타고가며 직선을 그어보며 막힐 때까지
2. 직선을 긋는 방법
    1) 기울기를 구한다. 변화량이 큰 축(x,y)을 기준으로 증가시키며 반대 축을 구하여 점을(점의 연결=직선) 그리는 방법이다.
    * 직선을 그으려면 실수적인 계산이 이루어지기 때문에 성능이 안좋은 옛날에는 브래즈 먼이 고안한 브래즈넴 알고리즘을 발명했다.(정수만으로 직선을 긋자) 


### 브래즈넴 알고리즘(블헤즌헴)
1. 기울기를 구하여 변화량이 큰 축을 기준으로 증가시키며 반대 축을 언제 증가시킬지 고민하는 것이다.
2. Error라는 개념을 사용하여 변화량이 적은 축의 ~~
    * Error라는 값을 변화량이 적은 축의 좌표를 더하다가 Error 값이 변화량이 큰 축과 같거나 넘는 경우 변화량이 적은 축을 1 증가시킨다. Error
    * 해결해야하는 문제: X좌표가 100, Y좌표가 1인 경우  
3. 구현
    <pre><code>
    Line(SX, SY, EX, EY)
    {
        DX, DY;

        for(..)
        {
            x++;
            Error += DY;
            if(Error...)
            {
                Y++;
                Error -= DY;
            }
        }
    }
    </code></pre>
4. 써먹을 수 있게 클래스화 시켜서 만들어 놓기 => 사용자에게 직선들의 좌표를 어떻게 반환해줄 것이냐?에 대한 모인기 필요하다.
    * 방법 1: 요즘 스타일은 iterator를 반환시켜 
    * 방법 2: 클래스 내부에 멤버변수를 좌표를 차례대로 반환하는 



## 기타 키워드
### 메모리와 성능
1. 대부분 성능을 위해서는 메모리를 포기해야 한다.
2. 서버는 메모리 확장 시 팀내에서 해결할 수 있지만 클라의 경우 유저의 PC완 관련이 있기 때문에 기확자와 논의를 해야 한다.

### 과제
1. 브레즈넴으로 선 긋기 구현

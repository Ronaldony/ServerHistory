# 2022/05/20 수업내용(복습 완료)
## 멀티 스레드
### 멀티 스레드 모델 예시 1(가칭, IOCP x)
1. 길 찾기를 멀티 스레드로 가져가는 경우(이전 시간에 이은 논의)
    1) 만약 길 찾기 스레드의 requst 큐가 스레드마다 있을 때
        * 단점: 게임 로직 스레드가 request 큐에 넣을때마다 어떤 길찾기 스레드의 큐에 넣을지 Dispatching을 해주어야 한다. 이는 윈도우 10 이전 레디큐와 같은 구조이다. 그래서 10부터는 코어들을 그룹으로 나누어 레디큐를 관리하게 된 것이다.
        * 위 단점으로 인해 길 찾기의 스레드가 몇개이든 request 큐를 하나만 가져가야 한다.
2. 네트워크 IO와 게임 로직 스레드가 호모 지니어스 형태의 멀티 스레드인 경우
    1) 게임 로직<->네트워크 IO 사이 request 큐가 하나인 경우: request 큐가 하나라면 게임 로직에서 일을 무작위로 가져가기 때문에 같은 세션에 대한 로직 처리 완료 순서가 보장되지 못한다. 
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169540816-28bb635c-f308-4412-8de2-599f90b3d5d3.png">
    2) 게임 로직<->네트워크 IO 사이 request 큐가 각각 있는 경우: 네트워크 IO에서 각각의 request 큐들에 정해진 세션에 대한 정보를 전달하고 이를 처리하는 형태
        * Request 큐에 세션 정보를 배치할 때 라운드 로빈, 큐 부하 측정 후 분배 등을 선택할 수 있다. 그러나 최초 배정 이후에 해당 세션 메시지가 들어올 때마다 매번 어느 Request 큐로 넣을지 판단하는 과정이 들어가게 된다. 이러한 판단 과정을 Hashtable 형태든 어떠한 관리 구조가 또 나와야 한다.
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169542185-97e74fc2-0c10-4a57-8e50-b0d6a13828ae.png">
3. 스레드는 Block이 걸려야하는 상황이 된다면 걸려야 한다. 우리가 항상 고민해야 하는 것은 CPU가 놀지 못하게 그동안 다른 일들을 처리하는 것이다.

### 멀티 스레드와 컨텐츠 요소
1. 이 절에서는 위에서 언급한 멀티 스레드 모델1에서의 상황을 가정한다.
2. 컨텐츠 요소인 맵, 필드, 던전 등의 공유 자원을 사용하는 상황
    1) 던전, 필드 등은 해당 인근 또는 인스턴스 던전 안에 있는 유저들 끼리만 동기화에 대한 영향을 받으므로 동기화 락 단위를 던전, 필드, 맵으로 가져가 통째로 써버려야 한다.
    2) 만약 유저가 1000명 이상 + 게임 로직 스레드가 10개 + 던전 스레드가 500개라면? 경합의 빈도는 굉장히 적을 것이다. 그러나 던전 스레드가 50개로 줄어든다면 경합은 높아질 것이다. 이런 경우 반대로 게임 로직 스레드를 늘려 다른 세션의 처리를 좀 더 분포시켜 CPU가 놀지 못하게하는 방법을 택할 수 있다.
        * 게임 로직 스레드를 늘림으로서 발생할 수 있는 문제점: 컨텍스트 스위칭의 비용이 증가한다.
    * 애초에 맵, 필드, 던전과 같이 분리되는 요소가 없다. -> 애초에 멀티 스레드로 설계해서는 안되는 구조이다. 컨텐츠 메시지 처리가 멀티 스레드로 설계되는 경우 컨텐츠 리소스가 수월하게 분리 될 것이다 라고 가정하고 설계되는 것이다.
3. 동기화는 동기화 객체를 많이 쓰고 Acquire, Leave의 수가 중요한 게 아니다. 경합의 빈도가 중요한 것이다!!

### 멀티 스레드 모델 예시 2(가칭, IOCP x)
1. 멀티 스레드 모델 1과 다르게 네트워크 IO 처리 후 바로 로직을 처리하는 형태로 가는 모델
    * <img width=500 src="https://user-images.githubusercontent.com/95362065/169648868-93b25d72-ee4a-473e-974d-f30e7c6ce96e.png">
2. 이 모델에서는 기본적으로 세션별로 recv 동작에 대한 처리의 순서를 보장한다.
3. 강사님의 관점
    1) 모델 1에서와 같이 어차피 누군가는 해야 할 일인데 굳이 다른 스레드에게 전가시키고 어느 스레드에 일을 시켜야 할 지 고민하는 것이 불필요한 부하를 만든다.
    2) 계층에 대한 관점: 이 모델에서 언급될 수 있는 계층에 대한 이슈는, 우리 입장에서 계층을 스레드 단위로 분리하는 것이 아닌 코드적인 차원에서 보는 것까지만해도 충분하다. OSI 3,4 계층 또한 이더넷 Interrupt를 기준으로 돌고있기 때문에 완전한 병렬 처리라 볼 수 없다.
    3) 수신 메시지에 대한 처리로 인해 네트워크 IO가 느려질 것이다? 이것은 걱정할 사안이 아니다. 앞서 말했듯이 네트워크가 아무리 빨라도 게임 로직에 대한 처리가 원활히 이루어지지 않으면 소용이 없다.
        * 네트워크가 느려진다라는 상황을 모델 1을 기준으로 생각해보자. 모델 1에서 네트워크가 느려지면? request 큐에 쌓일 것이다. 이 상황은 더욱더 비정상이다. 애초에 L4 계층에서 Window를 검사하여 송신측에서 송신 여부를 결정하게 된다. 애초에 내가 할 수 있는 일을 초과해서 받는다는 행위 자체가 잘못된 것이다.

### 호모 지니어스와 헤테로 지니어스
1. 헤테로 구조라면 데이터 경합이 일어나지 않도록 리소스를 생성하고 사용하는 것이 좋은 설계이다.
2. 호모 구조라면 데이터 경합의 빈도 측정과 경합이 최소화 하는 것을 고민해야 한다.
3. 학습 초기 언급했던 옛날에 기능, 지역별 등 물리적으로 서버를 나누는 것은 결국 -> 기능별로 비동기적으로 스레드를 나누어 처리하는 것과 똑같은 개념이다.
    1) 지역별로 나눈다는 것은 똑같은 기능이지만 독립적인 리소스가 나올 수 있는 부분을 뗀 것이다. -> 스레드 설계에서 호모 지니어스 형태이다.
    2) 기능별로 나눈다는 것은 다른 기능들의 독립적인 리소스가 나올 수 있는 부분을 뗀 것 -> 스레드 설계에서의 헤테로 지니어스 형태이다.
    3) 그래서 결국 동기화 락 단위를 던전, 필드, 맵으로 가져가 통째로 써버리는 것과 같다.

### IOCP와 스레드를 늘리는 것에 대한 관점
1. 호모지니어스 스레드 구조에서 Block 걸릴 스레드들이 많을 것 같아 스레드 개수를 늘리는 방법을 선택하였다. ->  Block이 안 걸리고 원활히 돌고 있다면 오히려 컨텍스트 스위칭 비용으로 인해 역효과가 발생한다.
    * 이러한 문제를 해결하기 위해 나온 게 IOCP이다.
    * 만약 특정 스레드에 일을 주고 깨우는 이벤트 방식을 사용하여 스레드 풀을 설계하였다면 우리는 어떤 스레드가 깨어있고 어떤 스레드가 일하는 지를 구분하지 못한다. IOCP는 이러한 부분을 효율적으로 제어하여 효과적인 스레드 풀을 제공해준다.
    * 위에서 언급했던 각 update 스레드마다 request 큐를 가져가는 형태의 모델은 IOCP를 사용할 수 없다. 애초에 큐 부터가 IOCP의 것을 써야 하고 update 스레드들은 이 하나의 큐를 통해서 일을 전달받는 형태가 된다.
2. IOCP는 Block걸린 스레드와 일하고 있는 스레드 개수를 확인해서, 놀고 있으니까(Block 상태) 스레드를 더 깨워주고 바쁘니까 안깨워주는 제어의 역할을 한다. 즉, 일을 시킬 스레드의 개수를 효과적으로 관리해준다.
    1) 윈도우에서 제공되는 스레드 풀 API는 IOCP를 사용한다.

### 프레임 처리
1. 이 절에서 말하는 프레임 처리는 위에서 언급한 멀티 스레드 모델 예시1과 2의 구조에서 스레드들에 대한 프레임 처리를 얘기하고자 한다.
2. 프레임 처리
    1) 호모 지니어스 스레드 구조에서는 프레임을 관리해 줄 스레드가 나와야 한다. 앞서 언급되었던 게임 로직 스레드들은 수신 메시지 처리만 하는 스레드들이 되고 실제 프레임 관리 스레드가 전체적인 로직을 맡아야 한다.
        * 만약 프레임 스레드 또한 분리시키는 경우 각각 맵/던전/필드 등의 기능별로 프레임에 대한 역할이 정해져 있어야 한다. => 이 얘기는 각 기능마다 다른 프레임을 가질 수 있다는 이야기?

### 멀티 스레드의 구조
1. 구조적으로 좋아진다 -> 구조적으로 좋게해서 코드를 간결하게 한다.
2. 멀티 스레드 구조는 어떤 구조가 좋다 나쁘다 할 수 없이 상황에 맞게 능력껏 설계를 해야 한다.

### 계층
1. 최종적으로 네트워크 라이브러리와 게임 서버 계층을 완전히 나눌 것이다. 여기서 네트워크 라이브러리는 OSI 5, 6 계층으로 볼 수 있고 게임 서버는 7계층으로 볼 수 있다.
    * 서로 코드를 알아 낼 수 없고 침범하지 못하게끔 계층을 나눌 것이다.

## 기타 키워드
### IO 바운드, CPU 바운드
1. IO 바운드: IO를 기다리는 시간. 동기화가 아닌 IO를 위해 Block이 걸렸다는 것이다. 대표적으로 Network IO가 IO 바운드 덩어리이다.
2. CPU 바운드: CPU를 사용하는 시간. 대표적으로 게임 로직이 CPU 바운드 덩어리이다.
3. IO 바운드와 CPU 바운드 중 어떤 것을 최소한으로 하는 게 중점적으로 보아야 하는가?
    1) 이 질문에 대해서는 단순한 대답이 나와서는 안된다. 스레드의 설계, 로직, 스레드의 역할별로 언급이 되어야 할 문제이다.
        * 예를 들어 어떤 스레드 설계에서는 IO 바운드가 높고 어떤 설계에서는 CPU 바운드가 높다 라는 식
    2) 프레임 스레드, 로직 스레드에서는 IO 바운드를 제거해야 한다. 
    3) IO 바운드가 많아진다는 것은 많이 논다는 것이다. 이런 스레드들은 많이 있을 이유가 없다.

# 2022/06/22 수업내용
# 락프리
## 락프리
### 기타
1. 락프리는 IN과 OUT이 정해져있는 자료 구조에 제한된다. 따라서 큐와 스택뿐이 없을 것이다.
2. 스핀락도 락이다.
    1) 장점: 퀀텀타임 내에 자원을 획득한다면
    2) 사용 순간
        * 1: 자원을 사용하는 시간이 굉장히 짧을 때 
        * 2: 이 자원을 당장 획득하여야 하는 경우
    3) 커널 코드 대부분이 락프리, 스핀락의 구조를 띄고 있다.
3. 동기화 객체
    1) 장점: 스레드가 코어보다 많은 경우 Block이 걸리는 상황이 되면 다른 스레드에 CPU를 점유할 수 있는 기회를 줄 수 있다.
    2) 단점: 자원이 사용 중일 때 Block이 걸리고 깨어나는데 많은 시간이 든다.
4. 스핀락과 락프리는 굉장히 유사한 면이 있다.

### 락프리
1. 작업을 시도하긴 하겠지만 누군가가 변화를 주는 것 같다라면 지금 작업을 포기할 것이다. (pop, push)
    1) 동시에 성공한다라는 것은 말이 안되는 상황이다. 불가능이다.
    2) push, pop 작업 자체를 포기하고 다시 작업을 시도할 것이다.
2. 깃발 뺏기 게임을 생각해보면 된다.
    1) 아무리 나보다 빨리 출발한 사람이 있어도 출발하여 깃발을 차지하기 위하여 달릴 것이다. 
    2) 만약 모두 속도가 같다면? => 
3. 락프리가 스핀락보다 더 이득이 되는 경우
    1) 가장 늦게 출발한 스레드가 해당 작업을 완료한 경우. (스핀락이었다면 해당 스레드가 아마 기다리고 있을 것이다.)
    2) 스핀락을 돌고 있는(자원을 획득하지 못한) 스레드보다 우선순위가 높은 스레드가 자원을 가진 스레드를 제치고 CPU를 점유한다면 스핀락을 돌고있는 스레드들은 데드락 상태와 유사하게 된다.
4. 실무에서 사용되지 않는 이유
    1) 불필요한 CPU 점유율을 높인다. 대게 코어보다 스레드가 많은 상황이 많기 때문에 CPU 점유율을 높이는 것은 큰 단점이 된다.
    2) 완벽하게 구현한다는 것이 굉장히 어렵기 때문이다.

### 락프리 스택
1. 자료구조: 리스트 방식
2. PUSH
    1) 구조
    <pre><code>
    // 원래 코드
    push(Data)
    {
        노드 생성
        노드 데이터 = Data;
        노드 next = top;
        Top = 노드;       // 문제의 구간
    }
    // 변경된 코드
    push(Data)
    {
        노드 생성
        노드 데이터 = Data;
        while(1)
        {
            노드* top = _Top;
            노드 next = top;
            if (_Top == top) // 내가 알던 Top: 노드 next
            {
                // 이 구간을 Atomic으로 해야 한다. 즉 CompareExchange로 구현해야 한다.
                _Top = 노드;
                break;
            }
        }

    }
    </code></pre>
3. POP
    1) 구조
    <pre><code>
    // 원래 코드
    push(Data)
    {
        노드 생성
        노드 데이터 = Data;
        노드 next = top;
        Top = 노드;       // 문제의 구간
    }
    // 변경된 코드
    Data Pop(...)
    {
        while(1)
        {            
            top = _Top;
            Next = top->Next;

            if (_Top == top)
            {
                _Top = Next;
                top 삭제
                return Data;
            }
        }
    }
    </code></pre>
4. list를 사용하는 이유
    1) 변수 하나로만 Top이 변했는지를 판단해야 하기 때문이다.
5. Template 타입으로 만들기(물론 Data에 대한 template)

### 포트 폴리오
1. 스핀락, 동기화 객체, 락프리를 사용할 때 성능 비교
    1) 락프리가 어떤 상황에서 장점이 될 수 있는 상황을 억지로라도 만들어내서 이 상황에서 락프리가 더 좋다라는 것을 증명해야 한다.
2. 락프리를 만드는 과정 로그, 문제의 추적, 원인 파악한 데이터를 모두 남겨야 한다.
    1) 어떤 문제들로 인하여 오작동이 되는지에 대한 모든 시나리오 그려져야 한다.

## 기타
### 과제
1. 락프리 스택이 왜 오작동하고 크러쉬 나는지 왜 뻑 나는지 알아오기
2. 작동의 정상 여부
    1) 메모리 참조 오류
    2) 순서대로 
    3) 개수가 틀어지는 상황
3. PUSH와 POP을 동일한 개수로 한다.

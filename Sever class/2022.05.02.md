# 2022/05/02 수업내용
## 스레드 프로그래밍
### 크리티컬 섹션
1. 새로운 접근: 유저 동기화인데 스레드 동기화를 시킨다? 이는 새로운 접근이다.
2. 크리티컬 섹션과 다른 동기화 객체와 다른 점
    1) 사용중이지 않으면 커널 전환없이 해당 자원을 얻을 수 있다. 이는 스핀락을 통해 얻을 수 있다. 스핀락을 사용하는 이유는 자원에 Lock이 걸려있다 하여도 퀀텀 타임 내에 자원을 획득하는데에 목적이 있다.
        * 스핀락의 포인트: 퀀텀 타임을 포기하지 않고(임의로 Block되지 않고) 자원의 소유권을 지속적으로 검사한다.
    2) 자신의 스레드에서 같은 자원에 대하여 Lock(자원 획득)을 2번 이상하여도 데드락에 걸리지 않는다.(크리티컬 섹션 객체가 자원을 획득한 스레드를 기억하고 있기 때문)
3. TryEnterCiricalSection
    1) 사용중이 아니라면 자원 획득, 사용중이라면 자원을 획득하지 못하고 함수 리턴
4. 모든 동기화 객체는 선택적으로 커널 모드에 진입한다.
    * 스레드가 Block되는 동작도 커널 모드 전환이 일어난다.
5. 크리티컬 섹션의 역사가 깊다. 변경이 굉장히 많이 일어났다. 그 이유는 크리티컬 섹션의 경우 다른 동기화 객체를 Wrapping한 녀석이기 때문에 성능을 개선시키기 위하여 사용 방법을 계속해서 수정하였기 때문이다.
6. CRITICAL_SECTION 객체
    <pre><code>
    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;   // 처음엔 생성되지 않고 있다가, 레이스 컨디션이 발생하면 CreateEvent을 호출하여 커널 오브젝트를 생성한다. 이 때문에 DeleteCriticalSection이 있는 것이다.
    ULONG_PTR SpinCount;
    </code></pre>
    * LockSemaphore의 문제점: 이미 크리티컬 섹션이 만들어진 상황에서 커널 오브젝트 생성에 실패하는 문제가 발생된다.
7. 요즘 유저 동기화 객체는 모두 스핀락 구조로 대기한다.

### Wait On Address
1. 객체를 가지지 않고 주소 값을 가지고 Block한다.

### 스핀락
1. Busy waiting: CPU를 할당해가며 컨텍스트 스위칭을 하지 않는 상태에서, 어떤 동작을 기다리는 동작
2. 현 시대에서는 프로그래머가 만들어 사용하지는 않는다. OS 쪽에서만 이 기법을 사용하여 구현한다.
3. 스핀락의 장점과 단점
    1) 장점: 이게 당장 최우선인 상황
    2) 단점: 불필요하게 CPU를 점유한다.

### WaitForSingleObject 함수와 WaitForMultipleObjects 함수
1. 동기화 객체를 기다리고 있는 스레드들 중 어느 스레드를 깨울 것인지 보장받지 못한다.
    * MS에서도 깨우는 순서에 의존한 프로그래밍을 하지 말라고 권장한다. 동기화 객체 동작 방식이 계속 바뀌기 때문에
2. 세마포어: 뮤텍스, 이벤트 동기화와는 달리 카운트 방식
    * 뮤텍스, 세마포어 동기화 객체는 아무도 절대 안씀!!!
3. WaitForSingleObject와 WaitForMultipleObjects
    1) 리턴값: WAIT_FAILED => 애초에 핸들 값이 이상한 경우
    2) WaitForMultipleObjects의 리턴값 중 WAIT_OBJECT_0+... (내용 보충)
4. WaitForMultipleObjects 사용 시
    1) 빈번히 Signaled 상태가 되는 오브젝트를 뒤쪽에 놓아 중요한 오브젝트의 우선순위를 높이는 방법

### 뮤텍스
1. 뮤텍스는 클라이언트가 중복 실행되었는지 확인하는 목적으로 커널 오브젝트 동기화 객체를 생성할 수 있다.
2. 관련 함수
    1) CreateMutex 함수를 사용하여 뮤텍스의 생성 여부나 생성한다.

### 디버그
1. 디버그 메뉴->스레드 메뉴를 통해 스레드의 정보를 모니터링 할 수 있다.
    1) 브레이크 포인터를 걸고 F10을 눌러 진행하다가도 컨텍스트 스위칭이 일어난다. 이 문제를 해결하는 방법은 스레드 창에서 다른 스레드를 중지 상태로 변경한다. 다시 동작해야하는 경우 재개 선택
2. gs: 스레드 정보와 관련한 데이터를 사용할 때 사용되는 세그먼트
3. 64비트에서의 호출 규약: 스택에 매개변수를 넣지않고 레지스터에 
4. 어셈블리 명령어
    1) pause: 하이퍼 스레딩 시스템에서 옆 스레드에 명령어 처리 권한을 주는 명령어(CPU 차원의 동작). 이는 해당 스레드의 동작이 멈춘다는 것이 아니다!! (하이퍼 스레딩 시스템 꼭 이해하기!)
        * 하이퍼 스레딩에서는 스레드마다 레지스터셋을 각자 갖지만, pause 명령은 OS 입장에서 컨텍스트 스위칭이라고 보지 않는다!!!
        * 일드 프로세서라는 함수는 inline 처리되어 pause로 전환된다.

### 기타
1. printf, fwrite, fread 등 커널 모드로 전환하는 함수들은 '선택적'으로 커널 모드로 전환한다. 임시 버퍼에 저장을 해놓고 필요할 때 커널 모드로 전환하여 실제 동작을 수행
2. 윈도우7 부터 크리티컬 섹션을 없애자!해서 나온 동기화 기법
    1) Kid Event(지금은 없어짐, 프로세스에만 속해있는 동기화 객체처럼 사용할 수 있는)
    2) Wait on Address: 모든 동기화는 이것으로 대체되었음
3. CriticalSection 함수 어셈블리로 분석해보기(+CriticalSectionContented)

## 기타 키워드

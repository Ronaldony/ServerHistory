# 2022/03/18 수업내용
JSON
(구체적인 JSON 의 문법은 json.org 를 확인 하시면 됩니다.)
Json 은 JavaScript Object Notation 의 약자로서 JavaScript 에서 객체를 표현하는 텍스트 데이터 표현 문법 입니다. 굉장히 경량화 된 데이터 표현 방법이며, 쓰기도, 프로그래밍 적으로 사용하기도 편리하여 많은 데이터에서 json 을 표준의 사용이 대중화 되고 있습니다.
2000년대 초반에는 XML 문법을 많이 사용 하였지만 문법이 불편하고 태그와 마크업 기반의 구조의 단점이 커서 지금은 JSON 이 여러 분야에서 표준처럼 사용되고 있습니다.
구글,페이스북,트위터,네이버 등등의 공개 OpenAPI 에서도 모두 JSON 을 기본으로 하며, 여러 게임, 네트워크 프로토콜 등에서 JSON 이 많이 사용됩니다.
또는 여러분이 각자 만들었던 외부 설정파일용 텍스트 파서를 대체할 수 있기도 합니다. (또는 직접 파서를 만들 능력이 안되거나 만들기 싫은 사람들은 json 을 외부 텍스트 설정 파일로들 많이 사용 합니다)


사용예)
{ “MemberNo”: “123456”,  “SessionTicket”: “R2X5JVYhq4y96qlFb+Qa7FRruUi0S9Yf2tF6kwYiQ==”, “RuneID” : 1001, “CardList”:[1,2,3,4,5,6], “s_Ver”: 1, “s_Time”: 123123123 }

이는 
MemberNo = 123456
SessionTicket = R2X5JVYhq4y96qlFb+Qa7FRruUi0S9Yf2tF6kwYiQ==
RuneID = 1001
CardList = Array[] 1,2,3,4,5,6
s_Ver = 1
s_Time = 123123123

를 표현합니다. 정말 아주 간단한 문법 입니다.
JSON 은 Key : Value 의 틀을 가지며, 배열 [ a, b, c, d ] 의 표현, 객체 “object” : { “member1” : 1, “member2” : 2 } 도 가능합니다.  배열과 객체 표현이 가능하다 보니 모든 구조적 데이터를 표현할 수 있게 됩니다.
또한 키(변수) 이름에 값이 지정되는 틀 이므로,  호환성이 좋습니다.

우리가 지금까지 사용했던 네트워크 프로토콜과 비교를 해보면….
바이너리 이동메시지
	2Byte : MessageType
	4Byte : PlayerNo
	2Byte : Position X
	2Byte : Position Y

JSON 이동 메시지
	{ “MessageType”:00, “PlayerNo”:1111, “PositionX”:10, “PositionY”:20 }
이렇게 사용될 수 있습니다.  각 장단점을 알아봅니다.
= 용량부분
바이너리 메시지 : 10 Byte
JSON 메시지 : 65 Byte 이상

Json 메시지는 텍스트 데이터와 Key 에 해당하는 변수이름까지 포함되어 65 byte 이상으로 용량이 큽니다.

= 속도부분
바이너리 데이터는 크기단위로 그대로 변수에 대입하여 사용할 수 있으나, JSON 구조는 텍스트를 파싱하며 검색하여 사용해야 합니다. JSON 이 어마하게 느립니다

= 안정성부분
바이너리 메시지는 각각 데이터별로 정해진 바이트 용량을 완벽하게 지켜야만 합니다. 1byte 라도 밀리거나 실수를 하면 모든 데이터가 망가지게 됩니다.  데이터들의 순서도 완벽하게 지켜야만 사용이 가능한 구조 입니다.

반면 JSON 은 Key 를 검색하여 값을 추출하는 방식이므로, 각 변수에 해당하는 용량 개념도 없고, 순서도 상관이 없습니다.  필요로 하는 값이 없더라도 예외처리를 통해 안정성을 높일 수 있습니다.

= 호환성
바이너리 메시지는 상호간에 정해진 약속대로만 구현하며, 어플리케이션 별로 모두 각자 설계하여 사용합니다. JSON 은 표준처럼 사용하는 표현 양식이며 텍스트를 사용하여 호환성이 좋습니다.
또한 JSON 을 읽고 쓰는 파서 라이브러리는 현존하는 모든 프로그래밍 언어를 대상으로 모두 공개되어 있습니다.


용량도 무지막지하게 낭비 스럽고, 성능도 어마하게 떨어지지만 그래도 JSON 이 대중적으로 쓰이는 이유는 편리성과, 호환성, 안정성 때문 입니다.  결국 쓰기가 편하기 때문에 성능도 떨어지고 용량도 낭비되지만 쓰겠다는 겁니다.  

다음은  모바일 게임 윈드러너의 첫 로그인시 서버로부터 받는 JSON 데이터를 캡쳐한 내용 입니다.
{"agreed":0,"bestScore":7029,"bestDist":5561,"bestOpts":"C:CHAR1,R:,P:,P2:,CL:0,RL:-1,RE:-1,ITMS:","weekScore":7029,"weekDist":5561,"weekOpts":"C:CHAR1,R:,P:,P2:,CL:0,RL:-1,RE:-1,ITMS:","bestDistRecord":5561,"weekDistRecord":5561,"friendDatas":{"88354349483960817":{"bscr":6272,"bdst":4571,"bopts":"C:CHAR1,R:,P:,CL:0,RL:-1","twscr":0,"twdst":0,"twopts":"","lwscr":0,"lwdst":0, "lwopts":"","nmls":0,"msgblk":"N", "wrClass":"","rank":0},"88334806680033728":{"bscr":868354,"bdst":101962,"bopts":"C:CHAR5,R:RIDE3,P:PET_L_004,P2:PET_S_010,CL:25,RL:25,RE:1,ITMS:ITM1;ITM2;ITM3","twscr":868354,"twdst":101962,"twopts":"C:CHAR5,R:RIDE3,P:PET_L_004,P2:PET_S_010,CL:25,RL:25,RE:1,ITMS:ITM1;ITM2;ITM3","lwscr":559906,"lwdst":80546,"lwopts":"C:CHAR5,R:RIDE3,P:PET_L_004,P2:PET_S_010,CL:25,RL:25,RE:1,ITMS:ITM1;ITM2;ITM3;ITM4","nmls":0,"msgblk":"Y","wrClass":"A","rank":10},
이런 데이터를 쭈우우우욱 받아서 사용합니다.  (카카오톡 친구들의 윈드러너 플레이 정보를 받고 있는 것입니다)







JSON C++ 에서 사용법

JSON 은 모든 프로그래밍 언어를 대상으로 JSON 라이브러리가 오픈소스로 제공되고 있습니다. (json.org 사이트 하단부에 있음)  그 중에서 rapidjson 을 사용하도록 하겠습니다.  텐센트 개발자가 개발한 코드이며, C++ JSON 라이브러리중 가장 사용이 많이 되고 있습니다.

http://rapidjson.org/ 
https://github.com/Tencent/rapidjson/

을 통해서 소스를 다운 받으시고, rapidjson-master/include/rapidjson  의 폴더를 그대로  복사하여 프로젝트 폴더로 옮겨서 사용 합니다.  헤더 include 만 하면 사용 가능합니다.



JSON 스트링을 C++ 에서 읽어들이기.
{ "Account":[
{"AccountNo":1,"Nickname":"테스트계정1"},
		{"AccountNo":2,"Nickname":"테스트계쩡2"}  ],
"Friend":[],
"FriendRequest":[
{"RequestNo":1,"FromAccountNo":1,"ToAccountNo":2,"Time":1437344611},
{"RequestNo":2,"FromAccountNo":1,"ToAccountNo":3,"Time":1437344611} ] 
}

이렇게 된 JSON 을 읽어들이는 예제 입니다.

Account 는 배열이며 배열의 요소에는 { AccountNo / Nickname }  이 묶이는 객체들 입니다.
각 데이터의 의미는 없습니다.  단지  변수,배열,객체를 표현하는 json 문법에 집중 하시면 됩니다.

#include "rapidjson/document.h"
#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"
using namespace rapidjson;
void JsonLoad(void)
{
	char *pJson = 	파일 또는 네트워크로 받은 JSON 문자열
지금은 UTF-8 을 전제로 함

Document Doc;
Doc.Parse(pJson);	// Document 로 Json 텍스트 파싱.

	UINT64 AccountNo;
	const char *pNickname;

Value &AccountArray = Doc["Account"];	// 첫번에 Account 객체 접근
					// rapidjson::Value  로 받아서 사용

	for (SizeType i = 0; i < AccountArray.Size(); i++)
	{
		Value &AccountObject = AccountArray[i];
		AccountNo = AccountObject["AccountNo"].GetUint64();
		pNickname = AccountObject["Nickname"].GetString();
		// 읽혀진 데이터 사용
	}
Value &FriendArray = Doc["Friend"]; 	
for (SizeType i = 0; i < FriendArray.Size(); i++)
	{
		Value &FriendObject = FriendArray[i];
		FriendNo = FriendObject["FriendNo"].GetUint64();
		FromAccountNo = FriendObject["FromAccountNo"].GetUint64();
		ToAccountNo = FriendObject["ToAccountNo"].GetUint64();
		// 읽혀진 데이터 사용
	}

이와 같은 형태로 Key 문자열을 [“ “] 로 접근하여 손쉽게 사용이 가능 합니다.
C++ 데이터를 JSON 으로 변환하기  (UTF16 -> UTF8 저장)
StringBuffer StringJSON;
Writer<StringBuffer, UTF16<>> writer(StringJSON);
writer.StartObject();			// { 
writer.String(L"Account");		// { “Account” 
writer.StartArray();			// { “Account”:[  
{ // 반복문 돌면서 Account 정보 저장
	writer.StartObject();		// { “Account”:[{  
	writer.String(L"AccountNo");	// { “Account”:[{“AccountNo”: 
	writer.Uint64(1111); 		// { “Account”:[{“AccountNo”:1111 
	writer.String(L"Nickname");	// { “Account”:[{“AccountNo”:1111, “Nickname”:
	writer.String(L”닉네임”); 	// { “Account”:[{“AccountNo”:1111, “Nickname”:  “닉네임”
	writer.EndObject();		// { “Account”:[{“AccountNo”:1111, “Nickname”: “닉네임”},

}
writer.EndArray();			// } 추가

writer.String(L"Friend");			// ……
writer.StartArray();
{ // 반복문 돌면서 친구정보 저장
	writer.StartObject();
	writer.String(L"FriendNo");
	writer.Uint64(pFriend->No);
	writer.String(L"FromAccountNo");
	writer.Uint64(pFriend->FromAccountNo);
	writer.String(L"ToAccountNo");
	writer.Uint64(pFriend->ToAccountNo);
	writer.EndObject();
}
writer.EndArray();
writer.String(L"FriendRequest");
writer.StartArray();

{ // 반복문 돌면서 저장
	writer.StartObject();
	writer.String(L"RequestNo");
	writer.Uint64(pFriend->No);
	writer.String(L"FromAccountNo");
	writer.Uint64(pFriend->FromAccountNo);
	writer.String(L"ToAccountNo");
	writer.Uint64(pFriend->ToAccountNo);
	writer.EndObject();
}
writer.EndArray();
Writer.EndObject();

const char *pJson = StringJSON.GetString();	// 이 문자열을 저장하거나 패킷을 쏨

지금 보면 Writer 의 경우 굉장히 노가다가 심한 방식 입니다.  하지만 별다른 방법이 없습니다. 스크립트 언어에서는 class 인스턴스를 그대로 JSON 인코딩이 가능합니다.  그렇게 되면 맴버 변수 이름을 Key 로 값을 Value 로 알아서 JSON 스트링으로 만들어 줍니다. 하지만 컴파일 언어에서는 변수의 이름이 존재하지 않기 때문에 어쩔 수 없이…. 약간의 노가다가 필요 합니다.


지금 위의 샘플 코드는 
C++ (UTF-16) -> JSON (UTF-8)   
JSON (UTF-8) -> C++ (UTF-8) 

의 인코딩 샘플 입니다. 샘플코드를 디버깅 하면서 정확히 파악 해봐주시기 바랍니다.

만약 
C++ (UTF-16) -> JSON (UTF-16)   
JSON (UTF-16) -> C++ (UTF-16) 

의 상황이 필요하다면  아래 코드들을 수정 해야합니다.

StringBuffer 의 인코딩 타입을 UTF16 으로 지정 합니다.

typedef GenericStringBuffer<UTF16<> > StringBuffer; 

Writer 의 Input 인코딩과 Output 인코딩을 모두 UTF16 으로 지정 합니다.

	Writer<StringBuffer, UTF16<>,UTF16<>> writer(StringJSON);
	
Value 와 Document 의 인코딩을 UTF16 으로 변경 합니다.

typedef GenericValue<UTF16<> > Value;
typedef GenericDocument<UTF16<> > Document;

이렇게 일부 typedef 의 인코딩을 변경시키면 UTF16 문자열 사용이 가능 합니다.

# 2022/05/18 수업내용
## 멀티 스레드
### 멀티 스레드 설계
1. 병렬 처리와 공유 자원
    1) 공격, 이동, 섹터 처리 등은 캐릭터 맵을 공유하기 때문에 병렬 처리가 불가능하다.
    2) 섹터 맵과 캐릭터 맵은 서로 독립적인 데이터 같이 보인다. 하지만 캐릭터 맵은 섹터의 정보를 내포하고 섹터를 계산하기 위해서는 캐릭터 맵에서의 좌표가 필요하다.
    3) 네트워크와 컨텐츠의 분리
        * 중간에 SendQ와 RecvQ가 있음으로서 서로 병렬적인 처리가 이루어질 수 있다. 네트워크는 RecvQ에 넣기만하고 빠지고 컨텐츠 쪽은 SendQ에 넣기만하고 빠지는 형태로 설계되어야 한다.
    * 잘못된 공유 자원에 대한 동기화는 CPU 사용률을 떨어뜨리고 스레드들이 서로 Block 걸리는데 시간을 허비한다.
2. 컨텐츠와 네트워크의 분리
    1) 컨텐츠 로직과 네트워크 중간에 Actor 패턴 구조로 RecvQ와 SendQ 자원을 동기화시켜 서로 분리시킬 수 있다.
        * 인큐의 경우 컨텐츠->네트워크, 네트워크->컨텐츠 어떤 방향이든 넣고 빠지는 비동기 방식으로 이루어져야 한다. 디큐 또한 데이터 검사 및 디큐 동작까지만을 동기화시키고 디큐한 데이터를 가지고 컨텐츠 로직 처리 부분은 비동기적으로 가야 한다.
3. 멀티 스레드 설계에는 어떠한 답은 없다. 단지 상황에 따라 최선의 방법을 선택해야 한다. => 암기가 아닌 원리의 이해가 필요

### 네트워크의 멀티 스레드
1. 네트워크 파트: 소켓 모델에 따라서 멀티 스레드 설계 방법이 달라져야 한다. (예시: eventselect는 소켓 셋 64개 씩을 전담하는 쓰레드를 다수 개를 생성하여 각각의 다른 세션 64개씩을 맡아 네트워크 동작을 수행하였다.) 
    * 네트워크 IO 스레드는 IOCP, Callback 방법 Overlap 등의 방법이 있다.
2. 최소한 보장되어야하는 사항: 하나의 세션은 하나의 스레드에 의해서만 처리되어야 한다. 즉 한 순간에 하나의 세션이 아닌 하나의 스레드에 의해서만 세션이 접근이 되어야한다는 것이다. 같은 세션의 SendQ와 RecvQ 서로간에는 동기화할 필요는 없다.
    1) SendQ나 RecvQ를 여러 스레드에서 접근하는 상황에서는 동기화가 이루어졌다 하여도 순서를 보장할 수 없다. 예를 들어 Q 진입 전 혹은 Q 내부에서 EnterCriticalSection을 호출하였다해도 EnterCriticalSection가 호출된 직후에 컨텍스트 스위칭이 일어날 수 있기 때문에 순서를 보장할 수 없다.
    * 이러한 특징은 멀티 스레드라서 나타나는 현상이다. 멀티 코어, 멀티 프로세서라서 생기는 문제가 절대 아니다! 싱글 코어에서도 똑같은 현상이 나타난다.
3. Stateless에서는 로직과 로직안에서 공유하는 자원이 없기 때문에 멀티 스레드 처리가 굉장히 쉽다.
    1) 아차피 서버의 고전적 모델은 1유저 1스레드이다. 새로운 유저가 연결되면 스레드를 생성하여 로직처리하고 파괴한다.
        * 아주 옛날 스레드 개념이 없던 시절 아파치 서버는 프로세스 스케줄링 모델이었다.

### 스레드 모델
1. 호모 지니어스와 헤테로 지니어스 
    1) 호모: 같은 일의 스레드를 여러개 => Stateless가 이 모델
    2) 헤테로: 다른 일의 스레드를 여러개 => Stateful은 이 모델
2. Actor 패턴
    1) 메시지 전달 시 중간에 Q를 두어 생산자와 소비자가 따로 나뉘어져 일을 하는 형태

### 게임 서버 모델
1. 게임 서버 모델
    1) 게임 로직은 하나의 스레드, 네트워크 IO는 여러개의 스레드로 설계
        * 게임 로직이 하나여서 대부분의 부하가 게임 로직으로 치우쳐진다. 네트워크 IO가 아무리 빨라도 처리속도는 느려진다. -> 게임 로직을 멀티 스레드로 설계가 되어야 한다.
        * 게임 로직이 하나일 때 수신 메시지 처리와 프레임 로직을 멀티 스레드로 분리할 필요가 있냐? => 만약 
    2) 게임 로직과 네트워크 IO가 여러개의 스레드로 설계
        * 게임 로직을 멀티 스레드를 분리할만한 요소들을 찾아 분리하는 것이다. 분리할만한 요소는 길찾기 등이 있다. 요점은 요청에 대한 결과를 어떤 식으로 전달하고 받는 것이냐이다. 때문에 Actor 패턴을 사용하여 전달한다. => 큐잉, 디큐 작업의 부하가 스레드를 분리하는 것보다 더 커지게되면 분리한 의미가 없어진다.
        * 스레드 분리를 하게될 때 이점을 정확히 판단해야 한다. 스레드를 분리함으로서 큐잉 등의 부가적인 작업으로 인해 오버헤드가 생기는데 이러한 점을 감수하고도 할 가치가 있다면 하는 것이다.
2. 서버가 느리다의 의미 => 처리가 느리다의 의미 -> 함수 return이 느리다.
    1) 기본적으로 비동기 IO를 사용하는 것이다.
3. 길찾기 스레드 분리
    1) Case 1: 길찾기 결과를 각자의 캐릭터에 존재하는 큐에 적재하는 형태. 단점은 순회를 해야 한다.
    2) Case 2: 길찾기 결과를 하나의 큐에 적재하고 하나의 길찾기를 요청한 마무리 작업 또한 요청자가 해야 한다.
    * 나중에는 DB, 갓챠 등을 분리할 수 있다.

### CPU 사용률
1. CPU가 100%라면 레디큐가 쌓였다는 얘기이고 아니라면 그 반대이다. 100%에 도달하게 되면 다른 스레드에  시간 측정 등의 기능에 영향을 주게 된다.

### 동기와 비동기
1. Non-block 소켓은 비동기가 아니다.
2. Overlap IO를 사용하면 recv, send가 비동기적으로 이루어진다.

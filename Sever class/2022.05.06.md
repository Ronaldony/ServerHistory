# 2022/05/06 수업내용
## 스레드 프로그래밍
### 동기화
1. Lock과 Unlock 시도 시 방법에 따라 어떠한 문제가 발생할 것인지에 대한 
    1) 문제 상황: 다수의 스레드가 임계 영역에 같이 진입하는 경우, Unlock이 되지 않는 경우, 

### 이벤트 객체
1. SetEvent 시 대기하는 스레드를 깨우는 주체가 누구이느냐
    1) 오토 리셋에서는 SetEvent 호출 시 이벤트 객체가 자신을 대기하는 스레드 리스트에서 제일 먼저 앞의 것을 뽑아 Running 상태로 전환시킨다.
        * 단점: 다수의 워커 스레드가 있을 때 순서대로 깨어나게되면 캐시히트율 감소, 컨텍스트 스위칭이 일어나게 될 확률이 높다. 같은 워커 스레드를 깨우는 쪽이 캐시히트율, 컨텍스트 스위칭이 일어나지 않을 확률이 높아진다.

### 피터슨 알고리즘
1. 동기화 객체, Interlocked을 쓰지 않고 동기화가 가능하냐?
    <pre><code>
    // 스레드1
    while(1)
    {
        if (flag == 0)
        {
            // 작업
            flag = 1;
        }
    }
    
    // 스레드2
    while(1)
    {
        if (flag == 1)
        {
            // 작업
            flag = 0;
        }
    }
    * 이 방법의 조건은 다음과 같다.
    * 조건1: 스레드마다 고유한 상태 값을 가져야 한다.
    * 조건2: 다음 동작할 스레드의 방향이 정해져 있어야 한다.
    </code></pre>
2. 피터슨 알고리즘
    1) 목적: 변수만 가지고서 동기화를 해보자!
    2) 구조
        * 사용 여부를 나타내는 변수 나의 Flag와 turn 변수를 확인하여 동기화
        <pre><code>
        // 스레드1        
        Flag[0] = true;
        turn = 1;
        while(1)
        {
            if ((Flag[1] != true) || (turn != 1))
                break;
        }
        Flag[0] = false;

        // 스레드2        
        Flag[1] = true;
        turn = 2;
        while(1)
        {
            if ((Flag[0] != true) || (turn != 2))
                break;
        }
        Flag[0] = false;
        * 포인트는 동시에 들어왔을 때 누가 먼저 들어왔냐를 판단하는 것이다.
        * 내가 이 구간을 지나쳤나 안 지나쳤나 표식하는 것이다.
        </code></pre>
    * 이 알고리즘은 CPU 구조상 정상 동작하지 않는다. 싱글 코어에서는 정상 동작한다. 정상 동작하지않는 시점, turn의 변수가 서로 다르게 읽히는 시점을 정확히 파악해서 문제점을 파악해보아야 한다.
    * 자료는 위키백과 까지만 찾아볼 것(의사코드)

## 과제
### 개선할 점
1. Shutdown에 Lock을 걸어야 하는가?
    <pre><code>
    Case 1
        // 스레드 1 코드
        a = b;
        // 스레드 2 코드
        b = x;
    
    Case 2
        // 스레드 1 코드
        Lock
        a = b;
        Unlock
        // 스레드 2 코드
        Lock
        b = x;
        Unlock
    </code></pre>
    * 우리가 동기화해야하는 상황은 양방향에서 쓰기를 하는 경우이다. 한 쪽에서는 읽기를, 한 쪽에서는 쓰기를 수행하는 경우라면 
    * 단순한 Shutdown의 동작이라면 
3. Interlocked를 수행하는 변수와 일반적인 변수가 캐시라인에 있을 때 잠기는 것에 대해 걱정해야 하는가?
4. Pop
    1) Size 크기를 먼저 차감하고 개수 검사 및 갱신 후, 데이터 복사가 이루어지는 구조로 설계하여 성능을 개선할 수 있다.

### 피터슨 알고리즘
1. Lock 파트에 g_Data++; 추가하기
2. 이 알고리즘이 정상 동작하지않는 것이 로직인가 CPU의 문제인가를 정확히 판단    

## 기타 키워드
### rand
1. 보안 목적: srand_s, rand_s
2. 분포도 개선(모던 C++ 표준에서 지원하지만 성능이 떨어짐): 

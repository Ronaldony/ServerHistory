# C++
## include
1. 컴파일 확장자 대상: .c, .cpp (.h는 대상이 아니다.)

## class
1. C++에서 구조체와 동작방식, 구현 방식이 같다.
2. 언제 class를, 언제 struct를 사용하나? -> class(객체)는 혼자 특정한 동작을 하는 독립체, struct는 데이터 덩어리라고 보는 것이 좋다.
3. class 안에 enum을 정의하는 경우가 많다.
<pre><code>
#define MAX 100
class C {
  enum{
  MAX = 100
  }
  char buf[MAX]; // class 내부 MAX를 사용
}
</code></pre>
4. class 내부에서 함수를 **정의**하면 inline 함수 처리가 된다. 내부에서는 선언, 외부에서 정의하면 inline 옵션에 따라 처리된다.
5. 기본 class 파일 구조: class.cpp 하나에 class.h
    1) .h에는 클래스 선언부
    2) .cpp에는 정의부

## enum
1. enum [이름], enum class [이름]의 차이점
    1) enum [이름]으로 선언한 경우 다른 두 개의 enum이 같은 상수 표현이 있다면, 서로 겹쳐 에러가 발생한다.
    2) enum class [이름]으로 선언한 경우 다른 구 개의 enum class가 같은 상수 표현이 있어도, 겹치지 않아 에러가 발생하지 않는다.
2. constexpr
    1) 최근 define, enum보다 constexpr로 상수를 표현하는 것을 권장한다. (enum의 열겨 형태를 사용하지 않는 경우만)
    2) define, enum과 다른 점은 컴파일 타임에 상수로 치환되는것이 아닌 런타임에 치환이 된다(그렇다면, 런타임 수행 시간에 차이가 있는가? -> 검증 필요)

## const
1. 전역 const는 RO 영역에 저장되어 컴파일 에러가 발생한다. 지역은 Stack 영역에 저장되어 컴파일 에러가 발생하지 않는다.
2. define과 enum, const는 런타임 수행시간에 차이가 없다. (실제 디버깅 필요)

## 객체지향
1. 정보은닉
    1) 클래스 내부에 private 변수를 getter, setter로 접근하는 것은 **정보은닉**이 아니다. (더 복잡하고 필요없는 수행만 늘어나게 된다.)
    2) 클래스 멤버 변수의 제공 및 변경이 아닌 동작에 대한 **결과**를 제공하여야 한다.
        <pre><code>
        class C {
          private:
          int hp;
          public:
          void isDie(hp);
        }        
        </pre></code>
    * getter, setter 만들지 않을 것!!

## 생성자
1. 

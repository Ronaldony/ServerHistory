# 2022/05/06 수업내용(복습 완료)
## 스레드 프로그래밍
### 명령어 재배치(Out of ordering)
1. 멀티 코어 환경에서는 명령어 재배치 기능을 지원하는 CPU 구조로 인하여 서로 다른 스레드에서 한 변수에 대해 전혀 다른 값으로 읽을 수가 있다.

### 동기화
1. Lock과 Unlock 시 방법에 따라 문제가 발생할 수 있는 상황 사례
    1) 상황1: 두개 이상의 스레드가 Lock을 통과해 임계 영역으로 들어가는 상황
    2) 상황2: 임계 영역에 진입 후 Unlock을 수행하지 못하는 상황
    3) 상황3: 두개 이상의 스레드가 Lock을 대기하다 같이 임계 영역으로 들어가는 상황

### 이벤트 객체
1. SetEvent 시 대기하는 스레드를 깨우는 주체가 누구이느냐
    1) 오토 리셋에서는 SetEvent 호출 시 이벤트 객체가 자신을 대기하는 스레드 리스트에서 제일 먼저 앞의 것을 뽑아 Running 상태로 전환시킨다.
        * 단점: 다수의 워커 스레드가 있을 때 순서대로 깨어나게되면 캐시히트율 감소, 컨텍스트 스위칭이 일어나게 될 확률이 높다. 같은 워커 스레드를 깨우는 쪽이 캐시히트율, 컨텍스트 스위칭이 일어나지 않을 확률이 높아진다.
        * 이 단점을 해결한 것이 IOCP이다. IOCP는 스레드 풀의 형태이다. IOCP는 스레드 풀의 관리를 개선하여 성능을 높였다.

### 피터슨 알고리즘
1. 동기화 객체, Interlocked을 쓰지 않고 동기화가 가능하냐?
    <pre><code>
    // 스레드1
    while(1)
    {
        if (flag == 0)
        {
            // 작업
            flag = 1;
        }
    }
    
    // 스레드2
    while(1)
    {
        if (flag == 1)
        {
            // 작업
            flag = 0;
        }
    }
    * 이 방법의 조건은 다음과 같다.
    * 조건1: 스레드마다 고유한 상태 값을 가져야 한다.
    * 조건2: 다음 동작할 스레드의 방향이 정해져 있어야 한다.
    </code></pre>
2. 피터슨 알고리즘
    1) 목적: 변수만 가지고서 동기화를 해보자!
    2) 구조
        * 사용 여부를 나타내는 변수 나의 Flag와 turn 변수를 확인하여 동기화
        <pre><code>
        // 스레드1        
        Flag[0] = true;
        turn = 1;
        while(1)
        {
            if ((Flag[1] != true) || (turn != 1))
                break;
        }
        Flag[0] = false;

        // 스레드2        
        Flag[1] = true;
        turn = 2;
        while(1)
        {
            if ((Flag[0] != true) || (turn != 2))
                break;
        }
        Flag[0] = false;
        * 포인트는 동시에 들어왔을 때 누가 먼저 들어왔냐를 판단하는 것이다.
        * 내가 이 구간을 지나쳤나 안 지나쳤나 표식하는 것이다.
        </code></pre>
    * 이 알고리즘은 CPU 구조상 정상 동작하지 않는다. 싱글 코어에서는 정상 동작한다. 정상 동작하지않는 시점, turn의 변수가 서로 다르게 읽히는 시점을 정확히 파악해서 문제점을 파악해보아야 한다.
    * 자료는 위키백과 까지만 찾아볼 것(의사코드)

## 과제
### 개선할 점
1. Shutdown에 Lock을 걸어야 하는가?
    <pre><code>
    Case 1
        // 스레드 1 코드
        a = b;
        // 스레드 2 코드
        b = x;
    
    Case 2
        // 스레드 1 코드
        Lock
        a = b;
        Unlock
        // 스레드 2 코드
        Lock
        b = x;
        Unlock
    </code></pre>
    * 우리가 동기화해야하는 상황은 양방향에서 쓰기를 하는 경우이다. 한 쪽에서는 읽기를, 한 쪽에서는 쓰기를 수행하는 경우라면 동기화할 이유가 없다. 하지만 여기서 조금 우려되는 것은 다음과 같은 상황이다.
        <pre><code>
        // 스레드 1
        if (flag == 1)
        {
            // 작업
        }
        // 스레드 2
        flag = 0;
        * 문제 상황: 스레드 1에서 조건문 안으로 진입한 상태에서 스레드 2로 컨텍스트 스위칭이 일어난다. 
        스레드 1의 작업은 완료되지 않았지만 스레드 2가 flag를 변경하는 것은 막을 수가 없다.
        </code></pre>
2. Interlocked를 수행하는 변수와 일반적인 변수가 캐시라인에 있을 때 잠기는 것에 대해 걱정해야 하는가?
3. 동기화 동작의 구분
    1) pop
        * Size 크기를 체크하는 동작과 실제 pop 동작을 나누어 동기화시키자! => pop 함수 진입 시 가장 먼저 크기를 차감하여 자신의 데이터를 확보해놓는다. 이때는 컨텍스트 스위칭이 일어나도 먼저 전혀 문제되지 않는다. Size 검사 후 유효하다면 데이터 버퍼에 Lock을 걸어 pop 동작을 수행한다.

### 피터슨 알고리즘
1. Lock 파트에 g_Data++; 추가하기
2. 이 알고리즘이 정상 동작하지않는 것이 로직인가 CPU의 문제인가를 정확히 판단    
3. 질문: Interlocked 또는 동기화 객체를 사용하였을때는 왜 정상적인 값이 나오는가?
    1) Interlocked 의문: Interlocked 명령은 명령어 재배치의 영향을 받지 않는 것인가? -> Interlocked 연산은 완전한 Atomic 연산을 보장하는 것이다. 같은 Interlocked 연산에 대하여 완전하게 Lock을 걸어 먼저 실행한 Interlocked 연산이 끝나야 다음 Interlocked의 연산이 수행된다 를 보장한다.
    2) 피터슨 알고리즘이 비정상 동작을 하는 이유에 대한 고찰: 정상적 동작을 하지 않는 이유는 무엇일까? 각 스레드가 임계 영역에 같이 들어가서 문제가 되는 것일까 아니면 공유 자원의 값이 다르게 읽혀서 문제가 되는 것일까?

## 기타 키워드
### rand
1. 보안 목적: srand_s, rand_s
2. 모던 C++ 표준에서는 rand()보다 분포도가 개선된 형태의 난수 생성기가 있다. 이 난수 생성기는 윈도우 API까지 호출하여 난수를 생성한다. (그러나 메모리를 많이 사용하고 성능이 떨어짐)

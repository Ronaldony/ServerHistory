# 2022/02/16 수업 내용
## 소켓 프로그래밍
### Backlog
1. 연결 정보를 Backlog에 저장하는 이유
    1) OSI L7 계층간 작업은 비동기로 이루어지기 때문이다.

### 통신 함수
1. recv함수
    1) Block 되는 시점: 수신 소켓 버퍼가 0인 경우
        * 누가 Block을 걸었나? => 함수 내부에서 WaitSingleObject 함수를 호출하여 PSH 패킷이 올때까지 block이 된다.
    2) recv가 반환하는 시점
        * case1: recv 하는 시점에 이미 소켓 수신에 데이터가 차 있는 경우
        * case2: recv가 block된 시점에 송신측에서 PSH 패킷이 오는 경우
    3) 소켓 버퍼에서 사용자 버퍼에 메모리 복사가 이루어지는 시점
        * Case1: 이미 소켓 버퍼에 데이터가 있는 경우로, (내용 보충)
        * Case2: 스레드가 Block인 경우로, 다이렉트로 사용자 버퍼에 복사를 해버린다.(오버랩 I/O 방식) 즉 사용자가 등록한 버퍼가 소켓 버퍼가 되는 것이다.
2. send 함수
    1) Block 되는 시점: 송신 소켓 버퍼가 0인 경우(부족한 경우)
    * send의 경우 송신 소켓 버퍼가 꽉 차서야 제로 카피에 들어가기 때문에 **오버랩 I/O에서는 임의적으로 송신 버퍼를 0으로 만든다.**
3. recv와 send를 Non-Block 소켓을 사용하는 경우 WOULDBLOCK 에러를 뱉어줌으로써 다음 동작에 대한 동작을 결정할 수 있다.
    1) 단점: 모든 소켓에 대하여 recv, send를 호출해봐야 상태를 알 수 있다. => 이를 해소하기 위한 방법이 소켓 모델이다
4. setsockopt로 소켓 버퍼를 조정하여도 L4 내부에서 값을 조정하여 실제 지정한 값과 다르게 된다.
    1) 송수신간 windows 사이즈가 이상한 경우 이 것을 의심해봐야 함

### Block과 Non-Block 함수
1. Non-Block 함수 사용 시 후속 처리가 필요하다.
2. 제로 카피: block 상태가 되는 시점에서 사용자의 버퍼를 다이렉트로 송수신 버퍼로 사용하는 것

### I/O
1. 동기: I/O 작업이 완료되면 반환
2. 비동기: I/O 작업의 완료 여부와 상관없이 반환한다.
3. 오버랩: Block 상태가 되어 사용자 버퍼를 등록하는 과정(Lock, 동기화)에서 Overhead가 발생한다.
4. Regitsted I/O: 처음부터 송수신 버퍼를 사용자가 등록한다. 

## 기타 키워드
### Backlog 큐
1. 65535까지 늘리는 것에 대한 완벽한 이해 필요
    1) HINT를 썼는데도 불구하고 16xxx까지밖에 안늘어나는 이유(원인 찾기)
    2) 최대 비동기 포트 수를 늘리면 왜 65535까지 사용가능한건지 (Backlog 큐와 최대 비동기 포트 수 관계)

### PSH 테스트 방법
1. recv 측에서  

### 과제
1. 프로카데미 서버 

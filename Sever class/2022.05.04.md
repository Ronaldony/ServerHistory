# 2022/05/04 수업내용
## 동기화
### 크리티컬 섹션
1. 어셈블리 분석
    1) gs 세그먼트가 등장하는 경우 스레드 정보에 접근한다고 가정을 하고 분석을 진행해야 한다. 대부분 스레드 ID에 접근
    2) Syscall, wow64 명령어 진입 시 커널 모드 진입이다. 
    3) lock bts: 인터락 비교 명령어
    4) NtWaitForAlertByThreadId: 
2. 현재 크리티컬 섹션은 WaitOnAddress를 Wrapping한 것이다. 예전에는 커널 동기화 객체를 Wrapping하여 DeleteCriticalSection이 있는 것이다.

### 멀티스레드
1. 동기화 접근
    1) 일반적인 접근: 동기화가 필요한 요소(세션, 캐릭터 정보 등)에 동기화 객체를 포함시켜 요소에 진입할 때마다 Lock, Unlock을 한다.
    2) 커널 동기화 객체를 쓰지 않은 경우: Interlocked을 사용하는 방법밖에 없다. 현재 유저 동기화 객체들도 InterLocked
    3) 우리의 접근1: 단순히 InterLocked 혹은 동기화 객체의 진입 횟수가 중요한 관점이 아니다. 경합의 확률(빈도)을 보는 것이 포인트이다. 만약 1/5000 혹은 1/10000 확률이라면 성능에 영향이 없다.
    4) 우리의 접근2: 경합이 일어나는 순간 다른 일을 하러 빠지는 것
    5) 우리의 접근3: 공유 자원에 대한 접근에 목적을 명확히 명시한 상태에서 접근하는 것이다. 만약 다른 스레드들이 읽기로만 접근하고 있다면 같이 접근. 만약 자원에 대한 접근이 삭제, 변경 시 Lock
2. 워커 스레드를 만들 때는 종료 방법에 대한 설계도 이루어져야 한다. (예를 들어 이벤트 오브젝트를 Signaled로 바꾸고 대기 상태로 바꾸는..)

### SRWLock
1. 특징 및 구조
    1) 만약 검색만을 위한 접근이라면 Shared로 할 수 있지만, 검색을 한 후 사용하는 경우라면 Exclusive를 사용해야 한다.
    2) SRWLock은 객체가 아니다. 구조체 형태로 주소값을 저장하는 PTR 하나로 구조되어 있다.
    3) 이 친구도 크리티컬 섹션과 같이 완전한 유저 동기화 방법이다. 내부적으로 WaitOnAddress를 사용하여 동기화한다. 다만 다른점은 스레드 ID를 확인하지 않는다.
2. 크리티컬 섹션과의 성능 차이
    1) 실제로 어셈블리를 분석해보면 크리티컬 섹션보다 더 가볍다. 
    * 따라서, 동기화 객체를 선택할 때 가장 먼저 SRWLock이 선택되어야 한다. 만약 재귀적으로 동기화 객체가 사용되는 상황이라면 가장 먼저 구조를 바꾸어야 한다. 만약 되지 않는다면 CriticalSection으로 전환시켜야 한다.

### 이벤트
1. 세마포어와는 다르게 카운트 방식이 아니다.
2. 사용 목적
    1) 보통 이벤트는 공유 자원에 대한 접근 문제를 해결하기 위한 것이 아닌 스레드 제어 목적으로 사용된다.
    2) 위 방법을 응용하여 스레드 풀을 구현해볼 수 있다.
3. 제어 스레드와 워커 스레드 사이에는 항상 큐가 존재하여 할당되는 일을 쌓아두어야 한다.

## 기타 키워드
### 스핀락 테스트
1. 프로파일로는 성능 측정이 힘드니 일정 시간 내에 진입 성공 횟수를 기준으로 대략적인 성능을 측정할 수 있다.

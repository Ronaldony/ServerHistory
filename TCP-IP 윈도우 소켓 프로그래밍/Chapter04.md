# Chapter04 TCP 서버-클라이언트
## Section01 TCP 서버-클라이언트 구조
### TCP 서버-클라이언트 개념
1. TCP 서버와 클라이언트의 관계는 웹 서버와 웹 브라우저의 관계가 대표적인 사례이다.

### TCP 서버-클라이언트 동작 원리
1. TCP 서버-클라이언트 동작 절차
    1) listen: 서버가 소켓을 생성한 후 클라이언트 접속을 기다림
    2) accept + connect: 클라이언트가 서버에 접속한다. 서버 입장에선 accept, 클라이언트 입장에선 connect 동작이다. 이때 TCP 프로토콜 수준에서 연결 설정을 위한 Frame 교환이 일어난다.(SYN, SYN/ACK, ACK)
    3) send + recv: TCP 프로토콜 수준의 연결 절차가 끝나면, 서버는 접속한 클라이언트와 통신할 수 있는 **새로운 소켓을 생성**한다. 이 소켓을 사용하여 클라이언트와 서버가 데이터를 주고받는다. 기존 소켓은 새로운 클라이언트 접속을 수용하는 용도로 계속 사용된다.
2. 서버 측 소켓과 클라이언트 측 소켓은 1:1로 대응된다. 하지만 하나의 **클라이언트가 N개의 소켓을 사용해** 서버에 접속할 수도 있다.

## Section02 TCP 서버-클라이언트 분석
### 지역과 원격 IP 주소 및 포트 번호
1. 지역 IP와 포트 번호: 서버 또는 클라이언트 **자신의 주소**
2. 원격 IP와 포트 번호: 서버 또는 클라이언트 자신가 통신하는 **상대의 주소**

### TCP 서버 함수
1. 일반적으로 TCP 서버는 다음과 같은 순서로 소켓 함수를 호출한다.
    1) socket(): 소켓을 생성함으로써 사용할 프로토콜 결정
    2) bind(): **지역 IP 주소와 지역 포트 번호**를 결정
    3) listen(): TCP를 LISTRENING 상태로 변경한다.
    4) accept(): 클라이언트가 통신할 수 있는 새로운 소켓을 생성한다. 이때 **원격 IP 주소와 원격 포트 번호**가 결정
    5) send(), recv() 함수로 클라이언트와 데이터 송수신 후 closesocket() 함수로 소켓을 닫음
    6) 이후 4-5 과정을 반복
2. 서버 함수
    <pre><code>
    // bind
    int bind(
        SOCKET         s,       // 클라이언트 접속을 수용할 목적으로 만든 소켓으로, 지역 IP와 포트 번호가 결정되지 않은 상태
        const sockaddr *addr,   // 소켓 주소 구조체를 지역 IP와 포트 번호로 초기화하여 전달한다.
        int            namelen  // 소켓 주소 구조체의 길이
    );
    
    // listen
    int WSAAPI listen(
        SOCKET s,       // 클라이언트 접속을 수용할 목적으로 만든 소켓으로, bind 함수로 지역 IP와 포트 번호가 결정된 상태
        int    backlog  // 서버가 당장 처리하지 않더라도 접속 가능한 클라이언트의 개수. 클라이언트 접속 정보는 연결 큐에 저장되는데,
                        // backlog는 이 큐의 길이를 나타낸다. 최댓 값 SOMAXCONN(2GB)
    );

    // accept
    // accept 함수는 접속한 클라이언트와 통신하도록 새로운 소켓을 생성하여 반환한다.
    // accept 함수는 접속 클라이언트가 없다면 서버를 대기 상태로 만든다. 이때 CPU 사용률이 0이 된다.(쓰레드의 상태가 blocked 상태?!)
    SOCKET WSAAPI accept(
        SOCKET   s,         // listen 함수로 LISTENING 상태가 된 소켓
        sockaddr *addr,     // 접속한 클라이언트의 주소 정보로 채워짐
        int      *addrlen   // 호출 시에는 addr이 가리키는 구조체의 크기로 전달해야하며, 함수 리턴 시에는 accept가 채워넣은 주소 정보 크기를 갖게 된다.
    );
    * 클라이언트의 IP주소와 포트 번호를 알 필요가 없다면 addr, addrlen에 NULL 전달
    </code></pre>

### TCP 클라이언트 함수
1. 일반적으로 TCP 클라리언트는 다음과 같은 순서로 소켓 함수를 호출한다.
    1) socket(): 소켓 생성 및 프로토콜이 결정된다.
    2) connect(): 원격-지역 IP 주소와 포트 번호가 결정된다.
    3) send(), recv() 함수로 클라이언트와 데이터 송수신 후 closesocket() 함수로 소켓을 닫음
2. 클라이언트 함수
    <pre><code>
    // connect 함수
    int WSAAPI connect(
        SOCKET         s,       // 서버와 통신할 소켓
        const sockaddr *name,   // 서버측의 소켓 주소 구조체를 초기화하여 전달
        int            namelen  // 소켓 주소 구조체의 길이
    );
    </code></pre>

### TCP 데이터 전송 함수
1. 소켓 주소 구조체에는 지역/원격 주소 정보 이외에 데이터 송수신 버퍼가 있는데 이를 **소켓 버퍼**라 부른다.
    * 송신 버퍼는 **데이터를 전송하기 전**에 임시로 저장해두는 공간이고, 수신 버퍼는 받은 데이터를 **응용 프로그램이 처리**하기 전까지 임시로 저장해두는 공간이다.
2. TCP 서버-클라이언트를 작성할 때는 데이터 경계 구분을 위한 상호 약속이 응용 프로그램 수준에서 필요하다.
    * 예를 들어, 클라가 100, 200, 300 바이트 데이터를 차럐ㅖ로 보낼 경우 서버가 데이터의 경게를 구분하지 못하고 250, 350 바이트 데이터를 읽을 수 있다.
3. send 함수
    1) 기능: 응용 프로그램 데이터를 OS의 송신 소켓 버퍼에 복사함으로써 데이터를 전송한다. 소켓 버퍼로의 데이터 복사가 성공하면 곧바로 리턴한다. 따라서 함수가 리턴되었다고해서 실제 데이터가 전송된 것은 아니며, 하부 프로토콜 처리까지 완료되어야 전송이 완료된다.
    2) 함수 구조
    <pre><code>
    int WSAAPI send(
        SOCKET     s,       // 서버와 연결된 소켓
        const char *buf,    // 전송할 데이터 버퍼
        int        len,     // 버퍼 길이
        int        flags    // 함수의 동작을 바꾸는 옵션으로, 대부분 0을 사용한다.
    );
    * send 함수는 SOCKET 인자로 전달되는 소켓의 특성(블로킹, 넌블로킹)에 따라 아래 두 종류의 리턴을 한다.
    * 블로킹 소켓: 송신 소켓 버퍼의 여유 공간이 세 번째 인자 len보다 작은 경우 해당 스레드는 blocking 상태가 된다. 같거나 큰 경우 함수는 len을 리턴한다.
    * 넌블로킹 소켓: ioctlsocket 함수로 블로킹->넌블로킹 소켓으로 바꿀 수 있다. 넌블로킹 소켓을 대상으로 send를 호출하면 송신 소켓 버퍼의 여유 공간만큼 데이터를 복사한 후
    실제 복사한 바이트 수를 리턴한다.
    </code></pre>
4. recv 함수
    1) 기능: OS의 수신 소켓 버퍼에 도착한 데이터를 응용 프로그램 버퍼에 복사한다.
    2) 함수 구조
    <pre><code>
    int recv(
        SOCKET s,       // 서버와 연결된 소켓
        char   *buf,    // OS 수신 소켓 버퍼로부터 데이터가 복사될 버퍼
        int    len,     // SO 수신 소켓 버퍼로부터 복사할 최대 데이터 크기(buf보다 크면 안 됨)
        int    flags    // 함수의 동작을 바꾸는 옵션으로, 대부분 0을 사용한다. 윈도우 비스타 이후에는 MSG_WAITALL를 추가하여 len만큼 데이터를 받을 때까지
                        // 해당 함수를 호출한 스레드가 블로킹된다.
    );
    * recv 함수는 다음 두 종류의 리턴을 한다.
    * 수신 버퍼에 데이터가 도달한 경우: 세 번째 인자 len 이하 크기의 데이터를 복사하고, 실제 복사한 바이트 수를 리턴한다.
    * 접속이 정상 종료한 경우: 상대방 호스트가 closesocket으로 접속을 종료하면, TCP 프로토콜(L4) 수준에서 접속 종료를 위한 패킷 교환 절차가 일어난다.
    이 경우 recv 함수는 0을 리턴한다.(정상 종료라 부름)
    </code></pre>
5. TCP의 종료
    * TCP 종료 시 FIN-ACK-FIN-ACK 네 개의 패킷 교환이 일어난다. 그러나 때로는 FIN-FIN/ACK-ACK 세 개의 패킷이 교환 되기도 한다.
    * 먼저 closesocket 함수를 호출한 소켓의 TCP 포트는 곧바로 파괴되지 않고 TIME_WAIT라는 특별한 상태를 거친 후 사라진다. 보통 TIME_WAIT은 5분을 넘지 않는다.

## Section03 TCP 서버-클라이언트(IPv6)
### IPv6를 지원하기 위한 코드
1. Ipv4 -> IPv6 코드로 변환하는 규칙
    1) ws2tcpip.h 헤더 파일을 포함
    2) 소켓 생성 시 AF_INET -> AF_INET6
    3) 소켓 주소 구조체로 SOCKADDR_IN -> SOCKADDR_IN6 사용
    4) IPv4만을 지원하는 함수를 Ipv4/Ipv6 지원 함수로 대체

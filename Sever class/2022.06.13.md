# 2022/06/13 수업내용
# 네트워크 라이브러리
    * 본 수업내용은 네트워크 라이브러리 설계에 대한 내용을 다룬다.
## 에코 서버
### 디버깅
1. 문제가 의심되는 것의 명확한 이유를 찾기 위하여 증명을 하는 코드를 넣어 자료로 확인해야 한다.
    * 예를 들어 내가 겪은 문제 중 특정 세션이 Release를 안 타는 문제 상황에 대한 원인(IO count가 차감되지 않는 경우)이 의심될 때, IO count가 차감되지 않는 경우를 로깅하여 증거를 남기고 이유 또한 추적해야 한다. 

## 네트워크 라이브러리
### 동기화
1. 이전 시간에서 세션의 메모리가 해제되었을 때 발생하는 문제들을 메모리풀을 사용하여 해결하는 방법은 아래와 같다.
    1) 세션의 동기화 객체가 삭제되는 것이 가장 원초적인 문제가 된다.
    2) 해결점1: 동기화 객체가 삭제되는 것을 해결
    3) 해결점2: 해당 세션이 다른 스레드에 의해 삭제 될 때
    <pre><code>
    // 새로운 코드
    // SendPacket 함수
    {
        세션Map.Lock();
        세션.검색();
        세션Map.Unlock();
        
        세션.Lock();
        세션 ID 확인(재확인)
        세션.Unlock();
    }
    
    // Diconnection 함수
    {
        세션Map.Lock();
        세션.erase();
        세션Map.Unlock();
        
        세션.Lock()
        // 고민사항1
        세션 삭제
        세션.Unlock()
    }
    * 고민사항1: 여기서도 세션 ID를 확인하는 코드가 들어가야 하나? => 결론적으로 아니다. 그 이유로는 
    </code></pre>
2. 세션의 사용 문제
    1) 어떤 리소스를 접근한다라는 상황이 되었을 때, 보통 메모리 포인터를 접근할 수 있다.
3. 세션 삭제와 해제
    1) 

### 세션
1. 세션이 삭제되고 세션이 새로 생성되는 것을 막느다는 것은 매우 힘든 선택이다.(모든 것에 대해 Lock을 걸자라는 것이니까)

### 메모리풀과 게임 구조
1. MMORPG더라도 인스턴스 던전이 주 서버가 된다.
2. 인던과 메모리풀의 관계
    1) 메시지 수신 -> 유저확인 및 인던 ID(컨테이너 Lock이 걸림)
        * 문제점: 인던 ID 검색되거나 삭제될 때 어떤 컨테이너를 통해 작업할 것이다. 이때 인던이 동적으로 할당되어 해제가 이루어지게 되면 위에서 언급했던 세션이 삭제되는 건으로 인한 문제가 똑같이 발생할 수 있다.
        * 따라서 메모리풀을 사용하여 구현하는 방법밖에는 답이 없다. 
3. 어설프게 C++을 하는 사람들이 스마트 포인터로 이 문제를 해결할 수 있다고 한다.a

### Wrapping
1. Recv 완료통지
    1) 메시지 완료 확인
    2) 직렬화 버퍼에 데이터 삽입
    3) OnRecv 함수를 호출. 
        * OnRecv의 역할: 세션 ID와 ㅖㅁ찯ㅅ
        <
    * 목적: 컨텐츠와 네트워크 라이브러리를 분리시키기 위한 작업이다.
2. OnRecv 함수
    1) 기능
    2) 구조
        <pre><code>
        // 에코 서버를 기준으로 작성
        OnRecv(세션, CPacket*)
        {
            int64 Echo;
            Packet >> Echo;
            
            CPacket SndCPacket;
            SndCPacket << Echo;
            SendPacket(세션ID, &SndCPacket);
        }
        </code></pre>
    3) 주의점1: 컨텐츠, 패킷의 크기에 대한 정보는 OnRecv에서만 알아야 한다. 다른 곳의 함수에서는 모른다.
    4) 주의점2: OnRecv는 헤더에 대하여 몰라야 한다. 헤더는 SendPacket 내부에서 생성하게 된다.
3. SendPacket
    1) 구조
        <pre><code>
        SendPakcet(세션ID, CPacket*)
        {
            헤더 생성
            SendQ.EnQueue(헤더);
            SendQ.EnQueue(메시지);
        }
        </code></pre>
        * 고민사항1: SendQ 인큐를 2번하는 것을 개선하는 방법을 생각해보자. 해결 방법은 애초에 직렬화 버퍼 앞쪽에 헤더만큼 빈 공간을 두는 것이다. 이렇게 할 수 있는 방법으로는 네트워크 라이브러리에서만 사용할 수 있는 함수를 
5. 패킷
    1) 패킷 내부에 네트워크 헤더를 추가할 것이다.
    2) 이제부터 네트워크 헤더와 컨텐츠 헤더를 분리할 것이다.
        * 네트워크 헤더: 메시지 길이, 
        * 컨텐츠 헤더: 메시지 타입, 

### 성능과 네트워크 라이브러리
1. 흔히 네트워크 엔진 성능을 말할 때 에코 서버를 말한다. 그러나!! 이는 정확한 성능 측정 방법이 아니다. 그 이유로는 위에서 설명한 OnRecv 함수에서 

## 기타
### 서버
1. 일단 세션 할당 및 해제를 메모리풀로 구현해볼 것
2. 패킷 헤더 종류
    1) 2btye 헤더: 메시지 길이 정보만 들어있는 헤더
    2) 5byte 헤더: 2byte + 안정장치
3. 우리의 네트워크 라이브러리 제작 목적은 성능을 높이는데 있는 것이 아니다. 멀티스레드의 문제점을 극단적으로 파악하기 위한데 그 목적이 있다.
    1) 우리는 동기화 객체, 세션 컨테이너를 없앨 것이다.
    2) 동기화 문제에 관해서는 성능에 대한 논의를 하지 않을 것이다.

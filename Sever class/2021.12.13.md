# C++
## include
1. 컴파일 확장자 대상: .c, .cpp (.h는 대상이 아니다.)

## class
1. C++에서 구조체와 동작방식, 구현 방식이 같다.
2. 언제 class를, 언제 struct를 사용하나? -> class(객체)는 혼자 특정한 동작을 하는 독립체, struct는 데이터 덩어리라고 보는 것이 좋다.
3. class 안에 enum을 정의하는 경우가 많다.
<pre><code>
#define MAX 100
class C {
  enum{
  MAX = 100
  }
  char buf[MAX]; // class 내부 MAX를 사용
}
</code></pre>
4. class 내부에서 생성자와 소멸자 그리고 함수를 **정의**하면 inline 함수 처리가 된다. 내부에서는 선언, 외부에서 정의하면 inline 옵션에 따라 처리된다.
5. 기본 class 파일 구조: class.cpp 하나에 class.h
    1) .h에는 클래스 선언부
    2) .cpp에는 정의부

## enum
1. enum [이름], enum class [이름]의 차이점
    1) enum [이름]으로 선언한 경우 다른 두 개의 enum이 같은 상수 표현이 있다면, 서로 겹쳐 에러가 발생한다.
    2) enum class [이름]으로 선언한 경우 다른 구 개의 enum class가 같은 상수 표현이 있어도, 겹치지 않아 에러가 발생하지 않는다.
2. constexpr
    1) 최근 define, enum보다 constexpr로 상수를 표현하는 것을 권장한다. (enum의 열겨 형태를 사용하지 않는 경우만)
    2) define, enum과 다른 점은 컴파일 타임에 상수로 치환되는것이 아닌 런타임에 치환이 된다(그렇다면, 런타임 수행 시간에 차이가 있는가? -> 검증 필요)

## const
1. 전역 const는 RO 영역에 저장되어 컴파일 에러가 발생한다. 지역은 Stack 영역에 저장되어 컴파일 에러가 발생하지 않는다.
2. define과 enum, const는 런타임 수행시간에 차이가 없다. (실제 디버깅 필요)

## 객체지향
1. 정보은닉
    1) 클래스 내부에 private 변수를 getter, setter로 접근하는 것은 **정보은닉**이 아니다. (더 복잡하고 필요없는 수행만 늘어나게 된다.)
    2) 클래스 멤버 변수의 제공 및 변경이 아닌 동작에 대한 **결과**를 제공하여야 한다.
        <pre><code>
        class C {
          private:
          int hp;
          public:
          void isDie(hp);
        }        
        </pre></code>
    * getter, setter 만들지 않을 것!!
2. 객체의 활용
    1) 동일한 요소에 대한 동작을 독립적인 객체를 필요할 때 생성, 삭제만으로 구현이 가능 (서로 연관성이 없어짐)
3. 객체를 적용하기 어려운 점
    1) 서로 연관성이 있는 동작에 대한 작업이 필요할 때

## 멤버함수
1. const선언
    1) const 함수 내에서는 동일 클래스에 선언된 멤버변수의 값을 변경하지 못함!
    <pre><code>
    class C {
        int hp;
        int x;
        int y;
        void GetY() {return y;}
        void GetX() const {return x;}
        void isDie(hp) const
        {
            cout<<GetX()<<endl;
            cout<<GetY()<<endl; // 컴파일 에러
        }
    };
    </code></pre>
    
## 멤버변수
1. modern c++에서는 const인 경우 클래스 내부 선언부에서 직접 데이터 저장 가능(이전에는 이니셜라이저로만 가능했음)
    * 참조 변수의 경우는 이니셜라이저만 허용
    
## 생성자와 소멸자
1. 객체 생성 시 class a();와 같은 명령은 틀린 표현이다.
2. 생성자에서 **이니셜라이저**에서 변수를 **초기화**하는 것과 생성자 내부에서 데이터를 저장하는 것은 차이가 있다 .
3. 디폴트 생성자와 소멸자는 상속의 관계에 있을때만 생성된다. 일반적인 클래스의 경우는 생성하지 않는다.
4. 지역 클래스의 경우 객체의 메모리는 함수 진입 시 확보되지만, 생성자 호출과 소멸자 **호출 시점**은 명령문이 작성된 블록 내부가 된다.
    * 때문에 클래스 생성의 경우 사용하고자하는 블록안에서 생성하는 것이 좋다.

## 컴파일러가 번역하는 

# 2022/06/03 수업내용
# IOCP
## TCP 소켓 프로그래밍 도서
### 예제(우리 스타일)
1. 수도 코드
    <pre><code>
    Session {
        Socket  // 소켓은 재사용될 수 있기 때문에 
        IP
        Port    
        SessionID
        RecvQ, SendQ
        SendOverlapped      // 이 정보는 _OVERLAPPED 구조체를 확장 시켜 send, recv 작업 등의 정보가 포함되어 있다.
        RecvOverlapped
        IOCount
    }
    </code></pre>
2. 세션 정보
    1) 멀티스레드에서 소켓은 재사용될 수 있기 때문에 세션 정보로 취급하면 안 된다.
        * 지금 당장은 고유하지만 재사용 될 수가 있다.
        * 멀티 스레드이기 때문에 송수신, 연결 끊김 등이 각기 다른 스레드에서 동작한다. 때문에 재사용에 따른 위험이 항상 존재한다.
        * 크기를 4byte? 8byte? => 4byte라면 1초에 1000명씩 들어온다면 49.7일에 오버플로우가 발생할 것이고 8byte라면?.. 무지 크다. 우리 입장에서는 1초에 3000~4000명을 커버할 수 있는 네트워크 라이브러리를 만들 것이기 때문에 8byte로 할 것이다.
    2) 우리는 네트워크 라이브러리를 만들기 때문에 재사용되지 않는 고유한 정보로 설계되어야 한다.
3. 워커 스레드에 전달되는 세션 정보
    1) 워커 스레드에 전달되는 Overlapped는 SendOverlapped나 RecvOverlapped가 될 것이다.
    2) 워커 스레드에 전달되는 Key는 위에서 구조된 Session의 주소가 될 것이다.(즉 세션 정보를 전달)
4. SeesionTable(=SessionMap)
    1) 의미: 세션 정보의 자료 컨테이너
    2) Key: SeesionID, Value: Session*
    3) 삽입, 삭제, 검색을 어떤 스레드가 할 것이냐?
        * 삽입: Aceept 스레드
        * 삭제: 누구나
        * 검색: 누구나
        * Accept 스레드에서도 삭제, 검색이 일어날 수 있다. Accept를 하자마자 Recv에서 에러가 나는 경우 일어날 수 있다.
5. RecvPost, SendPost
    1) 정의: RecvPost, SendPost는 각각 실제로 WSARecv, WSASend를 호출하는 함수가 된다.(실질적인 IO를 거는 함수)
    2) RecvPost 호출 시점: Accept 후, IOCP에 의해 WSARecv의 IO가 완료되었을 때
    3) SendPost 호출 시점: 
    4) RecvPost 설계
        * 인자: 세션의 정보(통 세션의 포인터 혹은 세션 구분자), 
        * 코드
            <pre><code>
            RecvPost(세션,...)
            {
                세션->RecvOverlapped 초기화
                WSABUF buf[2];      // 지역으로 ~~을 선언한 것을 삽입하여 어떤 오작동이 일어날 수 있는지 재현해볼 것
                buf[0] = 세션->RecvQ.BufferPtr;
                buf[1] = 세션->RecvQ.BufferPtr + RecvQ.DirectQPoint;
                
                ret = WSARecv(...);
                if (ret == FALSE)
                {
                    if (에러 != WSA_IO_PENDING)
                    {
                        // 진짜 에러
                    }
                }
            }
            </code></pre>
    5) SendPost 설계
6. 세션의 종료
    1) WSARecv와 WSASend에서 소켓에 대한 문제가 발생하였을 때 세션을 끊으면 발생할 수 있는 문제
        * 우려사항 1: 세션에 대한 완료 통지가 뒤늦게 도착했을 때의 워커 스레드에서의 오작동이 있을 수 있다. 그 이유로 동적 할당된 OVERLAPPED, 세션 정보에 대하여 로직을 돌리면서 문제가 될 수 있다. 이때의 세션 정보의 Page fault 상황(Decommit)과 완전 다른 정보가 해당 메모리에 적재된 경우 문제가 된다.
        * 우려사항 2: Overlapped 구조체와 버퍼가 삭제되는 것 자체의 문제 => 실제로 소켓이 끊기거나 문제가 생긴다면 그 즉시! IO 작업이 중지된다. 따라서 Overlapped 구조체와 버퍼가 삭제되는 것에 대한 문제는 일어나지 않는다. 따라서 이 우려사항은 대상이 아니다!!
        * 우려사항 3: 다른 스레드에서 해당 세션 정보에 접근하는 경우(동기화로 해결)
        * 굳이 WSARecv나 WSASend에서 에러를 확인 후 바로 세션을 종료를 해야한다면, IOCP에 통지를 많이 큐잉하고 시간을 벌어 세션 메모리를 재활용한다.
    2) 어떠한 세션을 대상으로 IO 요청이 0이 되는 순간 세션을 종료시킬 것이다. 이유는 우리에게 멀티 스레드 환경에서 세션에 대한 IO 작업이 안 걸리는 경우는 없기 때문이다.
        * Session 정보에 IOCount를 기록하여 보관한다.
        * IOCount를 0인지 검사하는 코드를 어디에 두냐에 따라 정상 동작과 오작동이 될 수 있다.

## IOCP
### 멀티스레드에서의 RecvQ, SendQ
1. SendQ가 필요한 이유
    1) 싱글 스레드
        * 우리가 필요할 때마다 Send를 보냈을 때 보낼 수 없는 상황이라면 문제가 생길 것이다.(=소켓 송신 버퍼가 가득참)
    2) 멀티 스레드
        * 오로지 성능을 위해서이다. Overlapped IO에 들어가는 오버헤드(페이지락, IO 등록 등)보다 SendQ에 복사하는 비용이 적을 수 있을 확률이 높기 때문이다.

### 동기적인 IO에 대한 처리
1. IOCP에는 동기-비동기 IO 완료 모두 전달된다. 그래서 동기-비동기 IO 완료에 대해 처리를 분리시킬 수 있다. 그러나! 우리는 일관성, 오류 방지에 대

### 완료 통지
1. WSARecv, WSASend에 대한 요청이 성공적으로 이루어졌다면 IO 작업이 중단되었거나 에러가 발생하였다해도 완료 통지는 올 것이다.
    * IO 작업이 중단되었거나 에러가 발생한 경우 완료 통지는 그 즉시 IOCP에 쌓인다.
    * WSARecv, WSASend에 대한 요청이 성공: 반환 값이 TRUE이거나 FALSE && IO_PENDING인 경우

### 기타
1. 성능 테스트 해볼 것

## 기타 키워드
### 과제
1. 에코 서버 만들기
    1) 

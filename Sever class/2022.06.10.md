# 2022/06/10 수업내용
# 멀티스레드
## ECHO 서버
### 디버깅
1. 문제가 되는 상황에서 문제가 해결되기 전 까지는 로직 변경은 절대 해서는 안 된다. 추적을 위한 디버깅 코드를 추가하여 디버깅을 해야 한다.(그러나 디버깅 코드로 인해 문제가 감춰질 수 있음)
    1) 문제에 대한 가설을 세우고 가설이 맞는지 확인할 수 있는 디버깅 코드를 추가
2. 세션 Release에 대한 문제
    1) 단순히 Release 함수 호출 횟수에 대한 카운팅을 하여 해결해본다? => 비교군을 찾아야 한다. Accept 횟수(세션이 생성된 횟수)와 비교해 볼 수 있다.
    2) Release가 왜 되지 않았느냐를 찾아야 한다. => 해당 세션에 대한 동작을 추적해야 한다. 이 세션이 이전에 어떤 스레드에서, 어느 함수를 거쳐, 어떤 동작을 했고, 이런 결과가 나왔는지를 메모리 로깅을 통해 추적해야 한다.
    3) 메모리 누수: NP풀이 증가한다면 세션 안에 소켓에 대한 문제로 볼 수 있다. 더 나가면 socket에 대한 IO 요청으로 인한 증가와 IOCP 완료 통지 쌓임으로 인해 증가한 것인지를 생각해 볼 수 있다.
3. NP풀 증가 요소
    1) SOCKET
    2) IO 요청
    3) IOCP 완료 통지
4. 소켓이 closesocket이 안 되었다면 작업관리자에서 프로세스 핸들 갯수를 확인하여 처리에 대한 결과를 추적할 수 있다.(소켓 할당 시 프로세스 핸들로 갯수가 잡힌다.)

### 스레드
1. 현재 에코 서버에서 세션에 접근할 수 있는 최대 스레드 개수
    1) 이유: 송수신 완료 통지에서 WSARecv 혹은 WSASend 호출 시에 그 즉시 송수신 완료 통지로 인해 다른 스레드가 깨어나 세션에 접근할 수 있다.
    2) 현재 에코 서버에서 문제가 안 생기는 이유: IO를 건 다음에 딱히 세션에 대한 추가적인 작업이 없기 때문이다.
        * 만약 추가적인 작업이 들어간다면 1)에 상황과 맞물려 여러 스레드가 한 세션에 접근하여 문제가 발생할 것이다.

### 동기화
1. 현재 에코 서버에서는 각 세션마다 (유저)동기화 객체를 두고 있는 상태이다. 그러나 이렇게 세션마다 동기화 객체가 필요할까?
    1) 판단의 기준: 경합이 발생할 수 있는지 생각해 보아야 한다. 
        * 결론적으로 세션마다 동기화 객체를 거는 것이 효과적이다. 세션마다 동기화 객체를 두게되면 워커 스레드들이 같은 세션에 대한 Lock을 걸 확률이 거~의 없어진다. 
        * 세션마다 동기화를 두지 않는다 하여도 다른 대안이 필요할 수 밖에 없다. 이러한 상황에서도 대안에 대한 어떠한 동작이 똑같이 들어가게 되면 그에 대한 오버헤드가 발생하게 되어있다. (다른 대안은 Interlocked 밖에 없을 것이다.)
2. Lock 시점에 대한 고민
    1) 완료 통지 최상단에서 세션에 접근하기 전에 Lock을 걸고 최하단에서 Unlock을 한다.
    2) 함수 단위로 볼 때의 Lock: 함수를 호출함으로서 세션에 대한 Lock을 고려할 때 함수 외부에서 Lock을 거는 경우와 Lock을 걸지않는 경우를 생각해보아야 한다. 그렇다라면 SRWLOCK 보다는 CS를 선택하는 편이 나은 방법일 수 있다. 
        * RecvPost: Accept 혹은 완료 통지에서 에서 호출할 수 
        * SendPacket: 
5. 현재 세션의 SendFlag, IOCOunt 와 동기화 객체는 서로 다른 목적을 가진다.
    1) SendFlag, IOCount: 어떠한 작업의 횟수를 제한시키기 위한 기능을 한다.
    2) 동기화 객체: 어떠한 순간에 동시 접근하는 것을 막는 것이다.

### 네트워크 라이브러리 - SendPost와 RecvPost
1. SendPacket
    1) Send는 수신 완료 통지 혹은 외부에서 언제든지 부를 수 있는 상황이 만들어진다. 우리는 어디에서든 호출하여도 정상적인 동작을 보장하는 라이브러리로 만드는 것이다.
        * 위와 같은 상황으로 인해 SendPacket 함수 '내부'에 Lock이 들어가는 형태가 되어야 한다.
    2) 인자 변경사항: 현재는 세션에 대한 정보로 포인터를 받고 있지만 세션 ID로 바꿀 것이다.
        * 네트워크 라이브러리를 설계 시 외부에 제공되어야 할 정보는 장단점을 잘 따져보아야 한다. 세션 포인터를 인자로 하였을 때 장단점은 아래와 같다.
            * 장점: 네트워크 라이브러리 안에서 세션을 찾을 필요가 없다.
            * 단점1: 라이브러리 함수 외부에서 세션을 찾아야 한다.
            * 단점2: 라이브러리 사용자가 임의로 세션의 정보를 변경할 수 있다.
            * 단점3: 라이브러리 내부에서 세션에 대한 정보를 삭제로 인한 외부에서의 메모리 참조 오류가 발생할 수 있다.
    3) SendPacket 내부
        <pre><code>
        SendPacket(세션ID, 메시지)
        {
            세션Map.lock(); 
            세션Map.find();       // 여기서 찾기 못하면 바로 함수 실패 리턴
            // 세션Map.unlock();  // 문제점: 
            
            세션.Lock
            세션Map.unlock();     //
            세션 사용
            세션.Unlock
        }        
        </code></pre>
2. 세션 삭제 - Disconnection
    1) 구조
        <pre><code>
        세션 삭제(...)
        {
            세션Map.Lock()
            세션 검색
            세션.Lock()
            세션.Unlock()
            세션 삭제
            세션Map.Unlock()
        }
        </code></pre>
    

## 기타 키워드
### 에코 서버

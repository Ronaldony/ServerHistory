# 2022/06/08 수업내용(복습 완료)
# IOCP
## 서버
### 세션
1. 세션의 재설계
    <pre><code>
    Session
    {
        // ... 
        SendFlag    // Send를 1번 하기 위한 플래그
        RecvFlag
        LockSession // 커널 동기화 객체
    }
    </code></pre>
    * LockSession을 넣는 것은 흔히 쓰이는 일반적인 방법이다. 추후 우리는 다른 형태로 멀티 스레드에 안전하게 만들 것이다.(Lock이 없을수도 있고)
2. 세션의 종료
    1) 세션의 종료: 소켓을 닫고 동적 할당된 세션을 해제하는 것
    2) 기본적으로 지켜야 할 사항은 누군가가 IO를 (세션을) 사용하는 중이라면 세션을 종료해서는 안 된다.
        * 동기화 객체여도 완료 통지에 있는 세션에 대한 작업에 대한 동기화는 시키지 못한다.
3. SendFlag
    1) Send를 1회로 제한하기 위한 플래그
    2) (에코 서버 기준)기존에는 수신 완료 통지에서만 Send를 하였지만 수신 완료 통지 결과를 처리할 때 송신 중이라면 SendPost 동작이 될 수 없다. 따라서 이제는 송신 완료 통지에서도 SendFlag를 검사하여 SendPost를 호출해야 한다. 

### 동기화
1. 동기화의 의미
    1) 의미1: 동시에 공유 자원에 접근하지 못하게 하는 것
    2) 의미2: 공유 자원을 제거해야하는 상황에서 다른 스레드에서 사용중이지 않을 때에만 제거하는 것
2. 동기화 객체는 위 의미2에 해당하는 작업은 해주지 못한다. 여기서는 IO Count가 그 역할을 해야 한다.

### IO COUNT
1. IO Count 증가와 완료 통지
    1) 완료 통지의 특성:동기던 비동기던 WSARecv나 WSASend가 지금 당장 완료할 수 있다면 해당 함수가 끝나기도 전에 완료통지가 온다.
    2) IOCount의 목적
        * 목적: 다른 스레드가 Session에 대한 작업을 진행중일 때 Session을 제거하지 못하게하는 것이다.
        * 동시에 Session에 접근하지 못하게 하는 것은 동기화 객체의 역할이다. IOCount의 역할은 아니다.
    3) 증가의 시점
        * 위에서 언급한 완료 통지의 특성으로 인해 WSASend, WSARecv를 호출하기 전에 IOCount를 증가시켜야 한다. 만약 호출 후에 증가를 시키게 된다면 IO Count가 0이 되는 순간이 있을 것이다.
2. IO Count 차감과 세션 종료
    1) 세션 종료 시점
        * IO Count가 0이 되는 순간 즉, IO Count가 차감되는 순간에 세션 종료도 같이 검사 후 이루어져야 한다.
    2) 차감의 시점
        * 시점1: 위 증가의 시점을 고려하여 Recvpost 혹은 Sendpost 이후 차감이 되어야 한다. (이전에 한다면 0이 되는 시점이 있을 수 있다.) 그렇다면 차감의 시점은 송수신 워커 스레드 최하단이 되겠다.
        * 시점2: WSARecv 혹은 WSASend 함수에서 에러가 발생한 경우
    3) 세션 종료 코드의 위치
        * 기본적으로 모든 차감 구간에 세션 종료 코드를 위치시켜야 한다. 또한 내 스레드가 0으로 만들었는가를 봐야한다. 따라서 Interlocked 함수의 결과값을 기준으로 판단해야 한다.
        * 시점: 위에서 언급한 시점1, 2 바로 뒤
    4) 세션 종료의 핵심은 어떠한 완료 통지이던 간에 세션에 대한 가장 마지막 완료 통지가 처리되는 순간에 세션을 릴리즈(종료)하는 것이다!!!!!!!

### GQCS
1. 반환과 인자에 대한 판단
    1) GQCS의 반환 값, transferred, Overlapped에 대한 모든 경우의 수에 대한 처리 코드가 들어가면 굉장히 복잡해진다. 따라서 우리의 코드는 다음과 같이 처리를 할 것이다.
    2) GQCS 반환 값
        * 결론적으로 성공과 실패 여부를 판단하지 않을 것이다. 성공은 IO 작업에 성공, 실패는 IO 작업에 실패한 경우이다. 예를 들어 Send 작업중 세션이 끊긴 경우 실패한 것이다. 우리는 딱히 이부분에 대해 판단할 필요가 없다. 이것을 가지고 우리가 할 수 있는게 없기 때문이다.(이 상황에서 세션을 마음대로 끊을 수도 없고 스레드를 종료할 수도 없기 때문이다.)
        * 만약 실패했다면 이후 IO작업은 자동적으로 모두 실패할 것이다.
        * 그러나 실패 시 GetLastError()를 확인하여 어떤 에러 코드인지 확인해야 한다.(로그만을 위해서)
    3) transferred
        * 특이 사례: 작업 중 세션이 끊겼다면(GQCS가 실패함) send 요청 값보다 작은 값이 나올 것이다.
        * send 요청 값보다 작은 값이 나와도 세션 종료에 대한 처리는 하지 않을 것이다. 그저 SendQ 링버퍼에 대한 처리만 할 것이다.
        * transferred가 0이 나왔을 때 송수신 중 어떤 완료 통지인지 구분하지 않을것이다. (그저 끊겼다고 판단할 것이다.)
    4) Overlapped(확장된 OVERLAPPED 구조체)
        * 스레드 종료 용도: Overlapped가 NULL인 경우 아래 완료 통지에서 언급한 3가지 원인 중 하나이다. 이는 종료할 조건이 된다.(Timeout을 사용할 것이라면 추가적인 코드를 작성해야 한다.)
            1) IOCP 문제(IOCP 디큐잉 실패)
            2) Timeout
            3) 스레드 종료를 위한 PostQueued.. 호출
        * 작업 판단: recv 혹은 send에 대한 작업 판단을 하는데에만 사용할 것이다.
2. 전체적인 처리 코드
    <pre><code>
    // GQCS
    if (NULL == Overlapped)
        // 스레드 종료
    if (0 == transferred)
        // 세션 종료 판단(IOCount-- 등..)
    if (송신 완료 통지)
    if (수신 완료 통지)
    </code></pre>

### 완료 통지
1. 완료 통지의 시점
    1) WSARecv, WSASend 요청에 성공한 경우 IO 작업에 실패하여도 GQCS로부터 완료통지가 전달된다.(Overlapped가 NULL이 아니다.)
    2) WSARecv, WSASend가 둘 모두 IO 요청이 되었을 때 두 완료 통지에 대한 순서를 보장받을 수 없다.
        * 사례1: 세션이 종료된 상황이다. WSARecv에 대한 완료 통지로 실패(함수 반환 값) 및 transferred가 0이 나오고 WSASend에 대한 완료 통지로 transferred가 요청 값보다 적게 나왔다. 이 상황에서 이 두 완료 통지에 대한 앞뒤 순서는 보장받을 수 없다.
        * 사례2: 동기던 비동기던 WSARecv나 WSASend가 지금 당장 완료할 수 있다면 해당 함수가 끝나기도 전에 완료통지가 온다.

### 함수 추가
1. SendMessage(=SendPacket)
    1) 기능: 입력된 메시지를 SendQ 링버퍼에 인큐한 후 SendPost를 호출하는 함수
2. Sendpost
    1) 기능: SendFlag를 확인하여 WSASend 호출 여부를 결정

### 네트워크 라이브러리
1. 실제 네트워크 라이브러리라면 어떤 세션, 스레드에서든지 Send, Recv가 가능해야 한다. (제한을 둘 수 없기 때문)
    1) 그러나 지금 우리가 만들고있는 에코 서버는 Send 작업을 수신 완료 통지가 와야만 하게 되어있다. 이러한 구조는 애초에 멀티 스레드로 동작되지 않는다.
    2) 그래서 추가된 함수가 위 SendPacket이다. 이는 라이브러리 사용자에 의해 호출될 것이다.

### 디버깅
1. 파일, 콘솔에 로깅을 하는 것은 동기화를 먹어버리기 때문에 멀티스레드의 디버깅 대상이 아니다.
    * 따라서 최대한 빠르게 메모리에 로깅(흔적)을 남기는 방향으로 디버깅해야 한다.
2. 멀티스레드의 가장 큰 해결점은 디버깅하는 감을 잡는 것이다.

## 기타 키워드
### IOCP 에코 서버 과제
1. transferred가 0이면 closesocket만 하는 코드를 넣기(즉 세션만 끊기)
2. 실제로 세션 종료가 어디서 이루어지는지 로그로 남기어 디버깅 감각을 키울 것
3. 더미 클라이언트 기능: Echo STOP을 하면 모니터링 정보 Wait Echo Count가 0이 되어야 한다.

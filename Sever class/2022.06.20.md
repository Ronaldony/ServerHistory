# 2022/06/20 수업내용
# 네트워크 라이브러리
## 제로 카피
### 제로 카피
1. Overlapped IO가 아닐 때 IO Pending이 일어나는 상황을 말한다.
2. 우리의 상황
    1) 상황: 직렬화버퍼(App) -> SendQ -> TCP 송신 버퍼.
    2) 위 상황에서 
    3) 구조 개선 - 직렬화 버퍼를 SendQ에 복사하지 않고 Send에 바로 꽂아버리는 방법을 생각할 수 있다. 즉 SendQ를 없앨 수 있을까?
3. 직렬화 버퍼
    1) 위치: 힙에 할당하여 들고 있어야 한다. 그래서 일단 초기에는 new, delete를 사용하여 구현할 것이다.
    2) 제거 시점: 제거 시점이 애매하다. 그래서 세션과 유사하게 참조 카운트를 넣어 0일 때 삭제한다. (송신 완료 통지가 왔을 때)
        * 문제점: 포인터 몇개를 해제할 지 알 수 없다.
        * 해결: 해당 세션 정보에 몇개를 등록했는지 저장해놓는다.
4. wsabuf와 SendQ의 재활용
    1) 생성된 직렬화 버퍼의 포인터를 SendQ에 꽂을 것이다. 원래는 버퍼를 복사하는 것이지만 이제는 버퍼 포인터를 등록할 것이다.
    2) 위에서 등록된 버퍼 포인터를 wsabuf에 개수대로 꽂아버릴 것이다.

### 제로 카피 코드
1. 코드
    <pre><code>
    SendPost
    {
        WSABUf buf[x]; // x: 개수에 대한 논의
    }
    </code></pre>
2. 등록할 WSABUF 배열 크기에 대한 논의
    1) 첫 번째: 동적 할당. 오버헤드가 생기는 문제점이 생긴다.
    2) 두 번쨰: 정적 할당. 배열 크기에 대한 크기는 알아서 결정할 몫이다.
        * SendBuffer를 적게 보내는 경우와 많게 보내는 경우에 어떤 차이가 나는지를 보고 판단해야 한다.
        * 한 번에 쏟아내는 것이 맞을지 적정치만 보내고 다음에 보낼 지 결정할 수 있다.
        * 한 번에 쏟아낸다면 유저가 하나면 상관이 없지만 다수라면 서로 간에 

### SendQ의 목적
1. Overlapped IO에서의 목적
    1) Send를 1회로 제한하기 위하여 모아놓고 건당건당 

### 소켓 버퍼
2. 현재 상황에서는 소켓 송수신 버퍼는 0이 되지 않는다. 0으로 설정하려하면 OS가 알아서 늘릴것이다.
3. 분석
    1) IO Pending가 얼마나 발생하는지 살펴보기
    2) 송수신 소켓 버퍼 사이즈가 어느정도까지 차는지 살펴보기
    3) Overlapeed IO가 작동되는 것이 이득인지 아닌지 결정하기(내 상황을 고려하여 파악해두기)

## 기타 키워드
### 모니터링
1. 네트워크 라이브러리에서 매초에 TPS를 미리 계산하여 모니터 등에 정보를 전달해주어야 한다.
    1) getter와 같은 방식으로 TPS를 전달하는 방식이 되어야 한다.

### 과제
1. IO Pending이 일어나는지, 얼마나 성능 차이가 나는지 무조건!! 분석하기
    1) 성능 차이: 제로 카피와 제로 카피가 아닌 경우를 비교해보기. IO Pending이 걸리는 경우와 그 구간을 측정해야 한다. 단순히 TPS를 측정해서는 안 된다.
    2) 
2. 제로 카피 구현하기. 즉 SendQ에 직렬화 버퍼를 꽂아넣는 형태로 SendPost를 구현하여 테스트하기
3. Stop()
    1) 서버를 안전하게 종료될 수 있게 작업을 하는 기능을 한다.
    2) 예시로 뭐 세션 종료, 스레드 종료 등이 들어갈 수 있을 것 같다..

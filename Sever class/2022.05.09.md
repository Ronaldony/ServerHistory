# 2022/05/09 수업내용
## 스레드 프로그래밍
### 피터슨 알고리즘
1. 비정상적인 동작의 이유 추적
    1) Lock-Unlock 구간 사이에 CriticalSection을 사용하여 TryCriticalSection를 사용
    2) 두 스레드가 서로 다른 변수를 가지고 Lock에 진입하였을 때 
        * 이미 앞서 피터슨 알고리즘의 오작동이 되었기 때문에 
    3) InterlockedExchange를 사용하여 추적
        <pre><code>
        int flagCpy;
        int turnCpy;
        flag[0] = true;
        iTurn = 1;        
        while(1)
        {
            // 사본을 만들어 상태 값을 비교
            flagCpy = flag[1];
            turnCpy = iTurn;
            if((flagCpy != true) && (turnCpy != 1))
                break;
        }        
        // Lock
        if (1 == InterlockedExchange(&x, 1))
            {
                printf("flag: %d / turn: %d\n", flagCpy, turnCpy);
                break;  // 동시에 진입한 경우
            }
        x = 0;
        // Unlock
        </code></pre>
2. 두 가지 이상의 스레드가 있을 때 같이 진입하는 순간을 포착하는 순간
    1) 스레드마다 고유한 값을 특정지어 할당하여 동시에 진입한 스레드를 판단할 수 있다.
        <pre><code>
        // Lock
        if (2 == InterlockedExchange(&x, 1))
            break;  // 2번 스레드가 이미 진입함
        x = 0;
        // Unlock
        </code></pre>
        
### Out of Ordering Execution(OoOE)
1. CPU 내부에서 명령어 처리 순서는 재배치 되지만 CPU로의 진입과 외부로의 결과 출력은 순서적으로 이루어진다.
    1) 내부에서 명령어 처리 순서가 매순간 달라지기 때문에 이미 처리된 명령어는 결과 출력만을 대기하는 상태가 된다. 때문에 결과 출력 순서가 
2. OoOE의 대상
    1) 덧셈, 뺄셈, cmp 같은 경우는 OoOE의 대상이 아니다. 
        * 재료가 준비가 되어있다면 먼저하든 나중에하든 상관이 없기 때문이다. 그 재료를 준비하는 것에 대한 순서 재배치가 어떤 조건에 의해 이루어지는 가를 생각해보아야 한다. -> Load와 Store
    2) Load와 Store에 대한 고민
        * 우리 기준에서는 mov 명령어 중 레지스터->메모리는 Store, 메모리->레지스터는 Load이다.
        * 예를 들어 a = x + y;가 있을 때 x와 y가 Load, Store 되는 시점이 대상이 된다.
        * 연관이 있는 변수, 메모리, 명령어는 순서를 바꾸지 못한다. 예를 들면 (1) x = z; (2) y = x;가 있는 경우 (2)가 (1)보다 앞서 재배치 되지 않는다.
3. Load와 Store의 명령어 재배치 조건
    1) <img width=700 src="https://user-images.githubusercontent.com/95362065/167328780-d22d2ea5-f1db-4501-a1ff-1d862ed82fb8.PNG">
    2) x86은 Load가 Store를 앞지를 수 있는 조건만이 존재한다. (읽기
    * Memory Ordering Wiki
4. 동기화 객체를 사용하면 OoOE에 대한 고민하면서 
    * 실무에서는 이러한 점을 고려하면서 프로그램을 절재 짜지 않는다. 
5. 예시
    <pre><code>
    flag[0] = true;     // store
    turn = 0;           // store
    while((flag[1] == true) || (turn == 1));    // Load, Load    
    </code></pre>

### 메모리 배리어 혹은 메모리 펜스
1. OoOE를 방어하는 동작이다. 
2. 명령어
    1) API 제공
        * inline으로 
        * _mm_mfence: 완전 펜스, 펜스를 기준으로 이전 명령어들의 명령어 재배치를 막고 처리를 완료하여 펜스 이후 명령어를 진행하겠다.
        * _mm_lfence: Load 펜스, 해당 펜스 기준 이전 Load를 모두 처리하는 것을 보장한다. (재배치를 하지 않겠다의 의미가 아니다!!)
        * _mm_sfence: Store 펜스, 해당 펜스 기준 이전 Store를 모두 처리하는 것을 보장한다.
        * 그렇다면 _mm_lfence, _mm_sfence를 같이 사용한다면 _mm_mfence의 효과가 나는 것이냐? => 아니다! _mm_lfence, _mm_sfence
    2) C 런타임 제공
        * __fastStorfence: lock or dword ptr [rsp], 0 => 아무런 의미없는 interlocked 동작이 => 모든 Interlocked 함수는 명령어 재배치를 막는다. _mm_mfence 보다 빠르다.
        * __ReadWriteBarrier: 컴파일러 최적화를 막겠다. 컴파일 단계에서 Out of Ordering을 막는 동작을 한다. __ReadWriteBarrier를 기준으로 컴파일 최적화로 인한 명령어 순서가 바뀌는 것을 막는 역할을 한다.
        * __MemoryBarrier: __fastStoreBarrier로 define 되어 있다. 하드웨어 
    3) C++ 표준(atomic_thread_fence)
        * Acquire: 
        * Release 시멘틱
        * 현재 x86에서는 Acquire와 Release 개념은 존재하지 않는다. 앞으로의 할 일에 대해서 펜스를 치는 행위이다.
3. Interlocked은 Interlocked 이전 명령어들의 명령어 재배치를 막는다. 즉, 메모리 배리어 효과를 낸다.

### 기타
1. Out Of Ordering 이슈 (AMD)
    1) AMD 멜트 다운: 커널 메모리에 전급할 수 있는 상황이 되었다. 
    2) 스펙터: 분기 예측에 의해서 코드를 변경할 수 있는 문제
1. OoOE를 하는 이유
    1) 파이프라인의 효율 극대화를 위하여(병렬 처리)

## 기타 키워드
### 과제
1. 피터슨 알고리즘에 펜스를 쳐서 정상 동작 구현해보기
2. 메모리 오더링에 규칙에 맞춰서 해결되는 상황을 언어 수준에서 수정해보고 테스트 해본다. 이때 그래도 정상적인 동작이 되지 않는지에 대하여 고민해보기

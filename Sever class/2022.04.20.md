# 2022/04/20 수업내용(복습 완료)
## TCP 파이터 서버
### 캐릭터 동작
1. 피격 판정 시점: 클라가 공격 후 서버의 충돌 결과를 기다리는 경우, RTT로 인해 충돌 결과가 늦게 오는 경우 어떻게 이것을 해결할 것인가?
    * 마영전에서는 먼저 클라에서 1차적으로 피격 판정을 확인하여 피격된 것처럼(이펙트, 데미지는 없는 상황) 모션을 취하고 그 이후에 서버에서 충돌에 대한 결과를 보내주면 2차적으로 데미지의 유무, 피격 판정을 결론지어 해결하였다.
    * 예를 들면 영화에서 A가 B를 때리는 시점에 슬로우 모션이 걸린 후 잠시후 한꺼번에 파바박 터지는 연출같은..

### 과제
1. 더미 프로그램 - 모니터링 정보
    1) Error: 클라에서 connect 시 오류 횟수
    2) 프레임: 초당 게임 로직 순환 횟수, 루프: 전체 루프 순환 횟수
    3) Discconect from Server: 서버에서 끊은 경우, 현재 더미 프로그램에서는 나와서는 안된다. (Timeout, HP로 인해 끊긴 것은 카운팅되지 않는다.)
    4) Chracter Count: 캐릭터가 생성된 수, Session Count와 정확히 동일한 개수여야 한다.
    5) Waiting for Timeout: 타임아웃 유저 수와 시간
    6) Loop/sec: 초당 더미의 루프백 횟수, 100 이상은 나와야 한다. 
    7) Packet/sec: 초당 서버로 부터 받은 패킷의 횟수(강사님은 1000명 일 때 평균4800 정도가 나왔다.)
    8) Sync Message Count: 더미가 서버로부터 싱크 메시지를 받은 횟수(하루 몇십 건은 괜찮음). 이 수치가 증가되면 
    9) RTT: 서버로부터 받은 에코패킷 RTT. 초당 횟수 측정 (강사님 수치 - 4 / 21 / 24)
2. 서버 프로그램 - 모니터링 정보
    1) 프레임, 루프 수
    2) 메시지 개수
    3) 세션 수, 캐릭터 수
        * 1초에 한 번씩 모니터링 정보 출력하기
3. 주의 사항
    1) Timeout 기능 추가할 것
    2) 로그를 텍스트로 파일 저장할 떄 디펜더를 꺼야 한다. 가끔씩 디펜더가 랜섬웨어 문제로 해당 파일을 검수하기 때문에 느려진다.
        * 파일을 저장 후 다음 open 시에 굉장히 느리게 열린다.
        * 2019 이전 서버 OS에는 백신 프로그램이 없었다.
    3) 모든 플레이어들은 최대 80초를 플레이어하고 게임을 종료한다.
    4) 더미 프로그램을 종료했을 때 서버와 더미 프로그램 모니터링 정보(예를 들면 유령 세션 수..) 다르다면 문제 파악 정확히 할 것

## 스레드
### 하이퍼 스레딩(=논리 프로세서)
1.  OS 입장에서는 실제 Core 수를 알 수 없다. OS 입장에서는 논리 프로세서를 Core로 본다. => OS는 논리 프로세서를 기준으로 스레드를 스케줄링한다.
    * 즉, 논리 프로세서를 기준으로 스레드를 설계해야 한다.

### 스레드의 사용 목적
1. 향상된 안정성
    1) 책에서 서브시스템이 작동을 멈추는 경우를 대비하여 멀티스레드를 사용한다고 하였는데, 실제 서버에서 일어날 수 있는것인지 생각을 해봐야 한다. 실제로 우리가 걱정해야하는 것은 메모리 참조 오류이다. 
        * HA(고 가용률) 시스템: 사용 가능률이 높은 시스템이다. 가용류 100%란 24시간 어떤 상황에서도 시스템이 동작한다는 뜻임 => Master가 죽으면 Slave로 교체하여 가용성을 높인다. 실제로는 앞단에 Proxy를 두고 Master와 Slave를 Proxy에 연결한다. => 하지만 이 또한 소프트웨어 입장에서는 Slave 또한 입장이 같다고(똑같이 죽을 것) 보기 때문에 있으나마나한 구조이다이라고 본다. 이는 하드웨어 고장에 대비한 구조이다.
   2) 예외 발생을 대비하여 스레드를 분리한다? -> 어차피 예외가 발생하면 stack unwinding이 일어나서 프로세스가 종료된다. 따라서 예외 발생을 목적으로 스레드를 분리하는 것은 말이 안된다.

### CPU 이용률
1. 작업 관리자에 표시된 CPU 이용률은 OS가 측정한 값으로, 스레드들이 1초 동안 CPU를 사용한 시간을 구한 비율이다.
    * 어셈블리 언어 명령어 중 동기화를 맞추기 위하여 CPU에서 Block을 하는 명령어가 있다. 이때 CPU는 연산을 하지 않고(전기를 안 먹음) 있는 상태이지만 OS 입장에서는 이러한 상황을 판단하지 못하고 CPU를 점유하고 있다고 판단한다.

### 스레드
1. 코드의 단위는 스레드이다.

### 스레드 스케줄링
1. 스케줄링 작업 자체도 CPU의 연산이다. 스레드 레디큐에 있는 TCB(Thread Context Block)를 CPU에 전달하여 스레드가 실행되어야하기 때문이다.
2. 스케줄링 할당 단위: 퀀텀 타임, 타임 슬라이스
    1) 정확한 수치를 언급하는 책이나 자료는 없다. 윈도우 시스템 프로그래밍에서는 약 20ms라고 언급한다. (보통 15~20ms이다.)
    2) 서버용 OS가 일반 OS보다 2배 정도 길다. 애초에 일반 OS보다 사용되는 프로세스가 적어 굳이 퀀텀 시간이 작을 필요가 없다. 
    3) 퀀텀 타임을 모두 쓴다는 것은 해당 스레드가 퀀텀 타임동안 하나의 코어를 100% 점유했다는 이야기이다.
        * 보통의 스레드들은 I/O 요청으로 인해 퀀텀 타임을 포기한다.
3. OS 스케줄러는 기본적으로 스레드가 어떤 프로세스에 해당하는지 따지지 않고 스케줄링한다.
    1) 프로세스 선호도: 할 수 있다라면 특정 CPU에 할당해주세요 라고 요청은 할 수 있다. (TCB의 PCB 포인터를 참조하여 수행)
4. 컨텍스트 스위칭
    1) 동일한 프로세스의 문맥을 교환하는 경우, 동일한 가상 메모리 테이블을 바라보기 때문에 다른 프로세스의 스레드를 문맥 교환하는 것보다 조금 더 가볍다.
    2) 서로 다른 프로세스의 문맥을 교환하는 경우, TCB 이외 부가적으로 CR3가 교체되고 이로 인해 가상 메모리 테이블이 교체된다. 
        * 해당 프로세스의 가상 메모리 테이블을 가리키는 CR3 레지스터가 교체된다. => 이로 인해 대부분의 캐시 메모리 초기화가 이루어지고 부하가 생긴다.
        * 즉, 다른 프로세스의 스레드로 스케줄링이 된다는 것은 다른 메모리 시야를 가지게 되는 것이고, 이로 인해 성능 저하가 일어나는 것이다.
        * 더 크게 본다면 , 명령어를 미리 셋팅하여(캐시된 구조들이) CPU 아래에 저장되어 있는데 이러한 명령어들이 모두 갈아치워지는 작업이 이루어져 CPU 입장에서는 결코 가벼운 작업이 아니다. (Out of ordering, ordering 버퍼, 스토어 버퍼, 로드 버퍼...)
5. 레디 큐(준비 스레드)
    1) 논리 프로세서마다 1개씩 준비되어 있다.
    2) 다음 번에 어떤 스레드를 프로세서에 할당 시킬 것인지 준비를 해둔다.
6. TCB와 PCB
    1) TCB: Thread Context Block의 약자로, 스레드의 레지스터 내용, 스택, 우선순위 등의 스레드 정보가 담겨있다. 또한, 자신이 속한 PCB의 포인터를 가지고 있다.
    2) PCB: Process Context Block의 약자로, 주소 공간 정보, 작업 집합 정보, 프로세스 관련 상태 값들을 가지고 있다.
* 강사님의 궁금증: 스케줄링의 정체. 스케줄러 또한 프로그램일텐데... 보통 책에서는 그것에 대한 언급이 되지 않는다.

### CR3와 가상 메모리 테이블
1. CR3: CR3는 Page Directory Entry(PDE)의 주소를 가리키는 Page Frame Number(PFN)의 정보를 가지고 있다.
2. PDE: Page Table Entry(PTE)의 주소 값들을 저장하고 있는 공간이다. Linear Address의 Page Offset를 PDE의 Index로 PTE 주소에 접근한다.
3. PTE: 실제 물리 메모리 페이지 프레임 번호를 저장하고 있는 공간이다. PTE의 Offset으로 Index로 지정한다.
4. CR를 통한 가상 메모리 테이블 접근 과정
    1) CR3 레지스터의 PFN을 참조하여 PDE에 접근
    2) Page Offeset을 기준으로 PDE의 특정 Index에 접근하여 PTE의 주소에 접근
    3) Page Offset을 기준으로 PTE의 특정 Index에 접근하여 실제 물리 메모리 페이지에 접근한다.
5. PDE와 PTE의 Index는 어떻게 찾아가는가?
   1) 구조
   <img width=550 src="https://user-images.githubusercontent.com/95362065/178419871-03ea88c7-25e3-4d8b-8889-4a7427b4bba6.png">


### 기타
1. 요즘 CPU에서는 고성능, 저전력 코어를 구별하여 백그라운드 프로세스들은 저전력 코어로 배정, 포어 그라운드 프로세스들은 고성능 코어에 배정하도록 설계한다. 이 기능을 위하여 OS와 CPU가 통신하게 된다. 이에 따라 CPU가 이에 맞는 OS에게 제공해주어야 한다.
2. 고장
    1) 보통 3년마다 한 번씩 서버를 갈아준다.
3. CPU와 클럭의 관계
    1) 전원 옵션->고급 설정-> 프로세서 전원 관리
    * 최소 프로세서 상태-균형 조정: 이 항목에서 설정 값은 클럭

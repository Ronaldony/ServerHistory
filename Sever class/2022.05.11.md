# 2022/05/11 수업내용
## 스레드 프로그래밍
### 메모리 오더링
1. 피터슨 알고리즘 문제 상황: x86 Memory Ordering 규칙에 맞춰 동기화 문제를 해결하려 시도하였지만 의도대로 되지 않았다 그 이유는?
    <pre><code>
    flag[0] = true;
    turn = 1;               Store turn
    while(1)
    {
        turnCpy = turn;     Load turn => 이 명령이 Store turn을 앞지르지 못한다.
        // ...
    }
    </code></pre>
2. Memory ordering white paper
    1) 2장 Load, Store 재배치 사례 분석하기
    2) 특이 사례1
        * ![memoryOrdering1](https://user-images.githubusercontent.com/95362065/167749895-33b360f1-5a9a-482a-98af-b86976b8822a.PNG)
        * 명령어의 재배치 규칙 위반이 아닌 Store 버퍼의 특성으로 인하여 발생하는 문제이다. 메모리 오더링은 L1 캐시까지 나가는 것이 아니라 Store버퍼에 넣는 과정 까지를 보장한다. 따라서 이 결과를 외부(다른 코어)에 반영하는 것은 또 다른 문제라는 것이다.
        * 위 문제로 인하여 한 프로세서에서 Load를 하기위해 다른 코어의 캐시에서 변수를 읽어올 때 다른 코어는 Store 버퍼까지만 변경된 값을 가지고 있을 수 있어, 과거의 값을 읽어올 수 있는 상황이 된다.
3. Load 버퍼, Store 버퍼
    1) 캐시 버퍼에서 긁어온 Load에 쌓아놓고 연산을 하고, 연산이 완료된 값을 Store 버퍼에 넣어놓고 연산 혹은 메모리에 반영을 하게 된다.
4. 명령어 엔트리 버퍼
    1) CPU는 다수의 명령어 엔트리 버퍼에 쫙 저장해 놓는다. 이 순서를 기억한 상태에서 명령어 재배치 작업을 수행한다.

### 실무와 동기화
1. 동기화 객체는 로직 단위로 사용해야 한다. 자잘자잘한 요소들을 동기화를 하는 짓은 하면 안 된다. (컨텐츠 개념으로서 접근을 해야 한다.)
    1) 잘못된 생각: 리소스 단위로 동기화를 걸게되면 오히려 경합 가능성이 높아져 성능이 저하되고, 동기화 객체가 중첩되어 데드락에 빠질 위험만 생길뿐이다. 
    2) 사례: 던전이 여러개 있을 때 아예 던전 단위로 동기화 객체를 하나씩 둔다. 이후 던전 로직 처리를 할 때 Lock을 걸고 로직 처리가 완료되면 Unlock 동작을 수행한다. 던전이 1개다? 그렇다면 애초에 싱글 스레드로 설계되었어야 한다. 애초에 우리는 병렬 처리가 되는 것을 멀티스레드로 만들기를 바란다. 서로 연관성이 있다면 애초에 하나의 스레드로 처리하는 것이 좋다.

## 동기화
### WaitOnAddress
1. 관련 자료: WaitOnAddress 특허자료
2. 특허자료 언급
    1) 메모리 차원에서 잠구는 것을 언급한다.
    2) Wait 싱크 모듈이 하드웨어 혹은 소프트웨어로 제공될 수 있다. 지금 은 소프트웨어 모듈이다.
    3) WaitOnAddress는 단순히 현재 내가 Block을 걸릴까 말까만 판단한다. 이는 어떤 메모리에 있는 값을 가지고 판단한다. 깨어날 때 Wake 함수를 호출하여 다른 스레드를 깨울 수 있다. => 이벤트 객체와 거의 동일한 기능이라고 보면 된다.
    * <img width=400 src="https://user-images.githubusercontent.com/95362065/167804455-a027107a-0b1d-4b12-8761-d2f7cf9332ae.png">
3. 구조와 동작
    1) 유저 모드에서 스레드 id를 보관한다. 또한 스레드 id를 가지고 누굴 Block을 할 것인지 누굴 깨울 것인지에 대한 작업을 유저 수준에서 이루어진다.
        * 하지만 특허문서에는 이런 부분이 하드웨어 혹은 커널에서 이루어질수도 있다라고 언급을 한다. 현재는 유저 단이지만 나중에는 바뀔지도 모른다는 언급을 한 것이다.
    2) WaitOnAddress로 인해 Block 걸린 친구들은 조건 없이 마냥 Block이 걸린 것이다. 보통 동기화 객체들은 Signaled의 상태를 기다리고 있다.
4. 어셈블리 분석
    1) WaitForAlertByThreadId 내부에 들어가면 wow64로 커널 모드로 전환해 특정 스레드 id를 Block 시킨다.
    2) AlertByThreadId 내부에 들어가면 wow64로 커널 모드로 전환해 특정 스레드 id를 wake 시킨다.
4. 함수
    1) WakeByAddressAll: Block된 스레드를 모두 깨운다.
    2) WakeByAddressSingle: 내부적으로 해시 테이블로 Block된 스레드 id를 관리하고 있는데 그 중 하나를 뽑아 깨울 것이다.
5. 문제점
    1) WaitOnAddress 만으로는 동기화를 구현할 수 없다. 그저 Compare 값과 같은 경우 스레드를 Block 시켜줄 뿐이다. compare 값과 lock 값을 자동적으로 바꿔주지 않는다. 때문에 Interlocked을 사용한 Atomic한 접근 보장을 유저 수준에서 해야 한다.
        <pre><code>
        if(TRUE == Interlocked(&g_Lock, TRUE))          // 1 시점
        {
            // Lock
            WaitOnAddress(&g_Lock, compare, ..);        // 2 시점
            // Unlock
            // 문제 시점A: g_Lock = 0;                    // 3  시점
            WakeByAddressSingle(&g_Lock);               // 4 시점
            // 문제 시점B: g_Lock = 0;                    // 5 시점
        }
        </code></pre>
        * 문제 시점 A
            * 문제 1: C스레드가 Block 인 상태에서 A 스레드가 1 시점을 지나고 B 스레드로 컨텍스트 스위칭이 
        * 문제 시점 B
            * 문제 1: g_Lock = 0까지 완료한 상태에서 다시 뺑뺑이
            * 문제 2: 같이 진입
        * 따라서 결과적으로 3 시점에 g_Lock = 0;을 하여 사용해야 한다. 크리티컬 섹션과 SRWLock 이와 같이 설계되어 있다.
    2) 우리가 WaitOnAddress를 사용하여 이러한 동기화를 구현해야 하느냐
        * 만약 위와 같이 동기화를 사용한다면, 다수의 스레드가 Lock이 걸린 상태에서 먼저 Unlock을 시도한 스레드가 다시 Lock에 걸리게 된다. 다른 스레드가 Block 상태에서 빠져나오기도 전에 Lock 진입을 시도하기 때문이다. 이와 같은 코드는 실무에서는 만들어지지 않는다. 테스트 시 이런 실수를 하게 된다.
        * 결론적으로 SRWLock을 사용해야 한다.

## 기타 키워드
### 코어
1. 현재 12세대 CPU는 고성능, 저전력 코어로 나누어 설계 된다. 윈도우 11부터 적용된다. 중요한 스레드를 고성능, 중요하지 않은 스레드를 저전력 코어에 배치한다 라는 목적으로 설계되었다.

### STD 뮤텍스
1. SRWLock을 Wrapping한 것이다. 또한 Thread id를 사용하여 해당 스레드 id 중첩 진입을 허용한다.

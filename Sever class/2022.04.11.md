# 2022/04/11 수업내용
## 시험 풀이
### 메모리 함수
1. VirtualAlloc, HeapCreate 함수 이리저리 사용해보기

### 소켓 모델
1. AyncSelect
    1) 메인 스레드가 네트워크 통신으로 빠져버려 멀티 스레드 환경에서는 적합하지 않다.
2. Select 모델의 단점
    1) 소켓 셋을 64개밖에 준비하지 못한다.
    2) Polling 방식

### RUDP
1. Unreliable한 부분을 커버해야 한다. 언급 순서는 다음과 같다.
    1) 패킷의 재전송 및 순서 보장
    2) 토큰, 세션에 대한 제어
2. UDP는 송신 버퍼가 없다. 수신 버퍼는 존재하기 때문에 여러 호스트에서 데이터를 보내면 부하가 커져 부담이 된다.
    1) 멀티 스레드 환경에서 사용하려면 포트를 나누어 I/O를 등록하여 부하를 줄일 수 있다.
3. RUDP의 목적
    1) 예전: 홀펀칭의 용도로도 사용된다. (TCP는 애초에 홀펀칭이 불가능하다.)
    2) 최근: 요즘 모바일 환경에서는 IP, Port 가지고 유저를 구분할 수 없다. 유저가 이동하는 사이에 IP와 Port가 계속해서 바뀌기 때문이다. 따라서, TCP의 연결 기준을 버리고 우리가 연결 기준을 만들자 라는데 목적이 있다. (이 기준을 토큰, 세션이라 부름)

### 클라-서버가 연결이 안될 때
1. 크게 백로그가 찼을 때와 3 Handshake 실패로 나눌 수 있다.
    1) 만약 클라와 서버 둘 다 가지고 있다면 우선적으로 클라의 상태를 확인해보아야 한다.
    2) 백로그가 차서 실패: 클라 측 소켓 상태에 대한 아무런 정보도 없다.
    3) 3 Handshake 실패: 클라 측 소켓 상태가 SYN-SENT에서 한동안 머물다가, 사라진다.

## 길찾기
### 경로
1. 이동 불가능 지역
    1) 유동적으로 이동이 불가능한 지역이 생겼을 때를 고민해보아야 한다. LOL의 경우 길이 막혔을 때 막힌 지점에서 계속 비빔
        * 지형 지물로 길찾기를 판단하는 길찾기와 유닛들의 위치를 기준으로 길찾는 것을 2 Layer로 구분한다. 
2. 막힌 경로를 이동하는 방법
    1) 이동 중에 매 타일을 밟을 때 마다 해당 경로가 뚫려있는지 길찾기를 하는 방법. 이렇게하면 
    2) 결정된 경로로 가다가 유닛들이 길을 막혀있다고 판단되면 다른 경로를 찾는 방법
3. 완전 막힌 경로 이동
    1) 지형 지물을 기준으로 경로 이동을 하다가 유닛 간 충돌을 기준으로 길을 찾는 방법
    2) 유닛을 기준으로 경로 이동을 하다가 지형 지물로 경로를 길을 찾는 방법

### 탐색
1. 탐색 범위 제한
    1) 필드를 기준으로 테스트를 통해 OpenList를 방문하는 횟수를 제한하여 무한 루프로 빠지는 위험을 예방
    2) 탐색하는 지역을 제한하여 그 범위안에서만 길찾기를 하는 것
    3) 이 외에도 특정 제한 기준을 만들어 특수한 상황에 대한 대비를 해두어야 한다.
2. 맵의 구간 구간을 나누어 미리 경로 테이블을 만들어 놓고 이동하는 방법
    1) 모든 경로를 저장하여 이동하는 것이 아니라 해당 위치에서 다음 경로로 가는 길만 아는 상태에서 무작정 가보는 것이다.
        * 이때 구간이동 시 이동을 어떻게 자연스럽게 할 것인지 고민해보아야 한다. 예를 들어 다음 구간 이동 시 이동 경로에 장애물이 있을 때 중심점이 아닌 자연스러운 경로로 이동하는 방법을 강구해야 한다.
        * 구간이 사각형이 아니어도 상관 없다. 곡선의 형태여도 구간마다의 이동 구간만 정해지면 된다.
3. 지형 지물 길찾기는 큼직, 유닛 선택은 작은 그리드를 사용하여 
* 리니지는 아예 길찾기를 안 한다. 장애물 충돌 시 비비는 범위를 넓혀가며 뚫린길을 찾아간다.

## STL
### 공부
1. STL의 구현 내부 구조와 사용법
2. 도서: C++ STL 프로그래밍(최흥배, 한빛미디어) - 최신판 이전 판은 무료로 E-Book 다운로드 할 수 있다.
3. STL 종류
    1) list: list
    2) vector: 배열
    3) map: 레드블랙트리(key-value, pair를 사용하여 구현) => 정렬 시 선택
    4) set: 레드블랙트리(key) - Key밖에 없어 해당 정보가 있냐, 없냐만 확인이 가능하다.
    5) multimap: map + 다중키
    6) multiset: set + 다중키
    7) unordered map: 해시 테이블 => 정렬 필요없는 삽입과 탐색, 요즘 선택지는 이거
    * 면접 준비: 시간 복잡도는 무작정 외우고, 각각의 구조에 맞게 사용처나 장단점을 파악해두기!
    * priority_queue, Deck 등..
4. vector
    1) 가변적으로 배열 공간을 사용할 수 있다. 새로운 데이터 push 시 이전에 할당된 배열을 해제하고 
    2) capacity: 메모리의 확보량(size와는 다르다). vector에서는 미리 capacity만큼 할당하여 사용할 수 있지만 이건 고정 배열과 유사하게 돌아가는 것이다. 물론 인덱스에 대한 안정 장치 등이 있지만..
        * 강사님은 성능을 선호하기 때문에 vector를 선호하지 않는다. 하지만 요즘 프로그래머들은 안전과 편리성을 선호한다.
5. STL은 최적화 컴파일을 기준으로 설계되었다. 따라서, 성능 테스트를 한답시고 결과가 느리다고 할 수 없는 것이다.

### 구분자
1. list에서 sort 시 같은 값을 찾을 때 비교하고자 하는 두 수를 
2. map이 노드를 찾는 방법
    1) 비교자 함수(A, B)가 있을 때 마지막으로 비교한 경우가 false인 경우 해당 노드를 저장한 후에 왼쪽으로 이동 후 오른쪽 리프노드로 이동한다. 해당 리프노드와 비교한다 (수정 필요, 제대로 이해 안 됨)

### 플레이어 구분
1. 보통 플레이어 관리를 Account 번호(회원 번호)를 가지고 하지만 ID 등의 정보를 더하여 2중, 3중 정보 구조로 플레이어 관리를 하여도 된다.
    <pre><code>
    unorderedmap<__int64, CPlayer*> PlayerMap;
    unorderedmap<wstring, __int64> NickMap;
    unorderedmap<wstring, __int64> idMap;
    
    * 삽입, 삭제와 검색 빈도를 파악하여 다중 구조를 가져가야 한다.
    * 실제 예시: 로그인 처리 시, 중복 로그인..
    </code></pre>

### 이동 생성자
1. vector의 생성자 생성을 줄이고자 나온 개념이다.
    1) 
3. 포인터를 대상으로하는 객체는 아무런 의미가 없다.

## 기타 키워드
### Modern C++
1. 도서
    1) 전문가를 위한 C++(개정판-검은색)
    2) C++ 2020
2. 현재는 14, 17 정도까지만 적용하여 사용하고 있다.

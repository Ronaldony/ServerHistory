# 2022/03/04 수업내용
## 네트워크 설계
### 링버퍼
1. rear와 front가 만나는 형태로 설계하면 멀티스레드 방식에서 문제가 생길 수 있음.
    * 따라서 rear와 front가 안 만나게 1byte 남기게끔 설계하기

### 메시지 처리
1. 메시지를 수신한 자리에서 처리할 수 있는 메시지와 없는 메시지로 구분할 수 있다.
    * 예를 들면 FPS 게임에서 총을 쏠 때 레이캐스팅하여 바로 충돌처리 할 것인가, 총알을 생성하여 총알이 지나가는 경로에 대해 일일히 충돌처리를 할 것인가.(한조 활)
    * 경로마다 충돌 처리: 3D에서는 키 프레임 중간 중간에 다른 객체와 충돌 여부가 있는지 확인해야 한다.
    * 타겟팅 충돌 처리: 메시지에 대한 데이터(공격 위치, 시간, 공격범위 등)를 저장한 상태에서 충돌하는 순간 
2. 공격에 대한 처리
    1) 충돌처리 시 중간에 끼어드는 객체에 대한 충돌처리를 해야되는 것인지만 결정되면 된다. 매 프레임 처리해야되는 것인지 아닌지 결정해야 하기 때문이다.

### 서버의 설계
1. 기본적인 멀티스레드 설계
    1) IO: 네트워크 IO 등..
    2) 프레임 처리: 메시지 처리, AI, 게임 컨텐츠 등.. 
2. 설계
    1) 기본적인 설계
        <pre><code>
        while(1)
        {
            network
               recv
               send
            logic
                send 용 데이터 생성 // 이렇게 설계된 경우 지금 Logic 처리된 데이터가 다음 프레임에 클라에게 넘어가게 된다.
            Sleep(n)
        }
        </code></pre>
    2) 배그 데디케이티드 설계
        <pre><code>
        while(1)
        {
            network
               recv                  // 클라에게 send할 첫 번째 데이터 생성
               send
            logic
                send 용 데이터 생성   // 클라에게 send할 두 번째 데이터 생성
            network
               send
            Sleep(n)
        }
        // 이러한 방식은 반응성은 좋아지지만 서버의 부담은 커진다.
        </code></pre>
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/156685727-6da153d3-147b-41af-a8de-c254bad9f245.jpg">
3. RPC(Remote Procedure Calls): 내 코드에서 함수를 호출하면 다른 공간(서버 등)에서 함수가 호출되는 개념

## TCP 소켓 프로그래밍
### WSAAsyncSelect 모델(이벤트 방식)
1. 윈도우 메시지로 전달되는 형태의 모델이다. 따라서, 윈도우 창이 있어야 함(WinMain)
2. MS는 WSAAsyncSelect 모델 대신 EventSelect 모델을 사용하라고 권장한다.
3. 이벤트 방식에서의 알림
    1) 소켓의 변화가 있을 때만 사용자에게 알려준다.(select 모델과는 다른 형태)
4. WSAAsyncSelect 함수는 내부적으로 소켓을 논블로킹 모드로 전환한다.
5. 서버에서 사용 시 SOCKET을 사용하여 찾아야 함

### WSAAsyncSelect 모델의 송수신 이벤트
1. FD_WRITE: 최초 연결된 직후, 보낼 수 없는 상태에서 보내는 상황 혹은 그 반대의 상황에서만 이벤트가 발생한다.
    * WriteEvent에서는 성능에 피해가 가더라도 일단 sendQ에 꽂고 sendQ에 있는 것을 send하자!
2. FD_READ: 최초 연결된 직후, FD_READ에 대응해서 recv()를 호출하는 경우에만 이벤트가 발생한다. FD_READ가 발생하였는데 recv()를 호출하지 않으면 다시는 발생하지 않는다.

### 윈도우 메시지
1. WM_USER: 윈도우 메시지의 최댓 값

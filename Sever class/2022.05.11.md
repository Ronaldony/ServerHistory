# 2022/05/11 수업내용
## 스레드 프로그래밍
### 메모리 오더링
1. 피터슨 알고리즘 문제 상황: x86의 Memory Ordering 규칙에 의해서
    * Memory ordering white paper: 이 문제와 관련한 
2. Memory ordering white paper
    1) 2장 Load, Store 재배치 사례 분석하기
    2) 특이 사례1
        * ![memoryOrdering1](https://user-images.githubusercontent.com/95362065/167749895-33b360f1-5a9a-482a-98af-b86976b8822a.PNG)
        * 명령어의 재배치 규칙 위반이 아닌 Store 버퍼의 문제로 인하여 발생하는 문제이다. 프로세서의 L1 캐시까지 나가는 것이 아니라 Store버퍼에 넣는 과정 까지를 보장한다는 것이다. 이 것을 외부(다른 코어)에 반영하는 것은 또 다른 문제라는 것이다.
        * 위 문제로 인하여 다른 프로세서에서는 Load를 하기위해 다른 캐시에서 변수를 가져올 때 다른 캐시에 
3. Load 버퍼, Store 버퍼
    1) 캐시 버퍼에서 긁어온 Load에 쌓아놓고 연산을 하고, 연산이 완료된 값을 Store 버퍼에 넣어놓고 연산 혹은 메모리에 반영을 하게 된다.
4. 명령어 엔트리 버퍼
    1) 처리할 명령어 쌓아둠

### 실무와 동기화
1. 동기화 객체는 로직 단위로 사용하는데 목적이 있다. 자잘자잘한 요소들을 동기화를 하는 짓은 하면 안 된다. (컨텐츠 개념으로서 접근을 해야 한다.)
    1) 잘못된 생각: 리소스 단위로 동기화를 걸게되면 오히려 성능이 저하되고 데드락에 빠질 위험이 있다. 이로 인해 동기화 객체가 중첩이 되고 경합이 많이 발생할 수 있다.
    2) 사례: 던전이 여러개 있을 때 아예 던전 로직 단위로 Lock을 걸어야 한다. 던전이 1개이다? 그렇다면 애초에 싱글 스레드로 설계되었어야 한다.

## 동기화
### WaitOnAddress
1. 관련 자료: WaitOnAddress 특허자료
    * Linux는 IOCP 방법이 없다.
2. 특허자료 언급
    1) 메모리 차원에서 잠구는 것을 언급한다.
    2) Wait 싱크 모듈이 하드웨어 혹은 소프트웨어로 제공될 수 있다. 지금 은 소프트웨어 모듈이다.
    3) 기능: 현재 내가 Block을 걸릴까 말까만 판단한다. 이는 어떤 메모리에 있는 값을 가지고 판단한다.(원하는) 깨어날 때 다른 스레드를 Wake 함수를 사용하여 스레드 id를 가지고 깨워준다.
3. 구조와 동작
    1) 특정 메모리에 값을 저장한다. 그 메모리의 주소를 WaitOnAddress에 등록한다.
    2) 스레드 id를 저장하고 있는 곳이 유저 단이다. 또한 스레드를 구분하여 Block을 할 것인지 누굴 깨울 것인지에 대한 작업을 유저 수준에서 이루어진다.
    3) WaitOnAddress로 인해 Block 걸린 친구들은 마냥 Block이 걸린 것이다.
    4) WaitForAlertByThreadId 내부에 들어가 wow64로 커널 모드로 들어가 특정 스레드 id를 Block 시킨다.
    4) AlertByThreadId 내부에 들어가 wow64로 커널 모드로 들어가 특정 스레드 id를 wake 시킨다.
4. 함수
    1) WakeByAddressAll: Block된 스레드를 모두 깨운다.
    2) WakeByAddressSingle: 해시 테이블로 Block된 스레드 id를 관리한다. 그 중 하나를 뽑아 깨울 것이다.
    3) WaitOnAddress
        <pre><code>
        
        </code></pre>
5. 문제점
    1) WaitOnAddress 만으로는 동기화를 할 수 없다. 그저 Compare 값과 같은 경우 스레드를 Block 시켜줄 뿐이다. compare 값과 lock 값을 자동적으로 바꿔주지 않기 때문이다. 그래서 Interlocked을 사용한 Atomic한 접근 보장은 따로 해주어야 한다.
        <pre><code>
        if(TRUE == Interlocked(&g_Lock, TRUE))          // 1 시점
        {
            // Lock
            WaitOnAddress(&g_Lock, compare, ..);        // 2 시점
            // Unlock
            // 문제A: g_Lock = 0;                        // 3  시점
            WakeByAddressSingle(&g_Lock);               // 4 시점
            // 문제B: g_Lock = 0;                         // 5 시점
        }
        </code></pre>
        * 문제 A
            * 1: C스레드가 Block 인 상태에서 A 스레드가 1 시점을 지나고 B 스레드로 컨텍스트 스위칭이 
        * 문제 B
            * 문제 1: g_Lock = 0까지 완료한 상태에서 다시 뺑뺑이
            * 문제 2: 같이 진입
        * 따라서 3 시점에 g_Lock = 0;을 하여 사용해야 한다.
    2) 우리가 WaitOnAddress를 사용하여 이러한 동기화를 구현해야 하느냐
        * 만약 위와 같이 동기화를 사용한다면, 다수의 스레드가 Lock이 걸린 상태에서 먼저 Unlock을 시도한 스레드가 다시 Lock에 걸리게 된다. 다른 스레드가 Block 상태에서 빠져나오기도 전에 Lock 진입을 시도하기 때문이다. 이와 같은 코드는 실무에서는 만들어지지 않는다. 테스트 시 이런 실수를 하게 된다.
        * 결론적으로 SRWLock을 사용해야 한다.

## 기타 키워드
### 코어
1. 현재 CPU는 고성능, 저전력 코어로 나누어 설계 된다. 윈도우 11에서는 제공된다.

### STD 뮤텍스
1. SRWLock을 Wrapping한 것이다. 또한 Thread id를 사용하여 해당 스레드 id 중첩 진입을 허용한다.

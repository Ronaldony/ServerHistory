# 2022/06/10 수업내용(복습 완료)
# 멀티스레드
## 네트워크 라이브러리
### 디버깅
1. 문제가 되는 상황에서 문제가 해결되기 전 까지는 로직 변경은 절대 해서는 안 된다. 추적을 위한 디버깅 코드를 추가하여 디버깅을 해야 한다.(그러나 디버깅 코드로 인해 문제가 감춰질 수 있음)
    1) 문제에 대한 가설을 세우고 가설이 맞는지 확인할 수 있는 디버깅 코드를 추가
2. 세션 Release에 대한 문제
    1) 단순히 Release 함수 호출 횟수에 대한 카운팅을 하여 해결해본다? => 비교군을 찾아야 한다. Accept 횟수(세션이 생성된 횟수)와 비교해 볼 수 있다.
    2) Release가 왜 되지 않았느냐를 찾아야 한다. => 해당 세션에 대한 동작을 추적해야 한다. 이 세션이 이전에 어떤 스레드에서, 어느 함수를 거쳐, 어떤 동작을 했고, 이런 결과가 나왔는지를 메모리 로깅을 통해 추적해야 한다.
    3) 메모리 누수: NP풀이 증가한다면 세션 안에 소켓에 대한 문제로 볼 수 있다. 더 나가면 socket에 대한 IO 요청으로 인한 증가와 IOCP 완료 통지 쌓임으로 인해 증가한 것인지를 생각해 볼 수 있다.
3. NP풀 증가 요소
    1) SOCKET
    2) IO 요청
    3) IOCP 완료 통지
4. 소켓이 closesocket이 안 되었다면 작업관리자에서 프로세스 핸들 갯수를 확인하여 처리에 대한 결과를 추적할 수 있다.(소켓 할당 시 프로세스 핸들로 갯수가 잡힌다.)

### 스레드
1. 현재 에코 서버에서 세션에 접근할 수 있는 최대 스레드 개수
    1) 이유: 송수신 완료 통지에서 WSARecv 혹은 WSASend 호출 시에 그 즉시 송수신 완료 통지로 인해 다른 스레드가 깨어나 세션에 접근할 수 있다.
    2) 현재 에코 서버에서 문제가 안 생기는 이유: IO를 건 다음에 딱히 세션에 대한 추가적인 작업이 없기 때문이다.
        * 만약 추가적인 작업이 들어간다면 1)에 상황과 맞물려 여러 스레드가 한 세션에 접근하여 문제가 발생할 것이다.

### 동기화
1. 현재 에코 서버에서는 각 세션마다 (유저)동기화 객체를 두고 있는 상태이다. 그러나 이렇게 세션마다 동기화 객체가 필요할까?
    1) 판단의 기준: 경합이 발생할 수 있는지 생각해 보아야 한다. 
        * 결론적으로 세션마다 동기화 객체를 거는 것이 효과적이다. 세션마다 동기화 객체를 두게되면 워커 스레드들이 같은 세션에 대한 Lock을 걸 확률이 거~의 없어진다. 
        * 세션마다 동기화를 두지 않는다 하여도 다른 대안이 필요할 수 밖에 없다. 이러한 상황에서도 대안에 대한 어떠한 동작이 똑같이 들어가게 되면 그에 대한 오버헤드가 발생하게 되어있다. (다른 대안은 Interlocked 밖에 없을 것이다.)
2. Lock 시점에 대한 고민
    1) 이제부터 우리는 이제부터 세션을 사용할 때 무조건 Lock을 걸 것이다.(Accept에서든 완료 통지에서든 등..) 이에 따라 완료 통지 내부에서는 최상단에서 세션에 접근하기 전에 Lock을 걸고 최하단에서 Unlock을 한다.
        * 이렇게 된다면 완료 통지 내부에서 호출되는 SendPost(SendMessage로 인한)와 RecvPost에 대한 Lock은 어떻게 되는지 고민해야하는 사항이다.
    2) 내부에서 세션에 접근하는 함수 시점의 Lock: 내부에서 세션에 대한 Lock을 고려할 때 함수 외부에서 Lock을 걸고 들어오는 경우와 Lock을 걸지않고 들어오는 경우를 생각해보아야 한다. 그렇다라면 SRWLOCK 보다는 CS를 선택하는 편이 나은 방법일 수 있다.
        * 함수 내부에서 세션 Lock을 고려하는 것과 고려하지 않는 2가지 버전을 준비할 수도 있다. 혹은 플래그를 통해 세션 Lock의 여부를 결정할 수도 있다.
        * 이에 해당하는 함수는 RecvPost, SendPost에 해당하며 이 함수들은 네트워크 라이브러리 내부에서만 호출되는 함수이다. 따라서 추후 private 접근 지정자로 될 것이다.
        * SendPost를 호출하는 SendMessage는 완료 통지 내부 그리고 완료 통지가 아닌 외부에 의해 호출될 수 있다. 이에 따라 SRWLOCK을 사용하게 되면 완료 통지 내부에서 재귀적 Lock의 문제가 발생할 수 있다.
3. 현재 세션의 SendFlag, IO count 와 동기화 객체는 서로 다른 목적을 가진다.
    1) SendFlag, IO count: 어떠한 작업의 횟수를 제한시키기 위한 기능을 한다.
    2) 동기화 객체: 어떠한 순간에 동시 접근하는 것을 막는 것이다.

### SendMessage, SendPost와 RecvPost
1. 함수 인자
    1) 현재는 세션에 대한 정보로 포인터를 받고 있지만 세션 ID로 바꿀 것이다.
        * 네트워크 라이브러리를 설계 시 외부에 제공되어야 할 정보는 장단점을 잘 따져보아야 한다. 세션 포인터를 인자로 하였을 때 장단점은 아래와 같다.
    2) 세션 ID로 전환했을 때의 장점
        * 장점1: 세션 정보의 메모리를 외부로 노출시키지 않으므로서 외부에서 세션의 정보를 변경할 수 없다. 외부에는 세션ID만 제공된다.
        * 장점2: 만약 세션 포인터를 인자로 둔다면 라이브러리 내부에서 세션에 대한 정보를 삭제하였을 때 외부에서 해당 세션에 대한 메모리 참조 오류가 발생할 수 있다. 그러나 세션 ID로 전환하게 되면 이러한 문제는 발생하지 않을 것이다. => 라이브러리 사용자는 세션에 대한 할당과 해제 권한이 없다. 따라서 해당 세션이 유효한 지 무효한 지 알 방법이 없다.
    3) 세션 ID로 전환했을 때의 단점
        * 단점1: 라이브러리 내부에서 세션 메모리를 찾아야 한다.(내부에서 find 과정이 
3. SendMessage
    1) Send는 수신 완료 통지 혹은 외부에서 언제든지 부를 수 있는 상황이 만들어진다. 우리는 어디에서든 호출하여도 정상적인 동작을 보장하는 라이브러리로 만드는 것이다.
        * 위와 같은 상황으로 인해 SendPacket 함수 '내부'에 Lock이 들어가는 형태가 되어야 한다.
    2) SendMessage 내부
        <pre><code>
        SendPacket(세션ID, 메시지)
        {
            세션Map.lock();
            세션Map.find();       // 여기서 찾기 못하면 바로 함수 실패 리턴
            // 세션Map.unlock();  // 후보지1
            
            세션.Lock();
            세션Map.unlock();
            세션->EnQueue();
            세션->SendPost();
            세션.Unlock();
            // 세션Map.unlock();     // 후보지2
        }
        </code></pre>
        * 이 구조는 다른 함수들에서의 Lock 동작이 고려되어 만들어진 구조이다.
    3) 세션Map Lock의 목적
        * 목적1: 세션Map에서 세션 삭제가 되었을 때 해당 세션에 대한 이터레이터를 이미 할당한 스레드에서 해당 노드 접근 시 오류가 발생한다.(세션 접근 오작동)
        * 목적2: 세션Map에 2개의 스레드 이상에서 세션 삽입, 삭제, 검색될 때 컨테이너 자체의 오작동이 발생할 수 있다. (컨테이너 오작동)
        * 우리는 동기화를 걸 때 동기화를 거는 이유가 명확해야 한다. 문제가 없다면 동기화를 걸어서는 안 된다.
    4) 세션 Map Unlock
        * 후보지1의 문제: Unlock을 하는 순간 다른 스레드에서 같은 세션 ID에 대하여 삭제가 이루어질 수 있다.
        * 후보지2의 문제: 문제가 발생할 수 있는 요소는 없다. 그러나 세션에 대한 동작도 같이 물리기 때문에 굉장한 성능 저하가 발생할 것이다.
2. Disconnection - 세션 삭제
    1) 구조
        <pre><code>
        세션 삭제(...)
        {
            세션Map.Lock();
            세션 검색
            세션 Map에서 세션 삭제
            // 세션Map.Unlock(); // 세션 Map Unlock 후보지1
            세션.Lock();
            // 세션Map.Unlock(); // 세션 Map Unlock 후보지2
            세션.Unlock();
            세션 삭제
            // 세션.Unlock(); // 세션 Unlock 후보지 1
            세션Map.Unlock();
        }
        * 이 구조는 다른 함수들에서의 Lock 동작이 고려되어 만들어진 구조이다.
        </code></pre>
    2) 이렇게 복잡한 구조를 가지는 이유는 결국 해당 세션의 동기화 객체가 삭제된 후 사용되는 것을 막기위한 구조이다. 삭제된 후 사용되면 다음과 같은 상황이 발생할 수 있다.(뇌피셜)
        * 상황1: 의도했던 동작(Lock 혹은 Unlock)이 이루어지지 않는다.
        * 상황2: 우리는 세션을 동적 할당할 것이다. 세션이 삭제된 후(동기화 객체도 같이 삭제됨) 접근했을 때 메모리 참조 오류 위험이 있다.
    3) 세션 Map Unlock 후보지
        * 후보지1의 문제점: 해당 세션을 다른 스레드에서 삭제하게되면 세션.Lock을 하는 시점에서 세션에 대한 메모리 참조가 발생할 수 있고, 또다른 문제는 세션.Lock을 호출한 후 Block 상태에서 동기화가 삭제되면 데드락에 빠지는 문제가 발생한다.
        * 후보지2의 문제점: 예를 들어 위에서 설명된 SendMessage 함수를 다른 스레드에서 진입하였을 때, 세션.Lock까지 진입하게 된다. 이때 Disconnection 스레드에서 세션.Unlock 이후 세션 삭제를 하고 나서 SendMessage 스레드에서 세션->EnQueue 혹은 세션->SendPost 명령을 실행하게 되면 오작동 혹은 메모리 참조 오류가 발생하게 된다.
    4) 세션 Unlock 후보지
        * 후보지1의 문제점: 
    5) 이 구조의 문제점
        * 항상 세션에 대한 모든 동작을 할 때 세션Map과 세션에 대한 동기화가 세트로 이루어져야 한다.(뇌피셜) 
        * 만약 완료 통지 워커 스레드에서 GQCS로부터 획득한 세션 Key(세션 포인터)를 가지고 워커 스레드 위에서 세션.Lock을 걸게 된다면 데드락에 걸릴 위험이 있기 때문에 여기서 조차 세션 Map 검색을 통해 세션에 접근해야 한다.
        * 이러한 문제점들은 세션이 동적으로 할당되고 삭제되기 때문에 발생하는 문제이다.(= 동기화 객체가 삭제됨)

### 기타
1. 위에서 언급되었던 동기화 객체 삭제로 인한 문제점을 해결할 방법을 강구해볼 것!!!
    * 세션마다 Lock은 걸겠지만 위에서 기술된 구질구질한 동기화 방법을 쓰지 않기 위한 해결방안을 생각해볼 것

## 기타 키워드
### 에코 서버

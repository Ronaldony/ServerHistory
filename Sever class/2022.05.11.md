# 2022/05/11 수업내용(복습 완료)
## 스레드 프로그래밍
### 메모리 오더링
1. 피터슨 알고리즘 문제 상황: x86 Memory Ordering 규칙에 맞춰 동기화 문제를 해결하려 시도하였지만 의도대로 되지 않았다 그 이유는?
    <pre><code>
    flag[0] = true;
    turn = 1;               Store turn
    while(1)
    {
        turnCpy = turn;     Load turn => 이 명령이 Store turn을 앞지르지 못한다.
        // ...
    }
    </code></pre>
2. Memory ordering white paper
    1) 2장 Load, Store 재배치 사례 분석하기
    2) 특이 사례1
        * ![memoryOrdering1](https://user-images.githubusercontent.com/95362065/167749895-33b360f1-5a9a-482a-98af-b86976b8822a.PNG)
        * 명령어의 재배치 규칙 위반이 아닌 Store 버퍼의 특성으로 인하여 발생하는 문제이다. 메모리 오더링은 L1 캐시까지 나가는 것이 아니라 Store버퍼에 넣는 과정 까지를 보장한다. 따라서 이 결과를 외부(다른 코어)에 반영하는 것은 또 다른 문제라는 것이다.
        * 위 문제로 인하여 한 프로세서에서 Load를 하기위해 다른 코어의 캐시에서 변수를 읽어올 때 다른 코어는 Store 버퍼까지만 변경된 값을 가지고 있을 수 있어, 과거의 값을 읽어올 수 있는 상황이 된다.
3. Load 버퍼, Store 버퍼
    1) 캐시 버퍼에서 긁어온 Load에 쌓아놓고 연산을 하고, 연산이 완료된 값을 Store 버퍼에 넣어놓고 연산 혹은 메모리에 반영을 하게 된다.
4. 명령어 엔트리 버퍼
    1) CPU는 다수의 명령어 엔트리 버퍼에 쫙 저장해 놓는다. 이 순서를 기억한 상태에서 명령어 재배치 작업을 수행한다.

### 실무와 동기화
1. 동기화 객체는 로직 단위로 사용해야 한다. 자잘자잘한 요소들을 동기화를 하는 짓은 하면 안 된다. (컨텐츠 개념으로서 접근을 해야 한다.)
    1) 잘못된 생각: 리소스 단위로 동기화를 걸게되면 오히려 경합 가능성이 높아져 성능이 저하되고, 동기화 객체가 중첩되어 데드락에 빠질 위험만 생길뿐이다. 
    2) 사례: 던전이 여러개 있을 때 아예 던전 단위로 동기화 객체를 하나씩 둔다. 이후 던전 로직 처리를 할 때 Lock을 걸고 로직 처리가 완료되면 Unlock 동작을 수행한다. 던전이 1개다? 그렇다면 애초에 싱글 스레드로 설계되었어야 한다. 애초에 우리는 병렬 처리가 되는 것을 멀티스레드로 만들기를 바란다. 서로 연관성이 있다면 애초에 하나의 스레드로 처리하는 것이 좋다.

## 동기화
### WaitOnAddress
1. 관련 자료: WaitOnAddress 특허자료
2. 특허자료 언급
    1) 메모리 차원에서 잠구는 것을 언급한다.
    2) Wait 싱크 모듈이 하드웨어 혹은 소프트웨어로 제공될 수 있다. 지금 은 소프트웨어 모듈이다.
    3) WaitOnAddress는 단순히 현재 내가 Block을 걸릴까 말까만 판단한다. 이는 어떤 메모리에 있는 값을 가지고 판단한다. 깨어날 때 Wake 함수를 호출하여 다른 스레드를 깨울 수 있다. => 이벤트 객체와 거의 동일한 기능이라고 보면 된다.
    * <img width=400 src="https://user-images.githubusercontent.com/95362065/167804455-a027107a-0b1d-4b12-8761-d2f7cf9332ae.png">
3. 구조와 동작
    1) 유저 모드에서 스레드 id를 보관한다. 또한 스레드 id를 가지고 누굴 Block을 할 것인지 누굴 깨울 것인지에 대한 작업을 유저 수준에서 이루어진다.
        * 하지만 특허문서에는 이런 부분이 하드웨어 혹은 커널에서 이루어질수도 있다라고 언급을 한다. 현재는 유저 단이지만 나중에는 바뀔지도 모른다는 언급을 한 것이다.
    2) WaitOnAddress로 인해 Block 걸린 친구들은 조건 없이 마냥 Block이 걸린 것이다. 보통 동기화 객체들은 Signaled의 상태를 기다리고 있다.
4. 어셈블리 분석
    1) WaitForAlertByThreadId 내부에 들어가면 wow64로 커널 모드로 전환해 특정 스레드 id를 Block 시킨다.
    2) AlertByThreadId 내부에 들어가면 wow64로 커널 모드로 전환해 특정 스레드 id를 wake 시킨다.
4. 함수
    1) WakeByAddressAll: Block된 스레드를 모두 깨운다.
    2) WakeByAddressSingle: 내부적으로 해시 테이블로 Block된 스레드 id를 관리하고 있는데 그 중 하나를 뽑아 깨울 것이다.
5. 문제점
    1) WaitOnAddress 만으로는 동기화를 구현할 수 없다. 그저 Compare 값과 Lock 값이 같은 경우 스레드를 Block 시켜줄 뿐이다. compare 값과 lock 값에 대한 변경은 자동적으로 이루어지지 않는다. 때문에 Interlocked을 사용한 Atomic한 접근 보장을 유저 수준에서 해야 한다.
        <pre><code>
        // 진입 시도
        while (1 == InterlockedExchange(&g_Lock, 1))    // 시점 1
        {
            WaitOnAddress(&g_Lock, &compare, sizeof(g_Lock), INFINITE); // 시점 2
        }

        g_Data++;

        // Unlock
        // g_Lock = 0;                  // 시점 3
        WakeByAddressSingle(&g_Lock);   // 시점 4
        // g_Lock = 0;                  // 시점 5
        </code></pre>
        * 시점 3의 상황
            * 상황: 만약 A 스레드에서 시점 3가 실행되는 순간 다른 스레드가 시점 1에 진입하여 동시에 임계 영역으로 들어 오게 된다. 이후 A 스레드가 시점 4을 실행하여 다른 스레드를 깨우는 상태가 된다. 깨워진 스레드는 다시 시점1을 지나 시점 2에서 Block 상태가 될 것이다.
        * 시점 5의 상황
            * 상황 1(문제 상황): A 스레드가 시점 4에서 스레드를 깨운 뒤 "시점 5가 실행되기 전에" 컨텍스트 스위칭이 일어나고, A 스레드로 인해 깨워진 스레드가 시점 1을 실행한다면 시점 2을 실행하고 다시 Block 상태에 들어갈 것이다. 이것은 결함이다. 다른 스레드가 임계 영역에 진입하여 Lock을 바꿔주지 않는 이상 데드락에 걸리는 것이다.
        * 따라서 결과적으로 시점 3에서 g_Lock = 0;을 해야 한다. => 크리티컬 섹션과 SRWLock 이와 같이 설계되어 있다.
    2) 우리가 위와 같은 방식으로 WaitOnAddress를 사용하여 동기화를 구현해야 하느냐?
        * 결론적으로는 SRWLock을 사용해야 한다. Lock이 걸리는 상황에서 Lock이 걸리는 것에 대한 부담은 논하지 않아야 한다. 우리가 보아야하는 것은 Lock이 걸리지 않아야 하는 상황에서 얼마나 빠르게 판단하고 튀어나오냐를 고민해보아야 한다. 크리티컬 섹션은 재귀적인 Lock을 허용하기 위해 스레드 ID를 저장하고 확인하는 작업이 들어간다.
    3) 실제로 우리가 위와 같은 문제점들을 살펴본 이유
        * 아래의 동일한 코드의 스레드들이 WaitOnAddress로 동기화가 이루어지는 상황에서, 임의의 스레드가 Unlock을 하면 그 다음으로 Lock에 진입하는 스레드가 누구냐? -> Unlock을 했던 동일한 스레드가 다시 진입하게 된다. 이유는 다른 스레드가 Block 상태에서 빠져나오기도 전에 더 빠르게 Lock 진입을 시도하기 때문이다. 실무에서는 아래와 같은 코드가 없겠지만 테스트 시 이런 실수를 하게 된다.
        * 이것이 커널 동기화 객체와 유저 동기화 객체의 가장 큰 차이점이다. 커널 동기화 객체를 사용하여 Unlock을 하게 되면 그 순간 커널이 Lock 진입 스레드를 정하게 되지만 유저 단에서는 WaitOnAddress 이전에 Interlcoked에 먼저 진입한 놈이 들어가게 된다.
        <pre><code>
        // 스레드
        while(1)
        {
            Lock
            // 임계 영역 동작
            Unlock
        }
        </code></pre>

## 기타 키워드
### 코어
1. 현재 12세대 CPU는 고성능, 저전력 코어로 나누어 설계 된다. 윈도우 11부터 적용된다. 중요한 스레드를 고성능, 중요하지 않은 스레드를 저전력 코어에 배치한다 라는 목적으로 설계되었다.

### STD 뮤텍스
1. SRWLock을 Wrapping한 것이다. 또한 Thread id를 사용하여 해당 스레드 id 중첩 진입을 허용한다.

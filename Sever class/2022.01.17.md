# 2022.01.17 수업
## 윈도우 GDI
### 마우스 십자 그리기 및 더블 버퍼링
1. 키 입력에 대한 처리는 DirectX에서 제공하는 Direct Input으로 처리해야한다.
    * 윈도우 메시지는 외부에서도 전송될 수 있기 때문이다.(매크로 프로그램 등)
    * Direct Input 기능은 키보드 버퍼에서 가져오는 느낌

### DC
1. GDI 개체: DC 공간에 들어가는 GDI 객체 속성, 1개 씩만 연결된다. Pen, Brush, Font, Bitmap 등의 개체가 있다.
    * 최대 9,999개 까지 생성된다.
    * 개체는 커널 영역에 저장이 되어 프로세스의 메모리 공간이 증가하지 않는다.
2. SOEN에서는 렌더링이 끝난 후 DC를 Delete하는데 권장하는 방법은 아님
3. 사용하지 않는 DC를 물고있으면 있을수록 성능에 영향이 있다.
4. 두개의 패턴을 DC에 그리는 방법
      1) 마우스의 모든 좌표를 저장하여 렌더링(제한 개수 지정)
      2) 비트맵 DC를 다수개로 나누어 저장

### BitBlt, PatBlt
1. PatBlt: 지정 색으로 DC 밀어버리기
2. BitBlt: 메모리에 있는 DC를 클라이언트 DC에 복사하기(화면에 출력하기)
    * 마지막 인자 DWORD rop은 그리기 속성 지정

### 그외 함수
1. SetPixel: 화면에 점 찍기
2. GetSysColorBrush: 시스템에 생성된 컬러 브러쉬 개체 얻어오기
    * 이미 존재하는 브러시 개체를 얻어오는 함수(생성 X)

## switch-case문
### 변수 선언
1. switch-case문에서 변수를 선언하려면 블록을 지정하여 선언해야 한다.
    <pre><code>
    switch()
    {               << 컴파일러가 인식하는 int a의 생존 범위 시작 시점
        case 1:
            int a;  // 컴파일 에러, int a의 생존범위가 해당 case 문에서 사용하지 못하는 것으로 인식
        break;
        case 2:
        {
            int b;  // 컴파일 OK
        }
        break;
    }
    </code></pre>

## BMP 파일
### Pitch (뭔지 헷갈림 다시 공부할 것!!!!)
1. 비트 색상의 한 줄의 단위, 기본적으로 4byte로 한다.
    * 메모리 계산으로 인한 4byte 경계를 기본으로 한다. ColorByte가 늘어나면 4단위로
    * Width w, ColorByte c = W 일 때 Pitch 경계 => (W + 3) & (~3)

## 게임
### Winmain 구조
1. PeekMessage() 함수를 활용하여 메시지 처리가 우선되어야 한다. 
    * 이에 따른 게임 처리는 메시지 처리가 된 후에 이루어진다. 메시지 처리가 먼저 되어도 게임 처리에는 큰 영향이 없다. 메시지 처리는 부하가 크지 않기 때문이다.

### 2D와 3D
1. 스프라이트: 게임 화면 출력 이미지가(캐릭터, 배경 등) 한 장, 한 장 존재하여 는 이미지 파일
2. 2D와 3D 차이
    1) 2D: 스프라이트를 연달아 출력하여 애니메이션 구현
    2) 3D: 행동 중간 중간 키 프레임을 좌표로 설정하여 해당 위치에서 직접 계산하여 그린다. 시간의 흐름대로 키 프레임 계산을 수행한다.
    3) 3D는 프레임이 떨어져도 그때마다 계산하여 큰 상관은 없다. 하지만 2D는 프레임이 항상 일정해야 한다.
    4) 2D는 최대 프레임이 제한되어야 하지만(스프라이트 때문), 3D에서는 상관이 없다.
        * 3D는 
3. Frame Skip: 2D에서 목표 FPS가 있을 때 느린 컴퓨터가 동작할 때 렌더링을 포기하고 로직을 50FPS로 맞추는 것
4. Fixed Update: 3D에서는 충돌처리 등의 로직이 정상적으로 이루어지는 것을 위하여 최하 프레임이 보장하는 것
5. Frame Skip와 Fixed Update의 차이점
    1) Frame Skip: 언제 렌더링을 버려야하는 시점을 찾는 방법
    2) Fixed Update: 로직이 목표 FPS 이하가 되는 순간 로직을 더 밀어넣어 프레임을 맞추는 것 (로직을 추가하는 느낌)
        * 유니티에서는 이 방법을 채택하고 있다.

### 시간 기준 처리
1. 프레임 기준 게임 처리는 예전 방식이고 최근에는 시간 기준으로 로직을 처리한다.

* 베어메탈: 조사 필요

# 2022/06/20 수업내용
# 네트워크 라이브러리
## 모니터링
1. 네트워크 라이브러리에서 애초에 TPS, 누적 정보 등을 미리 계산하여 저장해두고 있어야 한다.
    1) 즉 특정 시간 단위로 계산하는 경우에도 모두 네트워크 라이브러리 내부에서 계산을 하고 있어야 한다는 이야기이다.
    2) getter와 같은 방식으로 수치를 전달하는 방식이 되어야 한다.
2. 계산된 수치들을 네트워크로 쏠지, 파일, 콘솔에 출력할 지는 사용자인 서버가 결정해야 할 일이다.

## 제로 카피
### 소켓 버퍼
1. 일반적인 상황에서 소켓 송수신 버퍼는 0이 되지 않는다. 0이 되었다가 다시 늘어나 버린다. 0으로 만들면 window size가 0으로 갔다가 늘어난다.
    1) 수신 버퍼는 0으로 만들 이유가 없다. 왜? 우리 조건에서는 애초에 Recv를 걸면 대부분 IO Pending이 되기 때문이다.
    2) 우리의 상황(OVERLAPPED IO를 사용)에서는 이제 송신 버퍼가 0이 된다. 항상 유지가 되며 항시 IO Pending이 일어날 것이다.
2. 분석
    1) 제로 카피가 아닐 때(송신 버퍼가 0이 아닐 때) IO Pending가 얼마나 발생하는지, 또 송수신 소켓 버퍼 사이즈가 어느정도까지 차는지 살펴보기
    2) 제로 카피가 아닐 때와 제로 카피를 할 때(송신 버퍼가 0인 경우) 성능이 어느정도 차이가 나는지 분석하기.
        * 성능 비교는 그 구간을 측정해야 한다.
    3) 결론적으로는 Overlapped IO가 이득인지 아닌지를 결정해야 한다.(내 상황을 고려하여 파악해두기)

### 제로 카피
1. 제로카피란? 결국엔 Overlapped IO가 작동되는 상황과 같은 상황이다. (=IO Pending이 발생한다.)
    1) 다른 언어 쪽에서는 우리와 같이 상세한 개념이 아니라 "중간 송수신 버퍼를 없앤다. 다이렉트로 우리쪽으로 복사가 된다." 까지를 말한다.
2. 제로 카피 유도 방법
    1) 중간 버퍼를 없앤다.
3. 우리의 상황
    1) 상황: 현재 직렬화버퍼(App) -> SendQ -> TCP 송신 버퍼를 통해 전송이 이루어진다.
    2) 첫 번째 구조 개선 - TCP 송신 버퍼를 없앨 수 있을까? SendQ 버퍼를 다이렉트로 TCP 스택에 꽂아버리는 것이다.
    3) 두 번째 구조 개선 - SendQ를 없앨 수 있을까? 직렬화 버퍼를 SendQ에 복사하지 않고 TCP 스택에 꽂아버리는 방법을 생각할 수 있다.
        * SendQ를 완전히 없앨 수는 없다. 그 이유는? 아래의 SendQ의 목적 목차를 잘 살펴보자!
4. 직렬화 버퍼
    1) 위치: 동적 할당하여 힙에 저장해 놓는 방법이 있다. 지금은 new, delete를 사용하여 구현할 것이다.
    2) 사용 대상: 예를 들어 채팅 서버라면 하나의 유저가 입력한 메시지가 모두에게 전달될 것이다. 이때 직렬화 버퍼는 모든 유저의 링버퍼에 등록이 되어야 한다. 따라서 참조 카운트를 사용하여 제거 시점(할당 해제)을 결정할 것이다.
    3) 등록: 이제는 SendQ에 버퍼 데이터를 복사하는 것이 아닌 직렬화 버퍼의 주소를 등록할 것이다.
    4) 제거 시점: 제거 시점이 애매하다. 방법으로는 송신 완료 통지 처리 시 참조 카운트가 0일 때 삭제하는 것이다.
        * 문제점: SendQ에 몇개의 직렬화 버퍼 포인터를 등록했는지 알 수 없다.
        * 해결: Send 시 해당 세션 정보에 몇개를 등록했는지 따로 저장해놓는다.
    5) 참조 카운트 방식을 어떻게 구현할 지 짱구를 굴려보자! => 스마트 포인터와 같은 방식으로 구현해 볼 수 있다.
5. wsabuf와 SendQ의 재활용
    1) 직렬화 버퍼의 포인터를 SendQ에 꽂을 것이다. 이전에는 메시지를 복사하는 것이지만 이제는 버퍼 포인터를 등록할 것이다.
        * wsabuf에 SendQ를 등록할 때 어떻게 얻어서 등록할 것인지도 여러가지 방법이 나올 수 있다. 짱구를 굴려보기
    2) 위에서 등록된 SendQ에 모아놓은 직렬화 버퍼 포인터를 wsabuf에 등록한다.
        * 이전에는 WSABUF에 다수 개를 등록할 수 없어 이 방법을 사용하지 못했다. 그러나 지금은 가능하다. 지금은 제한이 없다.

### WSABUF 크기
1. WSABUF 배열 크기에 대한 논의
    1) 첫 번째: 동적 할당. SendQ에 등록된 직렬화 버퍼 개수만큼 동적 할당 한다. 단, 오버헤드가 생기는 문제점이 생긴다. 그러므로 우리의 대상은 아님
    2) 두 번째: 정적 할당. SendQ의 최대 크기 혹은 특정 계산을 통해 결정된 상수 크기로 정한다. 결과적으로 크기에 대한 결정은 스스로 판단을 내려야 한다.
        * WSABUF를 크게 잡아 한 번에 쏟아낼 때와 적당히 잡아 적정치만 보내고 다음에 보내는 경우에 어떠한 장단점이 있는지 생각 및 테스트하여 결정할 수 있다.
        * 예를 들어 지금 에코서버에서는 링버퍼 크기가 1000인데 패킷의 크기는 10이다. 이 경우 최대 100까지 메시지를 복사할 수 있는 상황이다. 따라서 WSABUF를 100개로 지정할 수 있다.
        * 최대 어느정도까지 등록이 되는지 테스트해서 수치를 뽑아 놓아야 한다. 또한, 이 수치 크기로 할 때와 이하로 할 때의 차이점을 비교해 보아야 한다.
        * 적정치가 좋다의 의견: 한 번에 쏟아낸다면 다수의 세션에게 보내는 상황이 되었을 때 하나하나의 세션마다 보내지는 양이 많기 때문에 다른 유저에게 보내지는 시간도 그만큼 지연될 수 있기 때문에 고민할만한 가치가 있다. 어찌 됐든 같은 TCP 스택에서 해당 IO 작업에 대한 처리를 해야하기 때문이다.

### 링버퍼 변경
1. 나중에는 Template 형태로 재구현 할 것이다.
    * 일단 지금은 그대로 사용할 것이다.

### SendQ의 목적
1. SendQ가 있는 목적
    1) 우리는 Send를 1회로 제한하기 때문에 보낼 데이터를 저장해놓을 공간이 필요하다. 예나 지금이나 마구잡이로 Send가 필요할 때마다 할 수 없는 상황이다.
        * IOCP 이전에는 Send 호출 횟수를 줄이기 위한 목적에 있다.

## 기타 키워드
### 과제
1. IO Pending이 일어났을 때와 일어나지 않았을 때(제로 카피인 경우와 아닌 경우) 얼마나 성능 차이가 나는지 무조건!! 분석하기
    1) 단순히 TPS 수치는 이정도 가지고 일어나지 않는다. 영향이 거의 없다.
    2) 직접적으로 해당 구간을 성능 측정하여 비교를 해보아야 한다. 
2. 제로 카피 구현하기. 즉 SendQ에 직렬화 버퍼를 꽂아넣는 형태로 SendPost를 구현하여 테스트하기
3. Stop()
    1) 서버를 안전하게 종료될 수 있게 정리 절차를 하는 기능을 한다.
    2) 예시로 뭐 세션 종료, 워커 스레드 정리, 이 들어갈 수 있을 것 같다..

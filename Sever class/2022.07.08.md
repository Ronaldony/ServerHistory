# 2022/07/08 수업내용
# 락프리
## 락프리 큐
### 디버깅
1. DeQ 작업에서 Size가 0보다 큰 것을 확인하고 들어갔는데 Head->next 가 NULL인 상황
    1) 문제 원인1: A 스레드가 바라봤던 Head가 다른 스레드에서 tail이 되어 next
    2) 문제 원인2: 
    3) 큐에 데이터가 없는 것을 처리하는 기준
        * 1: Size 확인. 
        * 2: Head->next가 Null 확인. 이 방식은 이벤트 방식으로 DeQ를 하는 방식이라면 있는데 없다고 판단하는 상황이 온다. 이 상황에 대해서는 아래에서 상세하게
2. DeQ와 스레드의 설계
    1) 이벤트적인 스레드 구조를 만들었을 때, 큐에 메시지가 있을 때 스레드가 깨어나는게 1:1로 매칭되게 할 수가 없다.
    2) 멀티스레드에서는 외부에서 큐의 Size를 확인하여 DeQ 동작을 하는, 즉 Size에 의존한 코드는 믿을 수가 없다.
    3) 따라서 정책을 제작자가 정해야 한다.

### 테스트
1. 제한 시간 내에 EnQ, DeQ
2. 스핀락과 락프리
    1) 스핀락 최악의 시나리오: 코어보다 스레드가 많은 경우 최악의 상황이 벌어질 수 있다. 그 이유로 자원을 할당한 스레드가 멈춘 상태에서 다른 스레드들이 자원을 할당하기 위해서 계속해서 뺑뺑이도는 상황이 벌어진다.
    2) 락프리: 코어보다 스레드가 많은 경우에도 스핀락과는 다른 상황이 벌어진다. 먼저 EnQ 혹은 DeQ 작업에 들어간 스레드가 있다 하여도 늦게 시작한 다른 스레드가 먼저 성공하는 상황이 나타나기 때문이다. 
    3) 스레드들이 많아진다는 것은 
3. 만약 다른 스레드들이 다른 일을 하는 것은 없애고 
    1) EnQ와 DeQ와 전혀 다른 일을 하는 스레드를 늘리는 것은 코어 개수를 줄이는 효과를 줄 수 있다. 
    
### 실무
1. 사용하지 않는 이유
    1) 자신이 만든 락프리 큐를 믿지 못한다.
    2) 제대로 알지 못한다. 어떤 상황에서 사용하여야 할 지 효과가 얼마나 좋은지 등..
        
## 기타
### 

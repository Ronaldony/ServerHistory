# 2022/02/11 수업내용
# 소켓 프로그래밍
## Chapter01
### UDP
1. 통신하고자하는 IP, 포트를 확인하기 위해서는 Wireshark로 캡처를 해야 한다.

### 포트 번호
1. OS마다 Dynamic 포트 번호가 다르다.
    * 테스트 프로그램을 만들 때 수신측에서 OS마다 Dynamic 포트가 다르기 때문에 이러한 점을 고려하여 설계해야 한다.

### 윈속
1. 소문자로 시작하는 소켓 함수 (socket, connect 등)들은 유닉스 버클릿 소켓과 완벽히 일치하기 때문에 유닉스-윈도우 OS 에서 모두 호환된다.
    * WSA... 함수는 윈도우 전용이다.

### 바이트 정렬
1. 통신하는 경우 바이트 정렬은 엔드 노드 혹은 중간에 있는 네트워크 장치를 고려하여야 한다.
    * 모든 네트워크 장비들은 빅 엔디안으로 설계되어 있다.
2. 변수의 기준을 잡을때는 Type의 이름보다는 부호와 크기를 기준으로 정하는 것이 맞다.

## Chapter02
### 오류 처리
1. 네트워크 함수 기능 사용 시 항상 GetLastError() 를 호출하여 확인해봐야 한다.
    * 초반 네트워크 소켓 프로그래밍 시 모든 에러 코드를 눈으로 확인하고 MSDN에서 검색해서 눈에 익혀야 한다.
2. 에러 코드를 익히는 이유
    1) 에러 코드에 따라 후속 처리(연결 끊기, 무시하기, 프로그램 수행 정지, 로깅 여부 등)을 결정할 수 있어야 한다.
    2) 추후 WSAWOULDBOLICK, IO_PENDING(Overlap) 등의 오류 처리를 정확하게 하기 위한 것
        <pre><code>
        ret = send(...);

        if (ret == SOCKET_ERROR)
        {
            DWORD err = WSAGetLastError();
            // Log(err);

            if (err != WSAEWOULDBOLCK)
                Disconnet();
        }
        </code></pre>
    * 일반적인 오류를 찾아내어 실제 에러인 것과 에러가 아닌 것을 판단하여 실행 여부, 로깅 여부를 판단해야 한다.

### SOCKET
1. 소켓 생성, 초기화 등의 리턴 값 정확히 확인하기.
2. SOCKET은 즉시 재사용이 가능하다. => 해당 SOCKET이 close를 다른 스레드가 
    * 싱글스레드에서는 문제가 되지 않지만 멀티에서는 문제가 발생할 확률이 높다.
    * 문제1: close된 소켓이 새로 생성을 요청한 소켓이 같은 번호로 배정되어 소켓 버퍼에 있는 데이터를 사용한다.
    * 문제2: close된 소켓이 새로 생성을 요청한 소켓이 같은 번호로 배정되어 바로 해당 소켓을 닫아버림
    * 해결: 동기화하면 해결된다. 하지만 우리의 목적은 동기화하지 않고 이 문제를 해결하는 것을 목적으로 한다.
3. 소켓 타입
    1) SOCK_RAW: IP와 TCP 헤더를 커스터 마이징하거나 헤더를 읽을수도 있게 소켓을 생성하는 옵션
        * 보통 해킹 시 헤더를 고치는데 사용
4. SOCKET 구조체의 초기화 값은 항상 INVALID_SOCKET
5. closesocket 함수는 "연결을 끊겠다"와 "SOCKET 구조체 리소스를 반환하겠다"라는 두 가지 의미를 지닌다.

## Chapter03
### 소켓 주소 구조체
1. sa_family: 모든 소켓 파라미터는 모든 IP 타입에 호환성을 갖기 위하여 이 자료형으로 받고 있다.

### 바이트 정렬
1. htons, htonl, ntohs, ntohl 등의 함수로 IP와 포트 번호를 바이트 정렬시킨다.

### IP 주소 변환 함수
1. inet_ntoa의, inet_addr은 비권장 함수이다. (강사님이 주신 프린트물 함수 사용할 것)
    * **inet_ntoa의 문제점**: 반환된 char* 주소가 사용자의 입장에서 동적 할당된 것인지, 전역 공간에 접근한 것인지 알 수가 없다. 또한, 다른 스레드에서 접근 시 바뀔 수가 있다.
2. 서버에서 소켓으로 받은 클라쪽의 정보중 IP, 포트 번호를 한 묶음으로 관리하여 유저에 대한 관리를 한다.

### 도메인 이름
1. gethostbyname, gethostbyaddr 함수들은 inet_ntoa와 비슷한 문제로 비권장 함수이다.
2. gethostbyname은 입력된 도메인 네임을 바탕으로 DNS 서버에 조회하지만, gethostbyaddr는 해당 IP 소유자에게 도메인 네임을 조회한다.
    * gethostbyaddr는 IP 소유자가 도메인 이름을 반환시켜주는 기능을 지원해야 가능한 기능이다.
3. GetAddrInfo 함수: 도메인의 해당 IP의 정보들을 초기화해주겠다.
    <pre><code>
    INT WSAAPI getaddrinfo(
        PCSTR           pNodeName,
        PCSTR           pServiceName,
        const ADDRINFOA *pHints,        // 
        PADDRINFOA      *ppResult       // 우리에게 필요한 정보
    );
    </code></pre>
    * ppResult는 링크드 리스트 형태로 반환된다.
    * ppResult는 freeaddrinfo로 따로 해제를 해주어야 한다.

## Chapter04
### 서버-클라이언트 구조
1. bind: 소켓을 IP와 포트에 연결시키는 기능. 해당 소켓이 사용중이라면 에러가 발생한다.
    * 하나의 소켓은 하나의 프로세스에서만 사용이 가능하다.
2. (이부분 약간 놓침)클라에서 connect 호출 시 대상 목적지로 가기 위해서 어떤 IP로 갈건지 정하고 그곳에 자동으로 Binding을 수행한다. 이후 3 Handshake
    * bind 함수는 수동으로 Binding하는 함수이다.
3. listen 소켓: 클라이언트의 연결(connect)를 기다리는 소켓

### 통신의 부하
1. UDP 입장에서 소켓 단위로 I/O를 제어하기 때문에 소켓을 여러개 생성하여 각 소켓의 부하를 줄일 수 있는 효과가 생긴다.

## 기타 키워드
### 테스트 프로그램
1. 스트레스 프로그램, 더미 프로그램

### 게임
1. 서버는 항상 64bit로 가야하지만 클라쪽은 32bit도 지원해줘야 한다. (해외에는 오래된 OS를 사용하는 유저가 있기 때문)

### 소켓 오류 처리
1. 우드 블록, I/O 펜딩

### 비권장 함수
1. 소켓 함수들 중 비권장으로 바뀐 함수들은 사용하지 않는 것이 좋다.

### 과제
1. GetAddrInfo 함수를 사용하여 해당 도메인의 IP 주소를 모두 가져오기

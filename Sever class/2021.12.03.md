게임 프로그래밍 구조
 1. 객체지향
	1) 적군 생성 방법: 동적 할당 추구
 2. 절차지향
	1) 적군 생성 방법: 고정 할당 추구
 3. 게임 프로그램 구조
	1) 로직
		(1) 적군 배치 및 이동
			(1-1) 생존 상태 플래그: 가장 접근을 많이하는 변수라면 구조체의 첫 요소로 배치(Offset 계산이 없어짐)
			(1-2) 적군에 대한 AI처리 시 최대치만큼 순회하며 처리하는 것은 문제가 되지 않는다. (4.의 2) 특성과 관계 있음)
			(1-3) 적군의 필요한 요소: 좌표, 방향, 이동 반경, 특성(type), 생성 좌표에 대한 정보를 가져야 한다.
			(1-4) 외부에서 이동 패턴(여러 패턴을 가질 수 있음)을 읽어와 몬스터의 이동 방향에 대한 요소를 저장하여 이동하여야 한다.
		(2) 공격 구현
			(2-1) 공격 횟수, 갯수에 대한 제한을 둔다. (FPS 게임 총알에 대한 탄피의 경우 무한히 증가하지 않는다.)
			(2-2) 공격 구조체(객체)를 따로 생성하여 아군 혹은 적군에 대한 소유권을 부여하여 이동 방향, 타격 판정 등의 동작을 수행한다.
			(2-3) 충돌 판정은 공격 투사체 기준 혹은 유닛 기준으로 나뉠 수 있다.
		(3) 외부 데이터로 빼야하는 요소들
			(3-1) 컨텐츠에 관한 요소에 대한 정보(스테이지, 몹의 좌표-종류-공격 패턴 등)은 프로그램에 직접 코딩하지 않고 외부(파일 등) 요소로 무조건 빼야한다.
				=>Stage(StageList를 스테이지에 대한 파일을 수정함으로써 프로그램의 동작을 변경할 수 있는 장점)
			(3-2) 스테이지, 적군 배치, 공격 패턴 등에 관한 것은 Tool을 만들어 기획자에게 제공하여 소통하는 것이 좋다. 
				=> 유의할 점: 기획자에게 Tool 제공 시 시각적인 그래픽의 형태로 제공하는 것이 좋다.	
 4. 클라이언트와 서버의 입장
	1) 클라이언트: 가시적인 게임 요소 변화에 따라 메모리 사용량이나 속도가 합리적으로 보여야 한다. (ex: 유저 수가 많으면 렉이 걸림)
	2) 서버: 유저수가 많든 적든 일정한 메모리 사용량, 속도를 유지하는 것이 이상적인 구조이다.
		(1) 정한 동접자 수가 가득찼을 때 원활하게 게임 진행이 되는 것이 이상적
 5. for문 안에서 중복 if 문을 사용할 때 if-continue로 대체하는 것이 코드가 간결하다.
	ex) if(cond1) { if(cond2) ... } -> if (!cond1) continue; if (cond2)...

과제 
 1. 스테이지, 적군 타격, 충돌
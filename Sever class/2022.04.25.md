# 2022/04/25 수업내용
## 스레드 프로그래밍
### 인터럽트와 스케줄러
1. 요즘 컴퓨터는 거의 대부분이 인터럽트로 처리된다.
    1) 최소 단위 오퍼레이션: Core가 명령어를 처리하는 동안 '인터럽트'가 개입되느냐 될 수 없느냐가 기준이 된다. OS에서 인터럽트는 핸들러 방식으로 처리된다.
    2) 모든 Core당 하나씩 기본적인 인터럽트는 등록되어 있다. 타이머 0번, 키보드 6번 등...
    * 윈도우에서는 드라이버가 아닌 소프트웨어에서 하드웨어 인터럽트를 막아 놓았다.(위험)
2. 스케줄러는 OS의 가장 기본 기능 중 하나는 인터럽트를 처리하는 것이다.
    1) 우리 코드 입장에서는 인터럽트에 의해 인터럽트 코드로 가는 것은 컨텍스트 스위칭(컨텍스트 블록이 바뀌는 것)이라고 보지 않는다.
    2) 옛날 OS 방식: 레지스터 백업과 복원 그리고 컨텍스트 스위칭의 작업까지 인터럽트 코드가 책임진다. 인터럽트 코드에서 많은 시간을 소비하지 않게끔 설계되어야 한다. 이 때문에 MS에서는 정식으로 등록되지않은 드라이버들을 설치못하게 한다.
    3) 최근 OS 방식: 레지스터의 백업과 복원까지만 수행하고 컨텍스트 스위칭 작업은 수행하지 않는다.
3. 인터럽트 메모리는 항상 Non-paged Pool 여야한다. 그 이유는 아래와 같다.
    1) Atomic 연산자를 처리하는 것 조차도 Interrupt로 시작해서 Interrupt로 끝나기 때문에. 인터럽트 코드에서 메모리 참조 오류가 나면 해당 인터럽트를 처리해줄 수 있는 놈이 없다.
4. 스케줄러
    1) 타이머 인터럽트가 발생했을 때 CPU는 자신이 수행할 스레드를 자신이 고르는 것이다. 스케줄러는 시간 확인까지만 해주고, 실질적인 디스패처가 수행한다. 이 또한 인터럽트이다.
    2) 디스패처: 실질적인 컨텍스트 스위칭을 한다. 퀀텀타임을 모두 사용한 스레드가 어느 레디 큐에 들어갈 지를 결정해야 한다. 이때 CPU 선호도, Block 시간 등을 고려하여 
        * 윈도우는 기본적으로 하이퍼 스레드라면 0,2,4,6...등 현재 돌던 실제 코어와 다른 코어에 스레드를 배정시킨다.
        * 윈도우 7에서는 실제 코어 수 만큼 스레드를 돌리면 딱 자기가 돌던 코어에만 배정되어 실행된다.
        * 만약 스레드가 할애된 퀀텀타임을 모두 사용한 경우 같은 코어에서 돈다면 컨텍스트 스위칭으로 보지 않는다.
5. 인터럽트 Dispatcher: 인터럽트의 실행 순서를 적절히 분배해주는 녀석
    1) 스레드가 인터럽트에 의해 못도는 시간은 퀀텀 타임에 더하지 않는다. 이를 조절하여 스레드가 퀀텀 타임을 모두 소비하였다고 판단되면 레디 큐에 넣는다.
    2) 퀀텀 타임 모두 소비, Block 해제 시 어느 레디 큐에 어떻게 배정하는 작업을 한다. 또한 나랑 같거나 높은 
        * 디스패처는 실행 요청된 스레드의 우선순위와 '현재' CPU에 돌고있는 스레드의 우선순위를 비교한 후 요청된 스레드의 우선순위가 높다면 바로 CPU에 꽂아버리고(레디큐를 보지도 않는다.) 돌았던 스레드를 레디큐에 어디에 넣을지 파악하여 꽂아 넣는다. => 이때는 퀀텀 타임의 조건은 볼 조건이 아니다. 새로 생성되거나 Block을 마친 스레드를 대상으로 이러한 동작을 수행한다.
6. 실습
    1) GetCurrentProcessorNumber(): 할당된 CPU

### 레디큐
1. 여러 코어 그룹이 하나의 레디큐를 공유하는 방식으로 바뀌었다. 
2. 동기화 객체 또한 설계가 바뀌었다.. (수정)

### 선호도
1. 오히려 많은 스레드를 돌리고 있는 시스템에서 선호도를 설정하면 해당 CPU가 바쁘다면 오히려 더 성능 저하가 이루어진다.
    1) 클라에서는 
 
### 스레드 동작
1. MOV 명령 동작의 과정
    1) MOV 명령: Lx캐시 -> 캐시의 TLB 참조 -> Page Entry -> Page Entry까지 갔는데 프레임 정보가 있다! Page in, 프레임 정보가 없다! Page fault 후 스레드 정지!

### 상호 배제와 교착 상태(Deadlock)
1. 동기화
    1) 코드 수준에서 구조적으로 동기화 객체와 같은 요소를 사용하여 배타적인 실행 영역을 제한하는 기법이다. (최소 단위 오퍼레이션과는 상관 없음)
        * 이것은 어떠한 규칙이다.
2. 교착 상태
    1) 상황: PlayerLock과 ItemLock이 있을 때 두 스레드가 두개의 Lock을 서로 교차하여 사용한 상황. => 애초에 설계가 잘못된 상황, 해결할 문제가 아니다.
    * 교착 상태 4대 요소 외우기(다수 자원의 소유와 대기, 상호 배제, 무선점, 순환 대기)

## 기타
### TLB
1. MMU의 일부, L1~L3에 캐시와 같이 붙어 있고 가상메모리를 물리메모리 주소로 변환한 값들이 캐시화 되어 있다.
    1) TLB에는 캐시될 대상의 주소들이 들어있는데 
    2) MOV 명령: Lx캐시 -> L 
    3) Page Entry까지 갔는데 프레임 정보가 있다! -> Page in, 프레임 정보가 없다! -> Page fault

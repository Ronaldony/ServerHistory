# 2022/04/13 수업내용(복습 완료)
## TCP 파이터 서버 만들기
### 보완사항
1. 이전 기수와는 다르게 재연결, 연결 끊김을 감지하는 부분을 추가할 것이다.
 
### 서버 구조
1. 보통 서버가 싱글 스레드라고 하면 게임 로직이 하나의 싱글 스레드로 구현되어있는 것을 의미한다. 네트워크 까지 같은 스레드라는 얘기는 아니다.
    * 언리얼의 경우 MO 형태의 서버 구조이기 때문에 네트워크까지 포함되지만 MMO는 절대 이러한 구조가 불가능하다.
2. 메인 스레드 구조
    1) 강사님은 보통 메인스레드에 서버를 컨트롤하는 정도의 기능 함수만 넣고 뺑뺑이를 돌리신다. 여기서 서버를 컨트롤하는 기능이란 실제로 서버 모니터링이나 플레이어 제어와 같은 기능을 말한다.
3. 서버의 컨텐츠 로직 프레임을 몇으로 맞출것이냐?
    1) 3D 게임에서 서버에서 프레임에 기반한 처리가 아닌 시간을 기반한 로직 처리로 구현되어야 한다.
        * 프레임은 떨어질 수 있기 때문이다. 이전 프레임과 현재 프레임 시간 차이를 계산하여 플레이어의 이동 거리, 충돌 등을 처리한다.
        * 렉이 걸리는 상황: 프레임이 떨어짐으로 인해서 나의 메시지 처리는 느려졌지만 원래 로직의 속도는 동일하다 => 시간에 기반한 로직 처리가 되어야 가능
    2) 프로그래머가 결정해야하는 사항이다. => 강사님은 보통 50, 60 프레임
    3) 프레임이 빨라지면 정교한 처리가 이루어진다 의 의미? => 캐릭터의 이동, 충돌 처리가 클라에게 더욱더 자연스럽게 표현된다.
        * 액션성이 강하거나 부드러운 연출이 되어야하는 경우 프레임이 빨라져야함
4. 각 파트의 프레임(멀티 스레드 환경)
    1) 네트워크: 개별적으로 스레드를 빼게되면 프레임에 맞추지않고 최선을 다해 수행
        * send의 경우는 보낼 것이 있는 경우 바로 보내기 위함이고, recv는 send에 대한 응답이나 클라의 요청을 빠르게 처리하기 위한 목적이다.
        * 따라서 네트워크 파트는 코어 1개를 먹고 들어간다. (Sleep이 없기 때문) => 이후에는 이 동작에 적합한 소켓 모델을 사용하여 계속해서 select처럼 뻉뺑이를 도는 것이 아닌 스레드가 block된 상태에서 소켓 버퍼의 상태에 따라 recv, send를 할 것이다.
    2) 컨텐츠 로직: 프레임에 맞춰 로직 수행

### 안전 장치
1. 서버 종료 대기: 메인 스레드가 종료되면 프로세스가 terminate되기 때문에, 메인 스레드에서 함부로 종료하면 안된다. DB 저장이나 기타 등등 유저의 정보를 저장해야하기 백업해놓아야 한다.
    * 저장은 비동기적으로 수행되기 때문에 반드시 저장이 완료되었는지 확인하는 작업이 들어가야 한다.
3. Server Control 기능
    1) 목적: 외부에서 서버 동작을 제어할 수 있는 기능을 제공하는 것이다. 서버 개발자, 기획자, 클라이언트에게 제공하여 서버 테스트를 각자 개인이 할 수 있게 만들기 위한 목적!
    2) 서버를 콘솔로 만들 경우 X 버튼을 제거한다.(즉시 서버 다운) 최소화 버튼을 누르다가 X를 누를 수 있기 때문이다.
    3) 실질적인 용도: 디버깅, 테스트, 개발 과정, 긴급 상황 등의 특수한 상황에서 사용하기 위한 용도로 제작되어야 한다.
3. Server control의 사용 사례
    1) 사례1: 클라이언트에서 디버깅, 테스트 등의 목적으로 계정 인증 등의 절차를 무시하고 게임에 접속하는 테스트 프로그램을 만들수가 있다. 이러한 상황에서 실수로라도 테스트 프로그램이 유저에게 배포된다면 엄청난 재앙이 될 수 있다. 따라서, 클라가 아닌 서버에서 이러한 기능의 목적의 기능을 추가하는 것이 더 올바르다.
        * 보통 계정 인증의 경우 웹이랑 연동이 되어 수행된다.
    2) 사례2: 라이브 서비스 중 갑작스럽게 디버깅이 필요할 때 서버 컨트롤을 통해 제어
        * 예전 강사님은 하나의 플레이어가 여러 맵에 존재하는 유령 플레이어 문제가 발생하였을 때, 이 문제를 해결하기 위해 서버 컨트롤에 플레이어를 임의로 생성하는 기능을 삽입하였다. 실질적인 문제 해결은 특정 맵에 유저를 심어놓고 다른 맵에 해당 유저가 존재하는지 확인하는 과정을 모든 맵에 대하여 검사하였다.

### 로그
1. 로그는 최후의 디버깅 방법이다.
2. 최종적으로는 로그를 클래스로 구현할 것이다. 로그는 콘솔뿐만이 아닌 파일로 저장하는 형태가 되어야 한다. DB에 저장을 하거나 다른 서버에 전송 등의 방법은 데이터 유실의 가능성이 있다. 이후에 서버가 죽어버린다면..(이해가 잘 안됨)
3. 로그 레벨
    1) 수업에서는 DEBUG, ERROR(라이브 서비스 목적), SYSTEM 으로 구분한다. 중요도 순서는 DEBUG < ERROR < SYSTEM 이다.
    2) 현재 로그 레벨보다 낮은 중요도 로그를 기록 요청하는 경우, 해당 로그는 남겨지지 않는다.
        * 디버깅 목적으로 서버를 테스트할 때는 로그 레벨을 DEBUG로 설정하여 모든 로그를 기록한다.
4. 정상적으로 동작된 로그를 남기는 것도 중요하다. => 우리는 에러가 발생하는 시점을 특정할 수 없다. 때문에 에러가 발생하였을 때 정상적인 루트가 어디까지 진행되었는지 파악하는 용도로 로그를 남겨 디버깅 할 수 있다.
5. 로그 레벨 변경
    1) 보통 로그 레벨을 나누어 로그를 남길 떄는 각 로그에 #ifdef을 걸어 남기지 않을 로그를 코드 단에서 완전히 제거한다.
    2) 우리는 위에서 언급한 #ifdef을 사용하지 않을것이다. Sever control 기능에서 실시간으로 로그 레벨을 변경하여 각 상황에 맞는 로그를 실시간으로 비교하기위한 목적이 있다.
        * 또 다른 이유1: 무조건 마지막으로 테스트한 코드가 그대로 서비스되어야 한다. 이때 로그 레벨 설정을 잘못하여 로그 레벨만 바꾸어 빌드하여 서비스하였다해도 완전히 다른 결과물이기 때문에 이러한 상황에서 로그 레벨을 변경시키기 위한 목적 
        * 또 다른 이유2: 보통 DEBUG 로그의 경우 컨텐츠 로직 등에 추가될텐데, 서비스하다가 새로 추가된 컨텐츠가 정상적으로 작동이 되는지 확인하기 위하여 로그 레벨을 변경해야 하는 상황이 올 수도 있다.

### 가변인자(내용 보충)
1. 가변인자는 피호출자 내에서 매개변수의 개수와 변수 하나하나 알지 못한다. va_start, va_end, va_list, va_printf 등의 가변인자 함수를 사용하여 List 형태로 뽑아오는 형태로 갈 것이다.
    * 거기에 포인터를 직접적으로 들어가면 스택 메모리 포인터를 준다. 우리가 수동적으로 들어갈 수 있지만 여전히 우리는 매개변수가 무엇인지 모른다. 따라서 우리는 ##__VA_ARGS__ 매크로를 사용하여 그대로 로그를 남길것이다.
2. 가변 매개변수 함수는 cdecl 호출규약이 사용되어야 한다. 함수 안짝에서 매개변수 개수를 몰라 스택을 정리할 수 없기 때문이다.
 
### 유저 관리
1. 세션 ID와 회원 ID(컨텐츠에서 사용되는)는 분리되어야 한다.
    * 회원 ID는 영원히 바뀌지 않으며 실제 유저를 구분하기 위한 구분자의 역할을 한다.
    * 세션 ID는 새로운 접속을 할 때마다 ID가 새로 부여되어 세션에 대한 관리의 기준이 될 것이다.

### STL 자료구조 사용 시 주의사항
1. 자료구조는 게임의 구조 혹은 컨텐츠 변경 등의 이유로 인하여 갈아끼울수(변경될 수) 있어야 하기 때문에, 해당 자료구조 변수의 멤버를 호출하는 것을 최소한으로 해야한다.
    * 이 작업을 wrapping 한다고 한다. 이는 사용법을 달리하여 우리 사용법에 맞게 설계하자는데 의의가 있다.
    * 강사님은 항상 자료구조에 대한 wrapping 함수를 만들고 본다. 사용하지 않더라도
    <pre><code>
    map<SOCKET, st_SESSION*> g_SessionGroup;
    
    // 나쁜 예
    g_SessionGroup.Find(id->SessionID);
    
    // 좋은 예
    map<SOCKET, st_SESSION*>::iterator iter;
    for(iter = g_SessionGroup.begin(); iter != g_SessionGroup.End(); iter++)
    {
        // 찾는 코드...
    }
    </code></pre>
2. 최적의 자료구조를 찾는 방법은 테스트이다. 아무리 짱구를 굴린다해도 항상 가설이 맞을수는 없다.

### 유저 접속
1. 연결 끊김 시 재접속 처리 추가하기
2. 유저 접속은 무조건 최선을 다해서 해야한다. 예를 들면 소켓 셋 등록시 항상 Listen 소켓을 등록한다.
    1) 누군가 악의적으로 무수히 많은 연결을 시도하는 경우를 생각해보자. 이때 accept 처리 수가 많다면 정상적인 접속에 대한 처리를 어느정도는 커버해줄수 있다. 반대로 accept처리 수가 적다면 정상적인 접속에 대한 반응이 느릴 것이다. (백로그가 가득 차 연결 실패로 이어질 수 있음)
3. 유저 끊김 기준
    1) recv가 0일 때
    2) 소켓 에러가 발생한 경우
    3) Timeout 처리
    * 소켓을 iterator로 순회하는 동안 위 3가지 상황 발생에 대한 대처 코드 넣기 (iterator에 문제가 발생하지 않게끔)
4. MMO는 좌표가 틀어지는 것이 클라만의 탓이 아닌 서버의 탓도 있다. 서버가 느려져도 좌표가 틀어지기 때문이다.
    * 따라서 연결을 끊는게 아니라 서버의 좌표를 클라가 맞추도록 좌표 동기화(싱크)를 할 것이다. 이때 해당 플레이어(클라)가 시야에 있는 플레이어들에게도 싱크 패킷을 보낼지 안 보낼지 결정해야 한다.
    * Realtek 이더넷 카드는 자주 네트워크 지연이 일어난다.

### 기타
1. 섹터(=클러스터, 파티션) 관리: 플레이어 시야에 대한 관리
2. 렉: 반응이 느리게 오는 것

## 기타 키워드
### C++ 문법
1. boost는 몰라도 됨(신입에게 요구한다는 것은 그 회사에서 boost를 위주로 사용한다는 것!) 요구하는 회사는 안 가야됨

### STL과 iterator
1. unordered map: 해시 테이블의 단점인 순회가 너무 비효율적인 점을 보완하기 위하여, iterator로 순차적으로 정렬해놓았다.
2. map: map 또한 iterator에 중위순회 순서로 노드를 정렬해 놓는다.

### 복습 중 질문
1. 서버 종료 대기 후 DB 저장 등이 비동기적으로 이루어진다면 이 작업들이 완료되었는지 검사하는 작업은 어떻게 할 것인지?

# 2022/03/11 수업내용(복습 완료)
## TCP 파이터 클라이언트 과제
### PC와 모바일 네트워크 끊김
1. 보통 PC게임은 네트워크가 끊기는 것을 전제로 가지 않는다. 네트워크가 끊겼다는 것은 게임이 종료가 된 것과 동급으로 본다. 끊길 시 타이틀(로그아웃)로 돌아가는 식으로 구현하여야 한다.
2. 모바일의 경우 네트워크가 수시로 끊기는 경우가 많기 때문에, 서버측에서도 30초~1분 정도 계속해서 재연결을 시도하여 게임 진행이 지속되게 구현하여야 한다.
    * 클라에서는 끊기는 동안 모래시계같은 것을 띄워서 플레이를 유지할 수 있게 서버에 계속해서 재접속 요청을 보낼 것이다.(이때는 정식 인증 절차를 밟지 않고 접속이 이루어져야 함)

### 메시지 처리
1. 메시지 처리에 대한 프로시저 함수의 매개변수를 통일시켜야 한다.
    * 이와 같이 하는 건 함수 포인터, Key-value 형태 자료구조 형식으로 설계할 수 있게끔 하기 위해서이다.
    * Key-value 자료구조 형태는 성능보다는 안전성 위주로, 만약 타입이 존재하지 않을 때 예외처리를 할 수 있게끔 하는 것이다.
    * switch-case 방식을 사용하지 않고 다른 방식으로 재사용하여도 대처할 수 있도록 처음부터 설계해야 한다.  
2. 메시지 하나당 하나의 프로시저 함수!!
3. 메시지 프로시저 함수 안에는 간단한 처리 함수만 둘 것. 즉, 클라의 하나의 동작 메시지의 요소들을 뜯어서 하나하나 함수를 호출하는 것이 아닌 정리된 최소한의 함수를 사용하여 메시지와 처리 함수 호출의 비율을 최대한 일치시키는 것이 좋다.
    * 외부에서 캐릭터에 대한 멤버를 건드리고 여러가지 조작을 통해서 행위가 되게끔 하지 말 것
4. 유니티의 에셋 스토어에 싱글용 게임을 온라인 게임으로 전환 시에 가장 첫 번째 하는 것이 대부분 모든 클라이언트 개발자들은 키보드 입력부 함수 안에서 로직이 들어가는데, 이것을 다 뜯어내어 액션 단위로 함수로 묶어 사용한다. (메시지 형태로 바꾸면 골치가 아파짐) 이후에 키보드 입력이 아닌 짜여진 코드에 의해 해당 동작들이 되는지 확인하고 네트워크를 붙인다.

### 메시지 생성
1. 각각의 패킷마다 생성 함수를 1:1로 만들어서 패킷 데이터 생성코드를 생성한다.
2. 메시지 생성 함수 설계 시 최대한 메시지 요소들을 컨텐츠가 아닌 데이터로써 풀어서 매개변수로 입력하여 메시지를 생성하게 하는 것이 좋다.
    * 이는 외부로 부터 독립적이게 만들어 유지보수에 유리하다.
    * 만약 객체 단위(컨텐츠, 예를 들어 플레이어)로 받게 되면 해당 객체가 변경되었을 때 모든 함수에 대해서 수정이 되어야 한다.
3. 메시지 처리, 메시지 생성 함수는 따로 .cpp를 만들어 관리해야 한다.
 
## 게임 구조
### 프레임 기준 구조
1. 프레임 스킵(2D 게임에 해당)
    1) 프레임 시간이 부족한 경우 **렌더링을 포기**하고 로직을 늘리는 방법이다.
2. 2D의 경우 스프라이트 한 장 한 장을 기준으로 렌더링하기 때문에 클라이언트는 프레임 기준으로 하지만, 서버는..?
    1) 서버의 경우 

### 시간 기준 구조
1. 3D에서의 Delta time 기준 처리
    1) 로직 처리: 예를 들어 이동 로직 처리 경우 Delta time * speed로 로직 처리가 이루어진다. 이는 3D에서는 시간을 기준으로 키 프레임 시점에 **애니메이션을 만들어**가기 때문에 가능한 방법이다.
    2) 온라인 게임에서는 클라와 서버가 동일한 공식을 사용하여 결과를 만들어 동기화 시킬 수 있다.
    * 언리얼의 Rigidbody를 사용하지 않는 경우 위와 같은 방법을 사용한다.
2. Fixed Update(3D 유니티, 언리얼에 해당)
    1) 프레임 스킵과 반대인 개념으로 Fixed Update를 항상 50FPS까지 맞춰준다. 때문에 Fixed Update에 로직부분을 넣는다.(Update는 느리면 느린대로 호출된다.)

### 서버의 구조
1. 현재는 서버에서도 항상 시간 기준으로 모든 것을 처리한다.
    1) 장점: 프레임이 떨어져도 별 문제가 없다.
2. 서버에서는 프레임 스킵, Fixed Update를 고민할 필요도 없고 사용할 수도 없다. 또한 프레임이 떨어져도 할 수 있는 것이 없다.
    * 따라서, 서버를 시간 기준으로 설계함으로써 프레임이 떨어져도 정상적으로 처리할 수 있도록 해야한다.
    * 목표 프레임 기준 10 프레임 이하로 떨어지면 유저는 불편함을 느낄 것이다.

### 길 찾기
1. 서버의 길 찾기
    1) 서버가 하는 경우 보통 타일 단위(사각형, 그리드)로 길 찾기를 구현한다.
    2) 캐릭터는 타일의 어느 위치에 서도 타일의 중앙을 기준으로 길을 찾는 형태이다. 또한, 타일 이동 갯수를 기준으로 이동 시간을 계산한다.
2. 클라의 길 찾기
    1) 클라가 하는 경우 3D의 폴리곤(네비메쉬, 다각형 면)으로 길 찾기를 구현한다.
    2) 클라에서는 아무 생각없이 네비메쉬 플러그인을 사용하여 길 찾기를 구현한다. 따라서 서버는 이러한 점을 고려하여야 한다.
    * 따라서 서버-클라가 통일되지 않은 방법으로 길을 찾게되면 서로 판단하는 좌표의 값이 달라진다.
3. 서버-클라 통일 길 찾기
    1) **예전** 클라에서는 월드좌표가 주, 필요하다면 그리드 좌표가 보조였다. 서버에서는 그리드 좌표가 주, 월드좌표가 보조였다.
        * 따라서 서버에서는 처리된 그리드 좌표를 월드 좌표로 환산하여 클라로 전달하였다.
    2) **현재**는 서버와 클라 모두 월드좌표가 주, 필요하다면 그리드 좌표가 보조이다.
    * 이유는? -> 최근 모든 게임은 3D로 제작되기 때문이다. 2D라 해도 3D 형태의 2D로 제작된다.
4. 현재에도 그리드 좌표가 필요한 이유
    1) 길 찾기의 보조 좌표, 충돌 처리 범위, 아이템 획득 판정 등의 요소에 그리드 좌표가 사용되는 경우가 있다.
    2) 그리드를 사용함으로써 데이터의 용량, 비교 횟수 등이 전반적으로 줄어들기 때문에 아직까지도 그리드 좌표를 버릴 수 없다.
    3) 오브젝트간의 모든 충돌 처리, 스킬 판정, 아이템 획득 판정 등을 모두 월드 좌표로 비교할 수 없기 때문이다.
    * 보통 그리드 단위는 2의 승수로 떨어지는 수로 정한다.

### 좌표
1. pixel이라는 단위로 좌표를 표현하면 오차가 커진다. 따라서, 실무에서는 대부분 실수형 변수로 좌표를 표현한다.
    * 모니터 상에서의 좌표가 아닌 월드 상에서의 단위로 좌표를 인식해야 한다.
2. 게임에서 좌표 1을 실제 세계에서 1m 정도로 본다.

## 기타 키워드
### 언리얼
1. 언리얼 데드케이티드 서버가 애매한 부분
    * 이 서버를 사용하는 배그에서 핵이 나오는 것을 보면 완전한 서버-클라 구조가 아니라고 판단된다.

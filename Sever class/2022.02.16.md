# 2022/02/16 수업 내용(복습 완료)
## 소켓 프로그래밍
### Backlog
1. 연결 정보를 Backlog에 저장하는 이유
    1) OSI L7 계층간 작업은 비동기로 이루어지기 때문이다.
2. 서버측에서 backlog 큐가 꽉 차서 클라측에서 connect가 실패하는 경우 무시한다.(WSAECONNREFUSED: 10061번 에러)

### 통신 함수
1. recv함수
    1) Block 되는 시점: 수신 소켓 버퍼가 0인 경우
        * I/O에 대한 처리를 누구한테 요청해서 Block이 걸렸나? => 소켓 수신 버퍼가 비어있다면 함수 내부에서 WaitSingleObject 함수를 호출하여 PSH 패킷이 올때까지 block이 된다.
    2) recv가 반환되는 시점
        * case1: recv 하는 시점에 이미 소켓 수신 버퍼에 데이터가 있는 경우(즉, PSH와 관계 없음)
        * case2: recv가 block된 시점에서 송신측으로부터 PSH 패킷이 수신된 경우
    3) 소켓 버퍼에서 사용자 버퍼에 메모리 복사가 이루어지는 시점
        * case1: 이미 소켓 버퍼에 데이터가 있는 경우로, 이는 사용자측에서 IO 작업이 이루어지는 형태가 된다.
        * case2: 소켓 버퍼가 비어있어 스레드가 Block 상태인 경우로, 다이렉트로 사용자 버퍼에 복사를 해버린다.(오버랩 I/O 방식) 즉 사용자가 등록한 버퍼가 소켓 버퍼가 되는 것이다. 이는 커널측에서 IO 작업이 이루어지는 형태가 된다.
        * 사실 case2에서 다이렉트로 사용자 버퍼에 꽂아주는 것인지 소켓 버퍼를 거치는 지는 애매한 부분이 있다.
2. send 함수
    1) Block 되는 시점: L7에서 요청한 길이보다 송신 소켓 버퍼의 공간이 부족한 경우
    * send의 경우 송신 소켓 버퍼가 꽉 차서야 제로 카피에 들어가기 때문에 **오버랩 I/O에서는 임의적으로 송신 버퍼를 0으로 만들어 제포 카피를 수행시킨다.**
    * 제로 카피: Block 상태가 되는 시점에서 사용자의 버퍼를 다이렉트로 송수신 버퍼로 사용하는 것
3. setsockopt로 소켓 버퍼를 조정하여도 L4 내부에서 값을 조정하기 때문에 실제 크기가 다를 수 있다.
    1) 송수신간 windows 사이즈가 이상한 경우 이 것을 의심해봐야 함

### Block과 Non-Block 소켓
1. Non-Block 함수 사용 시 후속 처리가 필요하다. 지금 당장 송수신 소켓 버퍼에 모든 작업을 할 수 없는 경우 에러를 반환한다.
    * WOULDBLOC
2. recv와 send를 Non-Block 소켓을 사용하는 경우 WOULDBLOCK 에러를 뱉어줌으로써 다음 동작에 대한 동작을 결정할 수 있다.
    1) 단점: 모든 소켓에 대하여 recv, send를 호출해봐야 상태를 알 수 있다. => 이를 해소하기 위한 방법이 소켓 모델이다.
    * 소켓 모델: 현재 송수신 여부를 미리 파악하여 송수신 동작을 수행할 지 말지를 결정할 수 있는 모델이다. selet, async select, evnet select, overlapped I/O 등이 있다.

### I/O
1. 동기: I/O 작업이 완료되면 반환
2. 비동기: I/O 작업의 완료 여부와 상관없이 반환한다.
3. 오버랩 I/O: Block 상태가 되어 사용자 버퍼를 송수신 버퍼로 등록하는 과정(Lock, 동기화 처리)에서 Overhead가 발생한다.
4. Regitsted I/O: 오버랩 I/O의 단점인 Overhead를 극복하기 위하여 처음부터 송수신 버퍼를 사용자가 등록한다.

## 기타 키워드
### Backlog 큐
1. 65535까지 늘리는 것에 대한 완벽한 이해 필요
    1) HINT를 썼는데도 불구하고 16xxx까지밖에 안늘어나는 이유(원인 찾기)
    2) 최대 비동기 포트 수를 늘리면 왜 65535까지 사용가능한건지 (Backlog 큐와 최대 비동기 포트 수 관계)

### PSH 테스트 방법
1. recv 측에서  

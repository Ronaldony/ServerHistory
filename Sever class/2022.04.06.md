# 2022/04/06 수업내용(복습 완료)
## 길찾기(Jump Point Search)
### 구현
1. 코드
    <pre><code>
    while(1)
    {
        Node = OpenList pop();
        목적지이낙?
        closeList.push(..);
        
        if(Node 부모 == NULL)
        {
            방향 코너 확인(Node.x, Node.y - 1, UP);
            ... // 8방향 코너 확인
        }
    }    
    
    switch(부모로의 방향)
    {
        case UP:
            // 기본 방향 검사
            방향체크(x,y-1,UU); 
            // 속성체크 (inline이나 매크로를 사용할 것)
            오른쪽이 막혔고 오른쪽 위 대각방향 코너 확인
            왼쪽이 막혔고 왼쪽 위 대각방향 코너 확인
            break;
        case RD:
            // 기본 방향 검사
            방향체크(x+1, y+1,RD);  // 오른 아래 대각
            방향체크(x+1, y,RR);    // 오른 
            방향체크(x, y+1,DD);    // 아래
            // 속성체크
            오른 아래, 오른, 아래 방향에 대한 속성 체크
    }
    
    // 방향체크하는 함수와 코너를 검사하는 함수를 분리하는 것이 더 깔끔할 수 있다.
    방향체크(x, y, Dir)
    {
        case RR:
            if(코너확인(x, y, Dir, &MX, &MY)
            {
                노드 생성(MX, MY, Node); // MX, MY에 노드 생성
            }
        break;
        case RU:
            // 대각 방향의 경우에는 코너확인이 수직 수평과 달라진다.
            // 대각 코너를 이 자리에서 확인하고 해당 대각의 수평 수직 방향 확인에 대해서는 코너확인을 들어간다.
            if(코너확인(x,y,Dir,&MX, &MY)
            {
                // 원래의 대각 방향 검사 자리 x, y 자리에 노드를 생성하는 이유는
                // 대각 방향의 수평 수직의 코너에 가 있는 경우 대각 방향 확인 자리에 노드를 생성해야 
                노드 생성(x, y, Node); 
            }
        break;
    }
    
    // 재귀로 만드는 방법이 있는데 이는 좋은 방법은 아니다.
    코너검사(x, y, Dir, *OutX, *OutY) // 오른 아래 대각선 코너 체크
    {    
        switch(Dir)
        {
            case RR:
                // 속성 체크
                위아래 벽과 오른편 위아래 대각 방향 코너 검사
                // 코너 확인 여부
                if(코너 == true)
                {
                    *OutX = x;
                    *OutY = y;
                    return true;
                }
                else
                {
                    x++;
                }
            break;
            case RU:
                // 속성 체크
                위아래 벽과 오른편 위아래 대각 방향 코너 검사
                // 코너 확인 여부
                if(코너 == true)
                {
                    *OutX = x;
                    *OutY = y;
                    return true;
                }
                else
                {
                    x++;
                }
            break;
        }
    }
    </code></pre>
    * JPS는 노드 생성을 줄이지만 각 타일의 속성체크가 들어간다. 때문에 속성체크가 빠르지 않으면 JPS의 성능이 잘 나오지 않는다. 따라서 속성체크 코드를 inline이나 매크로 처리하여 성능을 높여야 한다.
2. 점프 포인터의 문제점
    1) 노드 생성을 줄였지만 속성 체크가 너무 많이 들어간다. 그래서 최대한 속성체크를 매크로나 inline으로 구현해야 한다.

### JPS 개선
1. JPS를 개선시킨 것이 JPS+이다. JPS+는 모든 코너에 미리 타일 노드를 만들어놓고 실시간으로 타겟의 목적지까지로의 경로만 판단하며 길찾기하는 JPS 개선 방법이다.
    * 하지만 이는 코너가 바뀌면 동작하지 않는다.(다 익스트라와 유사)

### 에이스타 개선
1. 에이스타에서의 문제점
    1) 실시간 노드 생성으로 인해 성능이 떨어짐. 맵 전체에 노드를 생성하고 처리한다.
    2) CloseList의 존재여부: 사실 굳이 CloseList가 필요없다. 우리에게 필요한 건 해당 노드를 방문했냐 안했냐이기 때문이다. 따라서, 맵에서 xy좌표를 방문했냐 안했냐만 알려주면 된다.
    3) 부모를 바꿔 최단 경로를 바꿀 때 CloseList까지 검사할 필요가 있냐? => 없다. 이미 지나온 결로이기 때문에 OpenList에서만 확인하면 되는 것이다.

### 실제 적용
1. 우리가 만든 8방향의 길찾기를 실제로 적용할 수 있느냐? -> NO, 요즘 게임의 움직임은 8방향이 아닌 전 방향이기 때문에 사용할 수 없다. 따라서, 도착지점까지 타일 생성 후 경로를 만든느 과정에서 실제 방문할 노드를 재평가해야 한다. 이는 최단 경로를 찾기보다는 요즘 게임에서 8방향 움직임이 아닌 전 방향으로 움직이게 경로를 생성하는 것에 목적이 있다.
    * 방법: 부모 노드에 직선을 그어보고 그어진다면 계속해서 부모 노드에 직선이 안그어질 때 까지 긋는다. 그러다가 기준점 노드에서 직선이 안그어진다면 가장 최근에 그어진 노드로 기준점을 잡는다. 이후 다시 부모 노드를 타고가며 이전 직선 긋기 작업을 반복한다. 출발지점 노드가 부모노드가 되는 순간 끝.

### 직선을 긋는 방법
1. 변화량이 큰 축(x,y)을 기준으로 증가시키며 반대 축을 구하여 점을(점의 연결=직선) 그려 직선을 이어야 한다.(직선 방정식)
    * 변화량이 적은 축을 기준으로 점을 찍게되면 점의 갯수가 적게 나온다. 따라서, 우리는 변화량이 큰 축을 기준으로 수를 증가시키며 작은 축의 값을 구하여 점을 찍어 직선을 이어야 한다.
    * 직선을 그을때 실수 계산이 들어가면 성능이 나오질 않는다. 옛날에 컴퓨터 과학자 Bresenham은 정수만으로도 직선을 그을 수 있는 브레즌햄 알고리즘을 고안하였다.

## 브레즌햄 알고리즘
### 브레즌햄 알고리즘
1. 정의: 변화량이 큰 축을 기준으로 증가시키며 특정한 조건에서 반대 축을 증가 시키자~라는 방법의 알고리즘이다.(=변화량이 작은 축을 언제 올릴까~를 고민)
2. 특정 조건: 변화량이 큰 축이 X축, 작은 축이 Y라 할 때, X를 1증가시킬 때 마다 Error라는 변수에 Y축의 길이를 더한다. 이 작업을 계속 반복하다가 Error >= X축의 길이가 될 때 Y축을 1 증가시킨다. 이때 Error를 X축의 길이만큼 뺀 후에 나머지 값이 있다면 그대로 유지한 채로 다음 Y축을 증가시키기 위하여 이전 작업을 계속 수행한다.
    * 해결해야하는 문제: X좌표가 100, Y좌표가 1인 경우 마지막에 Y좌표가 1증가될 것이다. 우리가 원하는 것은 X좌표가 50일 때 증가하는 것이다.
3. 구현
    <pre><code>
    Line(SX, SY, EX, EY)
    {
        DX, DY;

        for(..)
        {
            x++;
            Error += DY;
            if(Error...)
            {
                Y++;
                Error -= DY;
            }
        }
    }
    </code></pre>

### 고민해보아야하는 것
1. 함수나 클래스를 써먹을 수 있게 만들어야 한다. => 사용자에게 직선들의 좌표를 어떻게 반환해줄 것이냐?에 대한 고민이 필요하다.
    * 방법 1: 요즘 스타일은 정해진 특정 타입의 iterator를 반환시켜 사용자가 순회하며 좌표를 얻어가는 형태
    * 방법 2(강사님 사용하는 방법): 클래스 멤버함수에 NextCoordinate를 호출할 때마다 건당건당 좌표를 반환해주는 형태 (함수가 호출될 때마다 실시간으로 좌표 계산이 이루어짐)

## 기타 키워드
### 메모리와 성능
1. 대부분 성능을 위해서는 메모리를 포기해야 한다.
2. 서버는 메모리 확장 시 팀내에서 해결할 수 있지만 클라의 경우 유저의 PC완 관련이 있기 때문에 기확자와 논의를 해야 한다. 

### 과제
1. 브레즌햄으로 선 긋기 구현

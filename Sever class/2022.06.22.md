# 2022/06/22 수업내용
# 락프리
## 락프리
### 기타
1. 락프리 리스트는 리스트로서의 존재 가치가 없다.
    1) 결국 헤드에 삽입하고 테일에서 뽑는 형태가 된다. 락프리 방식으로는 중간에 임의로 넣을 수가 없다.(해봐야 알 듯) 결국 큐나 스택과 같이 입출력의 순서가 정해진다.
    2) 또한 임의로 순회나 삽입 삭제가 될 수 없다.
2. 락프리는 IN과 OUT의 순서가 정해져있는 자료 구조에 제한된다. 따라서 큐와 스택뿐이 없을 것이다.
3. 스핀락
    1) 스핀락도 락의 하나이다.
    2) 장점: 퀀텀타임 내에 자원을 획득한다면 컨텍스트 스위칭 없이 자원을 획득할 수 있다.
    3) 단점: 쓸데 없는 CPU 사용률을 높일 수 있다. 스레드 수가 코어 수보다 많을 때 다른 스레드가 CPU를 점유하는데 영향을 줄 수 있다.
    4) 적절한 사용처
        * 1: 자원을 사용하는 시간이 굉장히 짧을 때
        * 2: 이 자원이 최우선인 상황
    5) 커널 코드 대부분이 락프리, 스핀락의 구조를 띄고 있다. 그 이유는 결국 커널 코드에서도 최종적으로 CPU에서 제공해주는 Interlocked를 사용하여 동기화 객체이던 malloc이던 구현해야 한다.
4. 동기화 객체
    1) 장점: 스레드가 코어보다 많은 경우 Block이 되었을 때 다른 스레드에 CPU를 점유할 수 있는 기회를 줄 수 있다.
    2) 단점: 자원이 사용 중일 때 Block이 걸리고 깨어나는데 많은 시간이 든다.
5. 스핀락과 락프리는 굉장히 유사한 면이 있다.

### 락프리
1. 작업을 시도하긴 하겠지만 누군가가 변화를 준 것 같다라면 지금 작업을 포기할 것이다. (작업: pop, push, EnQ, DeQ)
    1) 동시에 성공한다라는 것은 말이 안되는 상황이다. 불가능이다.
    2) 스택의 경우 push, pop 작업 시 TOP을 누군가가 나보다 먼저 바꾸었다면 해당 작업을 포기하고 다시 같은 작업을 시도할 것이다. 큐도 비슷한 과정.
2. 유사 상황: 깃발 뺏기 게임을 생각해보면 된다.
    1) 아무리 나보다 빨리 출발한 사람이 있어도 출발하여 깃발을 차지하기 위하여 달릴 것이다.
    2) 만약 모두 속도가 같다면? => 속도가 같다하여도 출발 이후 일어날 변수(넘어지는 등)가 생겨났다면 내가 늦게 출발하여도 도착할 수 있는 가능성이 생긴다.
3. 락프리가 스핀락보다 더 이득이 되는 경우
    1) 가장 늦게 출발한 스레드가 해당 작업을 완료한 경우. (스핀락이었다면 해당 스레드는 스핀락을 돌고 있을 것이다.)
    2) 스핀락을 돌고 있는(자원을 획득하지 못한) 스레드보다 우선순위가 높은 스레드가 자원을 가진 스레드를 제치고 CPU를 점유한다면 스핀락을 돌고있는 스레드들은 데드락 상태와 유사하게 된다.
4. 실무에서 사용되지 않는 이유
    1) 불필요한 CPU 이용률을 높인다. 대게 코어보다 스레드가 많은 상황이 많기 때문에 CPU 점유율을 높이는 것은 큰 단점이 된다.
    2) 완벽하게 구현한다는 것이 굉장히 어렵기 때문이다.
    3) 우리한테 가장 최우선인 자원이란 것은 거의 없다. 자원을 못쓴다면 다른 일을 하러가면 된다.

### 락프리 스택
1. 자료구조: 리스트 방식
2. PUSH
    1) 해결점: TOP을 방금 생성한 노드로 변경하기 전에 누가 변경하였다면 작업을 포기하겠다! 라는 동작이 되어야 한다. 
    2) 구조
    <pre><code>
    // 원래 코드
    push(Data)
    {
        노드 생성
        노드 데이터 = Data;
        노드 next = top;
        Top = 노드;       // 문제의 구간
    }
    // 변경된 코드
    push(Data)
    {
        노드 생성
        노드 데이터 = Data;
        while(1)
        {
            노드* top = _Top;     // Line a
            노드 next = top;
            if (_Top == top) // 내가 알던 Top: 노드 next
            {
                // 이 구간을 Atomic으로 해야 한다. 즉 InterlockedCompareExchange로 구현해야 한다.
                _Top = 노드;
                break;
            }
        }
    }
    </code></pre>
    3) 의문점: Line a 지점에서 꼭 지역 top을 선언하여 사용해야 하는지에 대한 의문점이 든다. (강사님은 문제가 될 것이라고 언급하였다. 자세히는 아니지만)
3. POP
    1) 구조
    <pre><code>
    // 변경된 코드
    Data Pop(...)
    {
        while(1)
        {
            top = _Top;
            Next = top->Next;

            if (_Top == top)
            {
                // 이 구간도 Push와 마찬가지로 Interlock 처리
                // Data는 알아서
                _Top = Next;
                top 삭제
                return Data;
            }
        }
    }
    </code></pre>
4. list를 사용하는 이유
    1) 변수 하나의 비교, 교체로만 Top이 변했는지를 판단하여 작업을 해야 하기 때문이다.
    2) 더블 링크드 리스트인 경우 양쪽 서로를 보아야 하기 때문에 4개의 행위가 Atomic하게 될 수 없기 때문이다.
    3) 결국은 큐나 스택같은 입출력과 순서와 방법이 정의된 자료 구조에 대해서만 락프리가 구현될 수 있다. 배열 형태는 불가능하다. 이 부분은 짱구를 굴려볼 것
5. 클래스를 Template 타입으로 만들 것이다.(Data에 대한 타입 Template)

### 포트 폴리오
1. 스핀락, 동기화 객체, 락프리를 사용할 때 성능 비교
    1) 다른 락을 사용할 때와 비교하였을 때 락프리가 어떠한 장단점이 있는지 정확히 판단해야 한다. (성능 측정 결과에 나의 생각을 맞추는 것은 절대 하면 안 된다!!!) 
        * 락프리는 락과 비교하였을 때 장점 자체에 다른 점이 있기 때문에 정확히 파악되어야 한다.
    2) 락프리가 어떤 상황에서 장점이 될 수 있는 상황을 억지로라도 만들어내서 이 상황에서 락프리가 더 좋다라는 것을 증명해야 한다. (결국 스택이나 큐가 그 기준이 될 것이다.)
        * 그냥 일반적인 상황에서 성능 테스트를 하면 의아한 결과가 발생될 것이다. 따라서 상황을 맞추어야 한다.
2. 락프리를 만드는 과정 로그, 문제의 추적, 원인 파악한 데이터를 모두 남겨 포트폴리오에 남길 것이다. (조사식 스샷 등)
    1) 어떤 문제들로 인하여 오작동이 되는지에 대한 모든 시나리오 그려져야 한다.

## 기타
### 이전 과제 - 제로카피 디버깅
1. 나의 의문: SendPost 내부에서 같은 링버퍼 Front를 대상으로 wsabuf에 등록이 되면 안 되는 상황인데 등록이 되는 상황이다. 이 문제를 나는 SendFlag의 문제라고 생각했다.
    1) 강사님 멘트1: 링버퍼 Front가 역전되는 순간을 잡아 어떤 스레드가 접근하고 있는지 확인해야 한다.
    2) 강사님 멘트2: SendFlag가 오작동하는 것 같다라는 의심이 든다면 2개 이상의 스레드가 동시에 접근하는 순간을 잡아야 한다. 이후 어떤 스레드가 왜 들어갔는지, 그 순간의 변수는 어떤 상황인지 파악해야 한다.

### 과제
1. 락프리 스택이 왜 오작동하고 크러쉬 나는지 왜 뻑 나는지 알아오기
2. 테스트 사항
    1) 메모리 참조 오류
    2) 순서대로 Push한대로 Pop이 되는지
    3) Push와 Pop의 개수가 틀어지는 상황
3. 테스트: PUSH와 POP을 동일한 개수로 테스트 할 것
    * 일단 데이터가 꼬이는 것은 배제하고 테스트 한다. (값이 틀린 경우)

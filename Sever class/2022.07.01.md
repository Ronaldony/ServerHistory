# 2022/07/01 수업내용
# 락프리
## 메모리풀
### ABA 문제(ABA problem)
1. 메모리의 주소를 재활용하는 상태이다. 때문에 주소값만 가지고 판단을 했을떄 이전에 내가 알던 데이터가 맞는지, 아니면 누가 새로운 
    1) 내가 Top으로 가리키고 있던 메모리 주소를 내가 아닌 누군가가 해제하고 할당하는지를 알 수 없다. 따라서 포인터 하나만으로는 실제 TOP이 변경되었는지 안 되었는지 알 수가 없는 상태가 된다.
    2) 
2. POP 에서의 문제
    1) 지점1에서 스레드가 멈추고 다른 스레드들이 같은 top에 대해...
    <pre><code>
    // 수도코드
    pop()
    {
        t = top
            next = t->next
        // 지점 1
        if (t == top)
            top = next; // 지점 2
    }
    </code></pre>
3. PUSH 에서의 문제
    1) PUSH같은 경우는 ABA 문제가 없다.
    <pre><code>
    // 수도코드
    push()
    {
        t = top
        NewNode = xx
        NewNode->next = t
        
        if (t == top)
            top = NewNode;
    }
    </code></pre>
4. ABA 해결 방법
    1) 고민거리: 포인터 주소 하나로는 과거에 
    2) 방법
        * Double CAS(Compare...): 128bit(16byte)를 할당받아 8byte를 주소 값, 8byte는 유니크한 Count값으로 사용한다. 자신의 레지스터 2배 크기만큼을 Atomic하게 동작할 수 있게 하는 기능을 지원한다. 이 방법은 엄청 느리다.
        * 사용되지 않는 주소를 사용: 초기 수업에서 언급한 커널 혹은 64bit의 경우 최상위부터 17bit를 활용하여 노드의 사용여부를 검사하는 방법. 하지만 이 방법은 OS 버전에 따라 달라질 수 있기 때문에 조심스럽다. 우리는 이 방법을 사용할 것이다.
        * 메모리풀 내부에서 주소에 대한 할당을 할 때 ...(잘 이해못함)

## 락프리 큐
### 일반 큐
1. 우리는 Head와 Tail이 Null을 찌르는 형태와 더미노드 형태를 두어 구현할 수 불필요한 코드를 제거하였다.

### 설계 시 문제점
1. 싱글 리스트에서의 문제
    1) Tail은 더미노드로 구현하였을 때 구현할 수가 없다. Tail이 더미 노드라면 Tail 이전의 노드의 next를 얻기 위해서는  포인터여야만 한다.
    2) Head는 더미 노드일 이유가 없다. Head와 Tail이 더미 노드인 경우 말이 안 된다.
    3) 마지막 하나의 노드만이 있을 때 Dequeue 상황일 때 
        * 따라서 최초에 더미 노드가 하나 기본적으로 생성된다.
        * DeQ 동작: Head가 가리키는 더미의 next로 이동하여 데이터를 사용하고 더미를 삭제한다. 그 후 next를 더미로 변경한다.
    4) Enququq의 문제점
        * 1번 동작: tail이 가리키는 노드의 next를 새로운 node를 가리키기
        * 2번 동작: tail의 위치를 새로운 node로 옮기는 것
        * 우리는 1번 동작만 성공하더라고 EnQ가 마무리되는 것으로 볼 것이다. 2번은 보조적인 역할로 볼 것이다. 2번은 실패했다하여도 어찌할 방법이 없기 때문이다.
        * tail이 가리키는 노드의 next가 null이 아니라면 재시도 할 것이다.
2. DeQ를 했을 때 

## Inetrlocked
### 성능
1. Interlocked는 생각보다 무거운 명령이다.
2. IneterlockedCompareExchangePointer는 시스템 bit에 따라 

# 기타
## 메모리
1. 64bit에서 윈도우가 허용하는 메모리 범위는 16EB(상위 21bit를 사용하지 못함)이다. 이중에 윈도우 10 초반까지는 커널 8TB, 유저 8TB 까지이다. 지금은 달라졌다.
    1) 현재는 커널 128TB, 유저 128TB가 유저영역이 되었다. (0x10000 ~ 0x00007FFF;FFFEFFFF) 최상위 17bit가 비어있다.
        * GetSystemInfo로 활용가능한 메모리를 확인해보면 볼 수 있다.

## 기술
1. SIMD 하나의 명령인데 여러 명령을 처리하는 기술(확장 레지스터를 통해 기능됨)

## 락프리 큐 과제
1. DeQ할 때 비어있는지의 여부를 Size로 검사할 것. 그 이유는 락프리 큐의 문제점을 경험하기 위해서이다. 이 문제는 정확히 파악하여 기록으로 남긴다.
2. 강사님이 전달한 코드의 문제점을 분석하여 기록으로 남겨놓기(포트폴리오 작성할 것)
3. 일단 락프리 스택에서 발생한 ABA 문제에 대한 해결 코드는 넣고 시작할 것

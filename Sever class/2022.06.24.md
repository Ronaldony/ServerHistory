# 2022/06/24 수업내용(복습 완료)
# 네트워크 라이브러리
## 락프리 스택
### 디버깅
1. 디버깅 추적 로깅을 남길 때 애초에 관련있는 로그들은 구조체로 묶어 로깅을 해야 한다.
2. 나의 증상: 같은 Top을 대상으로 delete를 시도하는 상황의 로그까지 남겨두었다. 이 상황에서 나는 같은 놈을 대상으로 delete를 시도하는 순간에 메모리 뻑이 났다 라고 보았지만 그 이전 상황에 대해서는 추적하지 않았다.
    1) 강사님 의견: 애초에 같은 TOP을 대상으로 해제를 시도하는 것은 말이 안 된다.(추측에 CAS로 막혀있기 때문) 그 이전에 어떠한 문제가 먼저 발생하여 그 상황이 벌어졌을 것이다. 따라서 그 이전 상황에서 흘러온 로그까지도 모두 추적을 해보아야 한다.
3. 메모리 로그
    1) 메모리에 로그를 하는 이유: 퀀텀 타임을 포기하여 Block되고 콘솔, 파일 로그를 찍으러가게 되면 스레드들이 동기화가 되어 버린다. (파일 IO 시 파일 자체에서 동기화가 되어버림)
    2) 로그 방법: 문자열 데이터는 대상이 아니다. 무조건 가장 빠르게 심플한 데이터를 대상으로 로그를 남겨야 한다.
    3) 로그를 남길 때는 최대한 많이 다양하게 상황에 대해 구체적으로 파악될 수 있는 데이터들을 남겨야 한다.
        * 어떤 스레드가 어떤 값을 들고 있는지 어떤 분기를 탔는지 등..

### 락프리
1. Compare-And-Swap(CAS): 윈도우 API인 InterlockedCompareExchange와 같은 기능을 하는 기능이다. 각 플랫폼마다 다른 이름을 갖는다.
    1) 락프리 스택에 대하여 인터넷에서 돌아다니는 일반적인 코드나 설명들은 노드를 push에 입력하고 pop 시 노드의 주소를 반환시켜준다. 우리의 목표는 일반적으로 사용할 수 있는 형태를 만드는 것이다.
        * 우리가 목표하는 것은 사용자가 사용 시 데이터의 관리적인 측면을 알 필요없이 그저 데이터를 가지고만 사용하는 것이다.
2. 노드(락프리)
    1) 배열을 사용할 수 없는 이유
        * 첫 번째 문제: push 내부에서 InterlockedCompareExchange를 넘어갔다 하여도 이전에 배열에 입력한 data가 내가 입력한 것인지 알 수 없다. (List의 경우 해당 노드는 하나의 스레드에 의해 data가 변경되고 있는 상황)
        * 두 번째 문제: push가 Top의 증가와 노드에 데이터를 저장하는 동작이 Atomic하게 일어나지 않는다. 때문에 pop 시 현재 Top에 있는 데이터가 push에 의해 변경된 것인지 변경되지 않은 것인지 알 수가 없다.
        * 위 문제를 해결하기 위해 해당 Top이 사용되고 있는지 없는지를 알기 위하여 스핀락을 사용하는데 이는 락프리의 의미 자체를 퇴색시키는 생각이다. 
    2) 리스트 형태로 사용하는 이유
        * Pop을 하는 행위가 Top을 바꿔주는 행위로만 Atomic하게 이루어지기 때문이다.
        * push 또한 Pop과 마찬가지이다.
    3) new, delete의 문제점
        * 동기화 락이 걸리는 문제가 생긴다. 
3. 동적 힙(1스레드, 1동적 힙)을 사용할 때의 문제점
    1) 할당받을 때는 해당 스레드에서만 할당받을 수 있는데, 해제할 때는 다른 스레드에서도 해제가 될 수 있으니까 결국엔 동기화가 필요하다.(그림이 잘 안그려진다.)
        * 강사님 언급: 스레드마다 힙을 확보했다라면 할당받을 때에는 아니까 상관없는데, 해제할 때도 그 스레드 힙으로 돌아가야 한다. 이것은 거의 불가능이고 누구도 이렇게 쓰지 않는다.

### 락프리와 new, delete의 문제 그리고 메모리풀
1. new, delete 문제
    1) 문제: delete를 행위로 인하여 top을 참조하는 과정에서 메모리 참조 오류가 나올 수 있다.(_Top이 가리키는 주소가 Decommit된 상태)
        * 지역 top에 _Top 값을 대입하였을 때 Stack 논리상 이미 제거된 상태라 하여도(메모리 해제가 아닌) 메모리 참조 오류는 발생하지 않는다. 따라서 _Top->next 값에 대하여 해제된 메모리 혹은 쓰레기 값을 가져왔다 하여도 문제가 되지 않는다.
        * 우리는 delete를 막을 수는 없다. 그저 메모리 참조 오류만 막는 방법을 생각해보자! -> 애초에 new, delete 방식으로 락프리 구조는 불가능하다.
2. 해결해야 할 문제
    1) new, delete 메모리 참조 오류를 해결하기 위해 Decommit 되지 않는 메모리를 사용해야 한다. => 메모리풀을 사용해야 한다.
    2) 메모리풀을 사용한다? 동기화 락을 없애야 한다. => 메모리풀 또한 락프리로 만들어야 한다.
        * 문제가 있어 보인다. 메모리풀 또한 스택 방식이다.
    3) 우리가 작성한 메모리풀은 현재 작성한 Stack(new, delete를 이용한)과 달리 락프리 구조가 가능하다. 그 이유는?
        * Template 클래스 작성 시 Stack과 메모리풀은 DATA를
        * Stack은 데이터를 기준으로 pop과 push가 이루지는 반면 메모리풀은 Node*을 전달한다. 즉, 메모리 주소 값을 기준으로 Alloc, Free가 이루어진다.

## 기타
### 과제
1. 프로그램 완성 절차
    1) 메모리풀을 사용하지 않고 메모리 참조, new, delete 오류에 대한 로깅과 추적 사항을 모두 기록하여 자료 남기기(delete로 인한 문제, Decommit 참조 문제)
    2) 메모리풀을 락프리로 구현하는 과정 중 나타나는 단 한 건의 문제를 디버깅하기(메모리 크러시는 나지 않을 것이다. 따라서 동작 오류 등을 살펴보기)
2. 락프리 스택 디버깅 자료 강사님께 이메일로 제출하기(로그로 남겨 시나리오를 작성하라!)
    1) 이렇게 이렇게 해서 상황이 되서 이게 지워졌다. 그래서 이 자리에서 메모리 참조 오류가 발생하였다.

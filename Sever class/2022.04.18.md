# 2022/04/18 수업내용
## 테스트 프로그램
### 스트레스 테스트
1. 테스트 목적: 스트레스 테스트는 서버가 정상적인 동작을 하는지는 알기 어렵다. 지정된 접속 및 메시지(과도한 부하를 쏟아부어)를 보내서 부하 정도 및 버그(반응)를 파악하는 용도의 테스트이다.

### 더미(봇) 테스트
1. 목적: 스트레스 테스트보다 더 나아가 컨텐츠, 플레이어를 포함하여 테스트하는 것. 즉, 서비스를 위하여 실질적인 테스트를 하는 것이다.
    * 동시 접속자에 대한 예측, 컨텐츠 버그, 네트워크 지연에 대한 실질적인 부분은 테스트한다.
2. 실제 테스트
    1) AI를 삽입하여 실제 플레이어가 접속한 것같은 유사한 환경을 만들어 진행
    2) 유저 DB, 로그인 등의 서버와 연동 또한 포함하여 테스트한다. 또한 컨텐츠에 따라서 타 서버들과 연동이 되어야 하는데 다른 서버(특히 DB)들의 성능이 좋지않으면 게임서버가 아무리 빠르다한들 성능이 나올 수 없다. (ex: 퍼블리셔가 붙는다면 로그인 웹쪽과도 연동이 되어야함)
    3) 일반적으로 예측 부하의 150% 정도를 테스트한다. 또한 프로세스 당 1천명 분의 플레이어 더미를 담당한다.
    4) 거의 대부분 라이브 되고 있는 게임에서 추가되는 컨텐츠에 대하여 더미 테스트를 진행하지 못한다. 이미 완성된 더미 테스트 프로그램을 손대지 못하기 때문이다.(?!) 그러다보니 추가된 컨텐츠에 대해서 기획이나 QA팀에서 플레이해보고 됐다하고 넘어감
        * 하지만 이런게 쌓이고 쌓이다보면 부담이 커져 동접수를 줄이는 방향으로 가게된다.(메모리 up, 로직 복잡도 up)
3. MMORPG는 위에서 언급한 조건으로 더미를 만드는 것은 컨텐츠가 너무 방대하다.
    1) 예를 들어 거래 시스템의 경우 모든 경우의 수에 대하여 테스트하기가 불가능하다.
4. 보통 한 프로세스에서 1천명 분의 플레이어 더미를 담당해야 한다.
5. 네트워크 트래픽
    1) 네트워크 인프라, 서버 하드웨어, 회선 비용등을 통계를 내어 퍼블리셔에게 제공해야 한다. 보통 퍼블리셔는 서버 장애 탓을 개발사에게 돌리고 싶어 한다.
        * 제대로 하려면 RAM, 메인 보드 등 까지 결정해야 한다. 하지만 보통 벤더의 완성품을 구매하여 사용한다. 조립은 쓰지 않는다. (보통 스펙에 대한 얘기를 할 때 메모리, 클럭, 코어 개수 등의 언급)
    2) Stateless 게임에서는 애초에 연결이라는 개념이 없기 때문에 동접이란 개념이 없다. 그래서 Stateless에서는 TPS(초당 최소한 몇 건의 몇 명을 처리하느냐)를 기준으로 성능을 측정한다. 보통 퍼블리셔에서 개발사에게 일정 TPS를 요구한다. 이때 개발사에서 할 일은 적절한 컨텐츠 몇가지를 뽑아서 이에 대응되는 테스트 툴과 같이 퍼블리셔에 제공하여 TPS 측정 테스트 요청을 한다.
        * 또한 퍼블리셔는 보통 DB와 연동되는 부분들을 다 달라고 했다 연관된 것들을 요구할 수 있다. DB에서 진행되는 Query를 요구한다. 퍼블리셔는 보통 대규모 데이터를 다룰 수 있기도 하고 개발사를 못 믿어서 요구하는 것도 있다. 이것은 퍼블리셔가 게임 개발에 도움을 주는 목적이기 때문에 안내줄 이유가 없다.
    3) 네트워크 트래픽 산출 방법
        * 실제 send를 하여 반환된 바이트 수 합계
        * IP, TCP 헤더 크기 측정: 실제 send 요청 횟수 합계 * 40bytes (send 요청 크기가 MSS를 초과한 경우에 그에 상응하게 추가하여 계산)
        * 예시: 듀랑고-모닥불(클베 때 이 컨텐츠를 빼버림)
        * 그래서 우리가 계산한 예상 수치와 실제 이더넷에서 나간 수치를 합하여 1/2한 값으로 트래픽을 예상할 것이다. 이 값을 기반으로 한 서버당 라인 초당 xBit면 되겠다 로 결론내어야 한다.
        * 예측 트래픽이 1Gbit 이상이 나오면 비용이 너무 많이 든다. 이때는 프로토콜을 수정하여 트래픽 감소를 시키든가해서 줄여야한다.
6. 모니터링 정보
    1) 목적: 플레이어들이 무엇을 하는지 최소한의 알 방법이 필요하다.
    2) 매치메이킹, 경매장, 배틀 등의 영역을 나누어 비 정상적인 유저 수, 접속한 유저 수, 대기 유저, 플레이 유저 수 등의 모니터링 정보가 있어야 한다.
    3) 송수신에 대한 레이턴시 값: 평균치를 계산하고 최소, 최대 값을 같이 구해야 한다.

### 기타
1. 테스트 프로그램은 오류가 0이어야 한다. 그래서 강사님은 보통 싱글스레드로 제작한다.
2. NC에서는 리니지 이터널 제작 시에 클라 오토를 만들어 QA를 진행하였다.
    * 클라 오토의 목적은 컨텐츠 오류 및 서버 부하를 측정하는데 목적이 있다.
3. 리플레이 기능 구현
    1) 프레임을 기준으로 메시지를 처리하여 구현할 수 있다. 모든 연산자 계산 순서 등도 모두 동일해야 가능하기 때문이다.(락스텝: 모든 유저가 프레임을 동기화하고 Input을 공유한다)
        * 오버워치의 경우 리플레이가 정확히 유저가 했던 행동과 일치하지 않는다. 얘네들은 키 프레임을 잡아 결과만 동일하게끔 리플레이를 구현하였다. 
4. 더미 테스트의 또 다른 목적은 추가된 컨텐츠가 있을 때 기존 컨텐츠에 영향이 있는지에 대한 부분을 보는 것도 있다.

## 스레드 프로그래밍
### 선점과 비선점
1. 기준: 스레드를 중간에 중단될 수 있느냐 없느냐!
2. 모든 OS는 선점형이어야 한다. 만약 무한 루프 스레드가 있는 경우 멀티스레드 불가능

### 유저와 커널 스레드
1. 유저 스레드
    1) OS가 개입하지 않는 유저 스레드
    2) 유저 스레드는 병렬로 실행되지 않는다. 유저 스레드는 별도의 스택이 제공되지만 개별적으로 코어를 할당받아 병렬적으로 처리되지 않는다.
    3) 유저 스레드는 무조건 비선점형이다. 그래서 나온 개념이 일드이다. 코드 단에서 일드를 하고 다른 스레드에게 실행 권한을 양도해주어야 한다.
    * C++ 2020에서는 윈도우 API 퐈이버를 제공한다.
    * 일드: 유저 스레드에서는 일드를 하여 현재 동작을 중지시키고 다른 스레드를 동작시키러 간다.
2. 커널 스레드
    1) OS가 개입하여 스레드를 병렬적으로 수행하는 스레드

### 프로세스
1. 콜스택
    1) 콜스택은 따로 저장되어 있는 형태가 아니라 실시간으로 스택을 분석하여 결과를 산출한다. 
2. CPU 상태: 레지스테 Set을 의미한다. 엄밀히 따지면 스택 정보도 CPU 상태에 포함이 된다.
    * 64bit에서는 위험하다는 이유로 inline 어셈을 막아놨다. 32bit에서는 가능
    * 스레드 컨텍스트 블록: 특정 스레드가 가지고 있는 CPU 상태. 각 스레드마다 현재 스레드 진행 상태를 의미한다.
3. 각 프로세스는 가상메모리 테이블(=프로세스가 가지고 있는 메모리 정보)을 커널 메모리 영역에 저장하고 있다. 이 테이블은 구조체처럼 덩어리이다.

### 멀티 스레드
1. 사용 목적
    1) 성능
    2) 사용자 응답성 개선: 게임 로딩 모래시계
    3) 프로그램 구조적인 개선: 기능들의 분리, 무한 루프 등의 문제 해결
    4) 스레드를 설계할 때는 현재 내가 설계한 것과 딱 맞아떨어지는 CPU가 나와야 한다. 스레드가 돌아갈 코어가 부족하다면 오히려 성능이 굉장히 떨어질 수 있다.

## 기타 키워드
### 퍼블리셔
1. 리텐션: 광고 대비 돌아오는 유저 수
2. 요즘 개발사는 보통 퍼블리셔와 계약하여 게임을 제작하는 것이 일반적이다.
3. 요즘 퍼블리셔들은 안 될것같은 게임을 펀딩하여...

### 유니티
1. 유니티는 싱글 스레드이다. 유니티에서는 이 싱글 스레드를 코루틴이라 표현한다.

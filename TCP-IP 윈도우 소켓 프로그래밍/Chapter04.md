# Chapter04 TCP 서버-클라이언트
## Section01 TCP 서버-클라이언트 구조
### TCP 서버-클라이언트 개념
1. TCP 서버와 클라이언트의 관계는 웹 서버와 웹 브라우저의 관계가 대표적인 사례이다.

### TCP 서버-클라이언트 동작 원리
1. TCP 서버-클라이언트 동작 절차
    1) listen: 서버가 소켓을 생성한 후 클라이언트 접속을 기다림
    2) accept + connect: 클라이언트가 서버에 접속한다. 서버 입장에선 accept, 클라이언트 입장에선 connect 동작이다. 이때 TCP 프로토콜 수준에서 연결 설정을 위한 Frame 교환이 일어난다.(SYN, SYN/ACK, ACK)
    3) send + recv: TCP 프로토콜 수준의 연결 절차가 끝나면, 서버는 접속한 클라이언트와 통신할 수 있는 **새로운 소켓을 생성**한다. 이 소켓을 사용하여 클라이언트와 서버가 데이터를 주고받는다. 기존 소켓은 새로운 클라이언트 접속을 수용하는 용도로 계속 사용된다.
2. 서버 측 소켓과 클라이언트 측 소켓은 1:1로 대응된다. 하지만 하나의 **클라이언트가 N개의 소켓을 사용해** 서버에 접속할 수도 있다.

## Section02 TCP 서버-클라이언트 분석
### 지역과 원격 IP 주소 및 포트 번호
1. 지역 IP와 포트 번호: 서버 또는 클라이언트 **자신의 주소**
2. 원격 IP와 포트 번호: 서버 또는 클라이언트 자신가 통신하는 **상대의 주소**

### TCP 서버 함수
1. 일반적으로 TCP 서버는 다음과 같은 순서로 소켓 함수를 호출한다.
    1) socket(): 소켓을 생성함으로써 사용할 프로토콜 결정
    2) bind(): **지역 IP 주소와 지역 포트 번호**를 결정
    3) listen(): TCP를 LISTRENING 상태로 변경한다.
    4) accept(): 클라이언트가 통신할 수 있는 새로운 소켓을 생성한다. 이때 **원격 IP 주소와 원격 포트 번호**가 결정
    5) send(), recv() 함수로 클라이언트와 데이터 송수신 후 closesocket() 함수로 소켓을 닫음
    6) 이후 4-5 과정을 반복
2. 서버 함수
    <pre><code>
    // bind
    int bind(
        SOCKET         s,       // 클라이언트 접속을 수용할 목적으로 만든 소켓으로, 지역 IP와 포트 번호가 결정되지 않은 상태
        const sockaddr *addr,   // 소켓 주소 구조체를 지역 IP와 포트 번호로 초기화하여 전달한다.
        int            namelen  // 소켓 주소 구조체의 길이
    );
    
    // listen
    int WSAAPI listen(
        SOCKET s,       // 클라이언트 접속을 수용할 목적으로 만든 소켓으로, bind 함수로 지역 IP와 포트 번호가 결정된 상태
        int    backlog  // 서버가 당장 처리하지 않더라도 접속 가능한 클라이언트의 개수. 클라이언트 접속 정보는 연결 큐에 저장되는데,
                        // backlog는 이 큐의 길이를 나타낸다. 최댓 값 SOMAXCONN(2GB)
    );

    // accept
    // accept 함수는 접속한 클라이언트와 통신하도록 새로운 소켓을 생성하여 반환한다.
    // accept 함수는 접속 클라이언트가 없다면 서버를 대기 상태로 만든다. 이때 CPU 사용률이 0이 된다.(쓰레드의 상태가 blocked 상태?!)
    SOCKET WSAAPI accept(
        SOCKET   s,         // listen 함수로 LISTENING 상태가 된 소켓
        sockaddr *addr,     // 접속한 클라이언트의 주소 정보로 채워짐
        int      *addrlen   // 호출 시에는 addr이 가리키는 구조체의 크기로 전달해야하며, 함수 리턴 시에는 accept가 채워넣은 주소 정보 크기를 갖게 된다.
    );
    * 클라이언트의 IP주소와 포트 번호를 알 필요가 없다면 addr, addrlen에 NULL 전달
    </code></pre>

### TCP 클라이언트 함수
1. 일반적으로 TCP 클라리언트는 다음과 같은 순서로 소켓 함수를 호출한다.
    1) socket(): 소켓 생성 및 프로토콜이 결정된다.
    2) connect(): 원격-지역 IP 주소와 포트 번호가 결정된다.
    3) send(), recv() 함수로 클라이언트와 데이터 송수신 후 closesocket() 함수로 소켓을 닫음
2. 클라이언트 함수
    <pre><code>
    // connect 함수
    int WSAAPI connect(
        SOCKET         s,       // 서버와 통신할 소켓
        const sockaddr *name,   // 서버측의 소켓 주소 구조체를 초기화하여 전달
        int            namelen  // 소켓 주소 구조체의 길이
    );
    </code></pre>

### TCP 데이터 전송 함수
1. 소켓 주소 구조체에는 지역/원격 주소 정보 이외에 데이터 송수신 버퍼가 있는데 이를 **소켓 버퍼**라 부른다.
    * 송신 버퍼는 **데이터를 전송하기 전**에 임시로 저장해두는 공간이고, 수신 버퍼는 받은 데이터를 **응용 프로그램이 처리**하기 전까지 임시로 저장해두는 공간이다.
2. TCP 서버-클라이언트를 작성할 때는 데이터 경계 구분을 위한 상호 약속이 응용 프로그램 수준에서 필요하다.
    * 예를 들어, 클라가 100, 200, 300 바이트 데이터를 차럐ㅖ로 보낼 경우 서버가 데이터의 경게를 구분하지 못하고 250, 350 바이트 데이터를 읽을 수 있다.
3. send 함수
    1) 기능: 응용 프로그램 데이터를 OS의 송신 소켓 버퍼에 복사함으로써 데이터를 전송한다. 소켓 버퍼로의 데이터 복사가 성공하면 곧바로 리턴한다. 따라서 함수가 리턴되었다고해서 실제 데이터가 전송된 것은 아니며, 하부 프로토콜 처리까지 완료되어야 전송이 완료된다.
    2) 함수 구조
    <pre><code>
    int WSAAPI send(
        SOCKET     s,       // 서버와 연결된 소켓
        const char *buf,    // 전송할 데이터 버퍼
        int        len,     // 버퍼 길이
        int        flags    // 함수의 동작을 바꾸는 옵션으로, 대부분 0을 사용한다.
    );
    * send 함수는 SOCKET 인자로 전달되는 소켓의 특성(블로킹, 넌블로킹)에 따라 두 가지 방식으로 리턴하게 된다.
    * 블로킹 소켓: 송신 소켓 버퍼의 여유 공간이 세 번째 인자 len보다 작은 경우 해당 스레드는 blocking 상태가 된다. 같거나 큰 경우 함수는 len을 리턴한다.
    * 넌블로킹 소켓: 
    </code></pre>

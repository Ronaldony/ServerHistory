# 2022/05/04 수업내용
## 동기화
### 크리티컬 섹션
1. 어셈블리 분석
    1) gs 세그먼트가 등장하는 경우 스레드 정보에 접근한다고 가정을 하고 분석을 진행해야 한다. 대부분 스레드 ID에 접근
    2) Syscall, wow64 명령어 진입 시 커널 모드 진입이다.
    3) lock bts: 인터락 비교 명령어
2. 현재 크리티컬 섹션은 WaitOnAddress를 Wrapping한 것이다. 예전에는 커널 동기화 객체를 Wrapping하여 사용하였기 때문에 DeleteCriticalSection이 있는 것이다.

### 유저 동기화 객체
1. 유저 동기화 객체가 커널 동기화 객체와 다른 유일한 점: 경합이 일어나지 않았을 때 혹은 스핀락 범위 내 소유권을 확인하는 절차를 유저 모드에서 검사하는 것이다!!!!! 꼭 ㄱ!
2. 윈도우 7에서는 완벽환 유저 동기화 객체를 만들기 위해서 크리티컬 섹션에 Kid event(물론 지금은 WaitOnAddress)를, SRWLock에는 SpinLock을 도입하였다. 윈도우 8에서는 크리티컬 섹션에도 SpinLock을 도입하였다.
3. 유저 동기화 객체의 변천사를 확실히 기억할 것!
    1) 윈도우7 까지는 완벽한 유저 동기화 객체가 없었다.(물론, Kid Event가 있었지만..) 유저 동기화 객체인 SRWLock과 크리티컬 섹션이 내부적으로 커널 동기화 객체를 생성하여 스레드를 Block으로 전환하였다.
    2) 윈도우8 부터 WaitOnAddress가 도입되어 완벽한 유저 동기화 객체가 되었다. 자원의 경합 검사부터 WaitOnAddress를 이용한 동기화 동작까지 유저 모드에서 실행된다. 물론 스레드가 Block이 되는 과정은 커널 모드로 진입해야 한다.

### 멀티스레드
1. 동기화 접근
    1) 일반적인 접근: 동기화가 필요한 요소(세션, 캐릭터 정보 등)에 동기화 객체를 포함시켜 요소에 진입할 때마다 Lock, Unlock 동작을 수행한다. 사람들은 느린 동작으로 인해 Lock, Unlock 수행 자체를 거부하는 성향이 있다. 단지 Lock, Unlock 수행에 대해서만 초점이 집중되어 있다.
    2) 커널 동기화 객체를 쓰지 않은 경우: Interlocked을 사용하는 방법밖에 없다. 현재 유저 동기화 객체들도 InterLocked을 사용하여 구현된다.
    3) 우리의 접근1: 단순히 InterLocked 혹은 동기화 객체의 Lock과 Unlock 진입 횟수가 중요한 관점이 아니다. 경합의 확률(빈도)을 보는 것이 포인트이다. 만약 1/5000 혹은 1/10000 확률이라면 성능에 영향이 없다.
        * 예를 들어 두 스레드 이상이 유저 세션에 대한 접근을 시도 중이다. 유저 세션이 1개라면 경합이 일어날 확률은 높지만, 유저 세션이 100개 1000개가 된다면 경합은 굉장히 낮은 확률로 일어날 것이다. 이 점을 고민해보아야 하는 포인트이다.
2. 경합 발생 시 우리가 할 수 있는 동작
    1) 우리의 접근1: 경합이 일어나는 순간 다른 일을 하러 빠지는 것
    2) 우리의 접근2: 공유 자원에 대한 접근에 목적을 명확히 명시한 상태에서 접근하는 것이다. 만약 다른 스레드들이 읽기로만 접근하고 있다면 같이 접근. 만약 자원에 대한 접근이 삭제, 변경 시 Lock => SRWLock의 방식이다.
3. 워커 스레드를 만들 때는 종료 방법에 대한 설계도 이루어져야 한다. (예를 들어 이벤트 오브젝트를 Signaled로 바꾸고 대기 상태로 바꾸는..)

### 스핀락
1. 스핀락은 퀀텀 타임을 모두 소비해서라도 원하는 목적을 이루는 것이다. 따라서 YieldProcessor가 아닌 Sleep(0)을 이용한 스핀락은 절대!절대! 스핀락이라고 말할 수 없다.

### WaitOnAddress
1. WaitOnAddress는 동기화 객체 없이, 등록된 주소를 기다리는 스레드가 누구인지를 가지고 동기화를 수행한다. 다른 쪽에서는 해당 주소를 기다리는 스레드를 깨워주는 동작을 수행한다.
2. NtWaitForAlertByThreadId: WaitOnAddress의 내부 방식이다. 해당 스레드 ID로서 마냥 Block 상태에 진입한다. 때문에 데드락에 걸리면 영원히 깨어날 수 없다.

### SRWLock
1. 특징 및 구조
    1) 만약 검색만을 위한 접근이라면 Shared로 할 수 있지만, 검색을 한 후 변경하는 경우라면 Exclusive를 사용해야 한다.
    2) SRWLock은 객체가 아니다. 구조체 형태로 주소값을 저장하는 PTR 하나로 구조되어 있다.
    3) 이 친구도 크리티컬 섹션과 같이 완전한 유저 동기화 방법이다. 내부적으로 WaitOnAddress를 사용하여 동기화한다. 다만 다른점은 스레드 ID를 확인하지 않는다.
2. 크리티컬 섹션과의 성능 차이
    1) 실제로 어셈블리를 분석해보면 크리티컬 섹션보다 더 가볍다. 
    * 따라서, 동기화 객체를 선택할 때 가장 먼저 SRWLock이 선택되어야 한다. 만약 재귀적으로 동기화 객체가 사용되는 상황이라면 가장 먼저 구조를 바꾸어야 한다. 만약 되지 않는다면 CriticalSection으로 전환시켜야 한다.

### 이벤트
1. 사용처
    1) 보통 이벤트는 공유 자원에 대한 베타적인 접근을 해결하려고 사용하는 것이 아닌 스레드 제어 목적으로 사용된다.
    2) 위 방법을 응용하여 워커 스레드 풀을 구현해볼 수 있다.
2. 제어 스레드-워커 스레드의 구조라면, 두 스레드 사이에는 큐를 통해 일을 전달 혹은 수신해야한다.

### 기타
1. 워커 스레드가 돌아가고 있는 상태에서 main 문이 다른 스레드들의 종료 확인 없이 종료가 먼저 이루어지면 전역, 정적 객체에 대한 메모리 크래시가 생길 수 있다.
    * 주의할 점: 우리는 동적 할당, 스레드 메모리를 걱정하는 것이다. 이는 모두 프로세스가 종료되면서 정리가 된다. 우리가 걱정하는 것은 스레드의 못마친 '일'과 종료 시 남게되는 '메모리 덤프'이다.

## 기타 키워드
### 스핀락 테스트
1. 프로파일로는 성능 측정이 힘드니 일정 시간 내에 진입 성공 횟수를 기준으로 대략적인 성능을 측정할 수 있다.

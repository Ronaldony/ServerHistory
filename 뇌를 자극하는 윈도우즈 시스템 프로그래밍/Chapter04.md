# Chapter04
## Section01 컴퓨터 구조의 접근방법
* 해당 섹션에서는 독자들의 컴퓨터 구조에 대한 이해를 위해서 CPU의 레지스터에 대한 디자인을 제안한다. 시스템 프로그래머 입장에서 CPU의 특성을 바라볼 때, 대부분 레지스터에 집중되기 때문에 저자는 CPU 요소 중에서도 레지스터에 대한 디자인을 제안하였다.
### 레지스터를 디자인하자
1. 레지스터 디자인 시 결정해야 할 중요 요소
    1) 레지스터의 비트 수
    2) 레지스터의 개수
    3) 레지스터의 용도
2. 본 책에서는 레지스터의 비트 수는 16비트, 개수는 8개(r0~r7, 0~7)로 구성한다. 다음은 레지스터 요소를 반영한 레지스터 세트이다.

    <img width="250" src="https://user-images.githubusercontent.com/95362065/145661735-1fc446db-cb13-411d-a414-b38d2653e3da.png" >

### 명령어 구조 및 명령어를 디자인하자
1. 레지스터와 명령어의 상관 관계: CPU 구성형태(레지스터 구성형태)에 따라 명령어의 구조도 달라진다. 여기서 말하는 명령어는 어셈블리 명령어이다.
    1) 때문에 어셈블리어로 프로그램을 하면 다른 CPU에서 해당 프로그램을 실행할 수 없다.
2. 레지스터 16비트에 효율적인 구성을 위한 구조는 명령에 사용되는 정보들이 최대한 포함되는 것이 좋다. 덧셈의 경우에도 연산자(덧셈), 피연산자1(덧셈의 대상, 최소 2개), 피연산자2(결과) 최소 4가지의 정보가 있어야 한다. 따라서, 다음과 같이 구성할 수 있다.

    <img width="400" src="https://user-images.githubusercontent.com/95362065/145661829-6966b043-f091-4198-9cc7-bf7688c2761d.png">

3. 사칙연산에 대한 심볼과 코드

    |연산의 의미|심볼|2진 코드|
    |------|---|---|
    |덧셈|ADD|001|
    |뺄셈|SUB|010|
    |곱셈|MUL|011|
    |나눗셈|DIV|100|
        
4. 각각의 레지스터를 나타내는 2진 코드의 구성

    |레지스터 심볼|2진 코드|
    |----|---|
    |r0|000|
    |r1|001|
    |r2|010|
    |r3|011|
    |r4|100|
    |r5|101|
    |r6|110|
    |r7|111|
    
5. 피연산자
        * 레지스터&레지스터, 레지스터&숫자, 숫자&숫자 이렇게 3가지 경우의 수가 나온다. 따라서, 피연산자의 비트 1자리를 레지스터인지 숫자인지 구별하는 자리가 필요하다. (레지스터를 1, 숫자를 0으로 표시하자)
6. 명령어 예시: ADD r2, r1, 5
        
    <img width="400" src="https://user-images.githubusercontent.com/95362065/145681211-6157a41b-308c-421e-9eaa-0e4d804f641a.png">

7. 인텔의 x86, x64 계열에서 "연산결과는 일단 레지스터에 저장되어야 한다"라는 제약사항이 있다. 이는 RISC(Reduced instruction set computer) 구조를 따르기 때문이다. (인텔 16비트까지는 CISC구조를 따랐다고 한다.)

## Section02 LOAD & STORE 명령어 디자인
### LOAD & STORE 명령어의 필요성
1. 앞서 저자가 디자인한 명령어에는 "연산결과를 레지스터에만 저장"과 "피연산자 자리에는 숫자 혹은 레지스터"라는 제약을 걸어둔다. 때문에 다음과 같은 연산은 할수 없다.

    <pre><code>
    int a = 10; // 0x10번지 할당
    int b = 20; // 0x20번지 할당
    int c = 0;  // 0x30번지 할당
    c = a + b;  // "0x10 번지에 저장된 값과 0x20번지에 저장된 값을 더하여 0x30번지에 저장하라"
    </code></pre>
        
2.  위 연산이 가능하기 위해서는 메인 메모리에서 x번지에 저장된 데이터를 레지스터로 가져오는 명령어(LOAD)와 레지스터 데이터를 x번지에 저장시키는 명령어(STORE)가 필요하다.
### LOAD & STORE 명령어의 디자인
1. 명령어 LOAD

    <img width="400" src="https://user-images.githubusercontent.com/95362065/145683045-02013e59-e0a3-4a0d-84db-3b84d3adfa71.png">

2. 명령어 STORE

    <img width="400" src="https://user-images.githubusercontent.com/95362065/145683242-8b9cd4f7-8143-4102-94bd-42ae53318e26.png">
        
3. 앞서 언급한 연산은 LOAD와 STORE를 사용하여 다음과 같이 해결된다. 

    <pre><code>
    int a = 10; // 0x10번지 할당
    int b = 20; // 0x20번지 할당
    int c = 0;  // 0x30번지 할당
    c = a + b;  // "0x10 번지에 저장된 값과 0x20번지에 저장된 값을 더하여 0x30번지에 저장하라"

    LOAD r1, 0x10
    LOAD r2, 0x20
    MOV r3, r1, r2
    STORE r3, 0x30
    </code></pre>
        
## Section03 Direct 모드와 Indirect 모드
### Direct 모드의 문제점과 Indirect 모드의 제안
1. 앞서 디자인한 LOAD와 STORE 명령어에서 메모리 번지가 들어가는 8비트 자리에 0xFF 주소까지밖에 표현하지 못한다.

### Indirect 모드의 이해
1. LOAD, STORE 명령어에서 지정하는 메모리 번지에 저장된 값을 주소 값으로 참조하는 것이다.

    <img width="400" src="https://user-images.githubusercontent.com/95362065/145684168-2c6bf968-882e-48cb-8288-f35d9b9338c9.png">
    
2. 문제점: LOAD와 STORE에서 Indirect Mode를 사용해야한다는 표현이 필요하게 된다.
    * 이 문제는 앞서 디자인한 LOAD, STORE 명령어 사용되지 않은 앞 2비트 예약비트를 사용하면 해결된다. (값은 자유 지정)

# 2022/07/06 수업내용
# 락프리 큐
## 디버깅
### 문제
1. 문제1: 중복된 값을 DeQ해주는 상황
    1) 문제 과정
        * 1: A 스레드 - DeQ에서 Head 교체 후 스레드 멈춤
        * 2: B 스레드 - A 스레드에서 Head->next로 갖고 있던 노드를 EnQ, DeQ 작업 반복하다 새로운 데이터로 EnQ를 하고 스레드를 멈춘다.
        * 3: A 스레드 - 지역 Head->next에서 data를 가져오는데 B 스레드에서 입력한 Data를 DeQ 해준다.
        * 4: 이후 DeQ 동작 때 3에서 사용된 Data가 중복되어 DeQ 된다.
    2) 해결 방법: Head를 교체하기 전에 DeQ할 Data를 미리 저장함. 하지만 이 방법은 성능이 떨어진다. 특히 대상이 객체라면 더더욱, 그러나 객체가 Q의 대상인 것 자체가 잘못된 것이다.
2. 문제2: EnQ 내부에서 tail->next(CAS 1번)는 교체하였는데 tail(CAS 2번)을 교체하지 못한 상황. 이후 다음 번 EnQ 작업 시 무한루프를 돌게되는 상황
    1) 문제 과정
        * 1: A 스레드 - 지역 tail을 저장 후 멈춤
        * 2: B 스레드 - EnQ와 DeQ 동작을 반복하며 tail의 값이 바뀌다가 A 스레드가 가진 tail 노드가 tail이 됨. 직후 멈춤. 이때 tail->next가 Null 인 상황이 됨
        * 3: A 스레드 - 지역 next에 tail->next를 저장하고 CAS 1번을 통과함
        * 4: A 스레드 - CAS 2번을 하려하지만 앞서 알던 tail이 아니기 때문에 작업에 실패함
        * 5: 이후 EnQ에서 무한 루프를 도는 상황은 아래 상황1과 상황2, 2가지로 나누어진다.
    2) 상황1: tail을 교체하는 것에 실패한 스레드의 다음 동작이 EnQ인 경우, 해당 스레드와 다른 EnQ 스레들이 무한루프를 돌게 된다.
    3) 상황2: tail을 교체하는 것에 실패한 스레드의 다음 동작이 DeQ인 경우, 해당 스레드가 DeQ 작업을 하고 다시 EnQ 작업에 들어갔을 때 Head와 Tail이 역전되는 상황이다.
    4) 해결 방법: 특정 스레드가 CAS 1번을 성공하고 CAS 2번에 실패하였을 때 다른 스레드가 CAS 1번을 기다리지 않고 바로 CAS 2번을 해버린다. 그러나 역설적이게도 이로 인해 또 다른 비슷한 유형의 문제2가 발생한다. 하지만 이것은 우리의 해결 대상이 아니다. 그저 문제가 발생하였을 때 어떤 동작으로 인해 발생된 것인지 분명히 하기 위한 것이다.
        * 이 방법은 스핀락과 락프리를 나누는 큰 기준이 된다. 락프리는 로직 차원에서도 아예 기다리지 않는 것이다.
3. 문제3: Size가 0보다 커서 DeQ 작업에 들어갔는데 Head->next가 NULL인 상황
    1) 앞선 수업에서 우리는 큐가 비어있는가를 Head->next가 Null인지가 아니라 Size로 판단하자고 약속하였다.
        * 만약 Head->next가 null인지 아닌지로 큐가 비어있는지를 판단하게 된다면 EnQ에서 tail->next만 교체하였는데 해당 노드에 대하여 DeQ 작업이 될 수 있다. 이때 Head와 Tail이 역전되는 상황이 발생한다.
    2) 첫 번째 접근 방법: DeQ 진입 시 먼저 Size를 감소시키고 Interlocked 결과가 0보다 크거나 같은 경우에 DeQ 작업을 진행한다.
        * 이 작업을 적용시켜도 DeQ 작업 내부에서 head->next가 Null 인 상황이 벌어진다. 이 상황은 사실 문제2와 관련된 문제이다.

## 락프리 큐
### 동작
1. 락프리에서는 EnQ, DeQ에 실패하는 경우가 없게 만들것이다. 애초에 락프리에서 실패한다는 것 자체가 말이 안 되기 때문이다.
2. 스핀락은 애초에 멈추기 때문에 상대방의 로직도 기다려주는 상황이 된다. 하지만 락프리는 상대방의 로직을 기다려주지 않는다. 즉 락프리보다 더 급한 성격이다.

### 테스트
1. 동기화 객체와 스핀락, 락프리의 비교
    1) 만약 컨텍스트 스위칭 등 외부적인 비용을 모두 제외한다면 모두 동일한 시간 내에 동일한 횟수가 이루어져야 한다.
2. 테스트의 기준
    1) 정해진 시간 내 EnQ, DeQ 횟수: 이 건에 대해서는 정확한 판단이 이루어질 수 없다. 그 이유는 앞서 말한 동기화, 스핀락, 락프리의 비교에서
    2) 테스트의 기준을 정할 때 락프리의 목적을 기준으로 생각해보아야 한다. 퀀텀 타임을 포기하지 않고 가장 먼저 성공하는 놈이 제일 앞서가는 것이다.
        * 스핀락: 퀀텀 타임 포기하지 않고, 다른 쪽의 로직을 기다릴게.
        * 동기화: 퀀텀 타임 포기하고, 대기 상태로 들어갈게.
        * 락프리: 퀀텀 타임도 포기하지 않고, 일단 내 로직을 돌릴게.

## 포트폴리오
### 작성
1. 총 10 페이지 정도로 작성될 것이다.
2. 락프리 스택의  대한 기본 ABA 문제는 포트폴리오에 넣지 않음
2. 락프리 큐의 EnQ의 CAS 실패 건에 대해서만 작성할 것이다.

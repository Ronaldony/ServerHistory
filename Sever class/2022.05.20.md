# 2022/05/20 수업내용
## 멀티 스레드
### 멀티 스레드 설계(IOCP x, 게임 )
1. 길 찾기를 멀티 스레드로 가져가는 경우(이전 시간에 이은 논의)
    1) 만약 길 찾기 스레드의 requst 큐가 스레드마다 있을 때
        * 단점: 게임 로직 스레드가 request 큐에 넣을때마다 어떤 길찾기 스레드의 큐에 넣을지 Dispatching을 해주어야 한다. 이는 윈도우 10 이전 레디큐와 같은 구조이다. 그래서 10부터는 코어들을 그룹으로 나누어 레디큐를 관리하게 된 것이다.
        * 위 단점으로 인해 길 찾기의 스레드가 몇개이든 request 큐를 하나만 가져가야 한다.
2. 네트워크 IO와 게임 로직 스레드를 호모 지니어스 형태의 멀티 스레드인 경우
    1) 게임 로직<->네트워크 IO 사이 request 큐가 하나인 경우: request 큐가 하나라면 게임 로직에서 일을 무작위로 가져가기 때문에 같은 세션에 대한 로직 처리 완료 순서가 보장되지 못한다. 
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169540816-28bb635c-f308-4412-8de2-599f90b3d5d3.png">
    2) 게임 로직<->네트워크 IO 사이 request 큐가 각각 있는 경우: 네트워크 IO에서 각각의 request 큐들에 정해진 세션에 대한 정보를 전달하고 이를 처리하는 형태
        * Request 큐에 세션 정보를 배치할 때 라운드 로빈, 큐 부하 측정 후 분배 등을 선택할 수 있다. 그러나 최초 배정 이후에 해당 세션 메시지가 들어올 때마다 매번 어느 Request 큐로 넣을지 판단하는 과정이 들어가게 된다. 이러한 판단 과정을 Hashtable 형태든 어떠한 관리 구조가 또 나와야 한다.
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/169542185-97e74fc2-0c10-4a57-8e50-b0d6a13828ae.png">
3. 스레드는 Block이 걸려야하는 상황이 된다면 걸려야 한다. 우리가 항상 고민해야 하는 것은 CPU가 놀지 못하게 그동안 다른 일들을 처리하는 것이다.

### 호모 지니어스와 헤테로 지니어스
1. 헤테로 구조라면 데이터 경합이 일어나지 않도록 리소스를 생성하고 사용하는 것이 좋은 설계이다.
2. 호모 구조라면 데이터 경합의 빈도 측정과 경합이 최소화 하는 것을 고민해야 한다.

### 멀티 스레드와 컨텐츠 요소
1. 이 절에서는 위에서 언급한 네트워크 IO와 게임 로직이 호모 지니어스 형태의 멀티 스레드 설계가 되어있는 상황을 가정한다.
2. 컨텐츠 요소인 맵, 필드, 던전 등의 공유 자원을 사용하는 상황
    1) 던전, 필드 등은 해당 인근 또는 인스턴스 던전 안에 있는 유저들 끼리만 동기화에 대한 영향을 받으므로 동기화 락 단위를 던전, 필드, 맵으로 가져가 통째로 써버려야 한다.
    2) 만약 유저가 1000명 이상 + 게임 로직 스레드가 10개 + 던전 스레드가 500개라면? 경합의 빈도는 굉장히 적을 것이다. 그러나 던전 스레드가 50개로 줄어든다면 경합은 높아질 것이다. 이런 경우 반대로 게임 로직 스레드를 늘려 다른 세션의 처리를 좀 더 분포시켜 CPU가 놀지 못하게하는 방법을 택할 수 있다.
        * 게임 로직 스레드를 늘림으로서 발생할 수 있는 문제점: 컨텍스트 스위칭의 비용이 증가한다. => 그래서 나온 게 IOCP이다.
    * 애초에 맵, 필드, 던전과 같이 분리되는 요소가 없다. -> 애초에 멀티 스레드로 설계해서는 안되는 구조이다. 컨텐츠 메시지 처리를 멀티 스레드로 설계되는 경우 컨텐츠 리소스 측이 수월하게 분리가 될 것이다 라고 가정하고 설계되는 것이다.
3. 학습 초기 언급했던 옛날에 기능, 지역별 등 물리적으로 서버를 나누는 것은 결국 -> 기능별로 비동기적으로 스레드를 나누어 처리하는 것과 똑같은 개념이다.
    1) 지역별로 나눈다는 것은 똑같은 기능이지만 독립적인 리소스가 나올 수 있는 부분을 뗀 것이다. -> 스레드 설계에서 호모 지니어스 형태이다.
    2) 기능별로 나눈다는 것은 다른 기능들의 독립적인 리소스가 나올 수 있는 부분을 뗀 것 -> 스레드 설계에서의 헤테로 지니어스 형태이다.
    3) 그래서 결국 동기화 락 단위를 던전, 필드, 맵으로 가져가 통째로 써버리는 것과 같다.
4. 동기화는 동기화 객체를 많이 쓰고 Acquire, Leave의 수가 중요한 게 아니다. 경합의 빈도가 중요한 것이다!!

### 프레임 처리
7. 프레임 처리
    1) 프레임을 관리해 줄 스레드가 나와야 한다. 그래서 앞서 언급한 게임 로직 스레드들은 수신 메시지 처리만 하는 스레드들이 되고 실제 프레임 관리 스레드가 전체적인 로직을 맡아야 한다.
        * 만약 프레임 스레드를 분리시키는 경우 각각 맵/던전/필드 등의 기능별로 역할이 정해져 있어야 한다.
8. Network IO 스레드가 Worker 스레드의 request 큐에 넣고 처리하는 것(1번 방법)과 Network IO 스레드가 메시지를 수신하고 바로 처리하는 것(2번 방법)의 차이 또는 문제점
    1) 1번 방법: Network IO보다 게임 로직이 느린 경우 request 큐에 데이터가 쌓일 수 있다. 
    2) 2번 방법: 
        * 강사님은 이 방법을 선호한다. 그 이유는 게임 로직의 처리가 우선이기 때문이다.
    * 그림 추가
    * Worker 스레드는 수신한 메시지를 처리하는 
9. Networkd

### IOCP
1. 효과적인 스레드 풀 관리를 가능하게 해준다. 
2. IOCP에서는 여러 스레드가 하나의 큐에서 일을 가져가는 형태가 된다. 따라서 위에서 언급한 구조는 IOCP에서는 사용할 수 없다.

### 서버의 분리
1. 예전에 했던 지역적, 기능별로 물리적으로 분리를 하는 것은 스레드를 분리하는 것과 같은 모양새이다.

### 계층
1. 최종적으로 네트워크 라이브러리와 게임 서버 계층을 완전히 나눌 것이다. 여기서 네트워크 라이브러리는 OSI 5, 6 계층으로 볼 수 있고 게임 서버는 7계층으로 볼 수 있다.
    * 서로 코드를 알아 낼 수 없고 침범하지 못하게끔 계층을 나눌 것이다.

## 기타 키워드
### IO 바운드, CPU 바운드
1. IO 바운드: IO를 기다리는 시간을 의미한다. IO를 위해 Block이 걸렸다는 것이다. 대표적으로 Network IO가 IO 바운드 덩어리이다.
2. CPU 바운드: CPU를 사용하는 시간을 의미한다. 대표적으로 게임 로직이 CPU 바운드 덩어리이다.
3. IO 바운드와 CPU 바운드 중 어떤 것을 최소한으로 하는 게 중점적으로 보아야 하는가?
    1) 이 질문은
    2) 로직, 스레드 단위로 어떤 것이 중요한 지 
    3) IO 바운드가 많아진다는 것은 많이 논다는 것이다. 이런 스레드들은 많이 있을 이유가 없다.
5. 프레임 스레드, 로직 스레드는 IO 바운드를 제거해야 한다.

# 2022/06/17 수업내용
# 네트워크 라이브러리
## 네트워크 라이브러리 클래스 화
### 컨텐츠와 네트워크 클래스
1. 컨텐츠 입장에서 세션의 관리, 송수신, 연결 끊기 등 네트워크 동작에 대한 신경을 쓰지 않게끔 네트워크 라이브러리를 작성해야 한다.
    1) 네트워크 라이브러리를 L7 아래 계층으로 분리시키는 것이다.
    2) 네트워크 라이브러리를 IOCP로 구현할 것이기 때문에 이벤트 방식이라고 볼 수 있다.
    3) 네트워크 라이브러리 입장에서는 사용자의 컨텐츠가 웹서버, 파일 서버, 게임 서버 등 어떤 녀석인지는 모르는 상태이다.
2. 컨텐츠와 네트워크 라이브러리 사이에서 주고 받아야하는 기능(알고 싶은 것)
    1) 이벤트 방식으로 동작하는 네트워크 라이브러리에서 컨텐츠에 제공되어야 하는 기능들은 다음과 같다.
    2) 라이브러리 -> 컨텐츠 방향: 신규 접속, 메시지 수신, 연결 끊김(시스템 적으로 혹은 외부에서 종료된)
    3) 컨텐츠 -> 라이브러리 방향: 메시지 송신, 끊기 요청
3. 네트워크 라이브러리와 컨텐츠의 교류
    1) 우리가 보통 특정 클래스의 기능을 사용할 때 그 클래스의 멤버 함수를 호출하였다. 그러나 네트워크 라이브러리는 내부에서 스스로 스레드를 생성하여 신규 접속, 메시지 수신, 세션 종료 등의 함수 호출이 내부에서 이루어지고 있다.
        * 신규 접속, 메시지 수신은 네트워크 입장에서만 이루어질 것이고 메시지 송신은 컨텐츠 입장에서 이루어질 것이다. 세션 종료는 둘 다에서 호출될 수 있는 상황이다.
        * 네트워크 라이브러리 클래스가 Accept 스레드, Worker 스레드를 스스로 생성하여 동작하고 있을 것이다.
4. 네트워크 라이브러리가 컨텐츠에게 상태 알림을 주는 방법
    1) 네트워크 라이브러리는 신규 접속, 메시지 수신, 연결 끊김 등의 상태를 컨텐츠쪽에 알려주어야 한다. 
    2) 방법1: 함수 포인터를 이용한 방법이다. 컨텐츠가 네트워크 라이브러리가 가진 함수 포인터에 함수를 등록하여 네트워크 라이브러리가 호출하여 알려주는 형태.
    3) 방법2: 가상 함수를 이용한 방법이다. 컨텐츠 클래스가 네트워크 라이브러리를 상속하여 가상 함수를 오버라이딩하여 호출되는 형태
        * 단점: 교체가 안된다. 역할을 바꿔야하는 상황이 오면 바꿀 수 있는 방법이 없다. 여기서 말하는 역할이란 상황, 조건에 따라 핸들링 해야하는 대상이 달라지는 경우를 말한다.(잘 상상이 안됨)
        * 컨텐츠 입장에서 상황, 조건에 따라 네트워크 라이브러리를 교체를 하던 가상 함수를 변경할 수 있는 방법은 IS-A의 방법이 아닌 HAS-A의 방법으로 가야한다는 의미가 된다.
    4) 방법3: 컨텐츠가 네트워크 라이브러리와 포함 관계(HAS-A)를 갖는 것이다. 따라서, 네트워크 클래스와 컨텐츠 클래스는 네트워크 인터페이스를 상속하여 서로 간에 교류가 이루어진다.
        * 인터페이스 클래스에는 메시지 송수신, 연결 종료, 신규 접속 등의 순수 가상 함수를 두게 된다. (만약 Protection Proxy 구조로 간다면 다를 수 있다. 아래 참고)
        * 이러한 구조에서는 네트워크 클래스에 Attach를 하여 컨텐츠 클래스의 인스턴스(객체)의 주소를 전달해야 한다. 그래야 인터페이스에 있는 함수를 호출하기 때문이다. Dettach를 하여 컨텐츠 클래스를 교체할 수도 있다.
        * 이 구조에서는 네트워크 라이브러리 클래스 하나, 인터페이스 하나, 컨텐츠 클래스 하나 이렇게 총 3개가 나오게 된다.
        * 왜 굳이 이렇게 해야하는 걸까?
            * 첫 번째 이유: 컨텐츠 클래스를 혹은 조건에 의한 동작을 교체하고 싶다.
            * 두 번째 이유: 유사 Protection Proxy 패턴 구조로 설계할 수 있다. 즉 컨텐츠와 네트워크 클래스의 중간에 있는 인터페이스 클래스가 아래와 같이 메시지 수신에 대한 코드를 한 번 감싸서 컨텐츠와 네트워크 중간에서 Dispatching 대리자 역할을 하게 된다. 이로써 컨텐츠 코드가 더 가벼워지고 수월해졌다.
            * 사용자가 등록한 코드에 맞추어 어떤 코드를 생성하는 툴이 있을 때, 예를 들어 RPC는 사용자가 등록한 프로시져 함수를 호출하는 코드까지 생성해주어야 하기 때문에 이러한 구조로 가져갈 수 밖에 없다. (네트워크 라이브러리와 컨텐츠의 계층을 분명히 나뉘어져야하는 상황이다.)
            <pre><code>
            // 인터페이스 클래스에서 메시지 수신 함수를 다음과 같이 정의하여 Contents 입장에서 편하게 만들어 준다.
            switch()                        Contents 처리
            {
                            ->              Proc_1()
                            ->              Proc_2()
                            ...
            }
            * 이러한 구조는 컨텐츠 코드를 가볍게 할 수 있다. 
            </code></pre>
            
### 또 다른 네트워크 라이브러리 구조
1. 흔히 코드의 재사용성을 고려하여 다음과 같은 구조로 네트워크 라이브러리를 작성하는 경우가 있다.
    1) Accept 클래스, Send 클래스 등 기능마다 클래스로 나누어 각 기능마다 인스턴스를 메인이 되는 IOCP 클래스에 Attach하여 사용하게 하는 구조이다.
            

## 서버간 통신모듈
### CLanServer, CLanClient, CNetServer
1. 우리가 만들어야하는  것들
2. CLanServer, CLanClient의 경우 외부에서의 공격이 없는 것으로 간주하여 헤더를 가장 간단하게 만든다.

### 함수
1. OnClientLeave
    1) 소켓 자원이 해제되는 기능을 한다.
2. OnWorkerThreadBegin, On
3. OnError
    1) 사용자에게 소켓 생성 실패 등을 알려주는 역할
4. OnConnectionRequest
    1) White IP 기능을 하는 함수이다. 서버 점검 시 테스트 할 떄 

### 서버간 통신
1. LAN 환경에서도 생각보다 트래픽이 크다.
    * 서버간 연결이 생긴다면 트래픽이 굉장히 


### 기타 키워드
1. 각 기능마다 attach, dettach 등을 라이브러리 사용자 입장에서 등록하게끔 하여 
2. 너무 많은 기능을 클래스에 포함시키면 사용자는 오히려 더 어케해야될 지 모른다.

# 2022/04/27 수업내용(복습 완료)
## 인터럽트
### 코어와 인터럽트
1. 인터럽트는 하나이지만 이 인터럽트가 CPU로 전달되며 코어들이 개별적으로 처리해야할 인터럽트인지, 아니면 모두 같이 처리해야 할 인터럽트인지 구분된다.
    * 예를 들어 키보드 인터럽트는 코어 모두가 협동하여 한 번만 처리하게 되고, 타이머 인터럽트의 경우는 코어 각자 개별적으로 처리하게 된다.

## 스레드 프로그래밍
### 스레드
1. C 런타임 라이브러리와 C++ 11
    1) C 런타임 라이브러리에서는 윈도우 API 수준의 CreateThread 함수로 제공되고 모던 C++에서는 '스레드 객체(클래스)'를 제공한다. 이 '스레드 객체'는 CreateThread를 맵핑한 녀석이다. 따라서 커널 오브젝트로 접근되는 스레드라는 의미이다.
    2) 우리의 공부 순서는 윈도우 API 수준의 스레드 함수의 분석 및 관리 방법을 익힌 다음, 모던 C++ 스레드 객체의 사용법을 익힐 것이다.
2. 스레드와 스레드 커널 오브젝트는 다른 의미이다. 스레드는 코드가 도는 단위이고 스레드 커널 오브젝트는 해당 스레드를 바라보고 관리하는 객체이다.
3. 스레드 생성
    1) CreateThread 시 참조 카운트(Usage Count)는 처음부터 2이다. (부모 스레드와 자신)
    2) 스레드 ID는 모든 프로세스를 통틀어 유일한 값이다.
    3) Suspend의 목적: 보통 테스트 용도로 사용된다. 락프리큐, 스핀락 등의 성능 테스트를 할 때 여러 스레드를 생성과 동시에 Suspend를 건다. 이후 한꺼번에 ResumeThread를 호출하여 성능을 테스트한다.
        * 나중에 실수하는게 스레드 생성과 동시에 Suspend를 걸지 않고 성능 테스트를 하는 것이다. 이렇게 되면 제일 먼저 생성된 스레드가 모든 작업을 완료하여 마치 싱글 스레드인 것 처럼 결과가 나와버린다.
4. 스레드의 매개변수
    1) 용도: 보통 똑같은 코드의 스레드가 여러개 생성될 때 어떤 스레드인지 구분하기 위해서 사용
5. 스레드 ID
    1) 남의 스레드 ID는 알 수 없다. 그래서 보통 스레드를 생성할 때 보관해둔다.

### 스레드의 구분
1. 스레드를 구분하는 것에는 스레드 커널 오브젝트 핸들과 스레드 ID를 사용하는 방법이 있다. 
    1) 용도: 단순한 스레드의 구분을 할 때는 '스레드 ID'를 사용하고 스레드의 종료, 대기, 재실행 등의 제어를 목적으로 할 때는 '핸들'을 사용한다,
    2) More: 핸들은 커널 오브젝트를 사용하기 때문에 부담이 된다. 스레드 ID는 단순히 어떤 레지스터에 저장된 것을 가져오기 때문이다.

### 스레드의 종료
1. 종료 코드는 스레드 객체에 저장된다. 스레드의 종료를 확인할 수 있는 방법은 2가지이다. 객체 상태(signaled, non-signaled)와 종료 코드를 확인하는 방법. 정석은 객체 상태를 보는 것이다. 이유는 아래와 같다.
    * 종료 코드는 GetExitCodeThread을 통해 얻게 되는데 만약 스레드가 종료되지 않았다면 STILL_ACTIVE(259)가 반환될 것이다. 그러나 259 또한 정상적인 종료 코드 값으로 반환될 수 있기 때문에 객체 상태를 보는 것이 정석이다.
2. exitThread
    1) start function에서 return을 하는 것과 exitThread 동작의 큰 차이는 없다. 결과적으로 return 할 때 자동적으로 exitThread가 호출되기 때문이다.
3. 최근에는 TerminateThread를 하여도 정상적인 루틴(시스템 객체를 닫고, 스레드 스택 회수, DLL_THREAD_DETACH를 프로세스에 매핑된 DLL에 넘기는 작업 등)은 정상적으로 정리된다.(예전에는 안 그랬음) 그러나 절때! 사용하지 않음
    * 스레드가 타의에 의해 종료되면 해당 스레드가 하던 일을 잃어버리게 된다.

### 스레드 Suspend 상태
1. SuspendThread 시 1증가, ResumeThread 시 1감소
2. Suspend 상태는 어떠한 것도 기다리는 상태가 아닌 그저 Block된 상태이다.
3. '스레드를 제어한다'라는 의미는 다른 스레드 상태를 대기, 종료하는 것이 아니다. 스레드 간 통신을 통하여 어떠한 동작을 행하게 한다는 의미가 있는것이다.

### Sleep(0)과 switchToThread
1. switchToThread와 Sleep(0)과 동일하게 퀀텀 타임을 포기하고 레디큐로 들어간다.
    1) 차이점(예전): Sleep(0)은 자신보다 우선순위가 같거나 높은 스레드가 있을 때만 실행 권한을 넘겨준다. 그러나 switchToThread는 자신보다 우선순위가 낮은 스레드 또한 다음 실행의 대상이 된다.
    2) 차이점(최근): 최근에는 Sleep(0)과 switchToThread는 자신보다 우선순위가 낮은 스레드 또한 다음 실행의 대상이 된다.
    3) 의문점: 퀀텀 타임을 포기한 뒤에 해당 스레드가 어떤 코어의 레디큐로 들어갈 지, 새로운 실행 대상이 우선순위가 낮은 스레드가 되는 경우 어떻게 이러한 동작을 함수 수준에서 가능한 것인지 등

### 스레드와 C 런타임 라이브러리
1. 스레드마다 getptd 함수를 통해 ptd 공간을 부여받는다.

### 우선순위
1. 우선순위 조정에 대한 논의 1
    1) 논의 사항: 우선순위를 조정하여 이득 볼만한 것이 있는가?
    2) 상황1: 우선순위 변경으로 인해 다른 스레드 동작에 영향이 있는가?
        * 이 얘기는 우선순위 변경으로 인해 CPU 이용률 100%에 육박하는 상황이 일어난 상황이다. 하지만 이 조건은 굉장히 까다롭고 실제로 일어날 수 있는 상황인지 잘~ 생각해보자
    3) 상황2: N개의 같은 우선순위를 가진 스레드가 있고 CPU 이용률은 대략 50%라고 하자. 이 상황에서 몇개의 스레드 우선순위를 높였을 때, 이 스레드들은 개발자의 의도대로 더 많이 돌 것인가?
        * 현재 모든 스레드는 퀀텀 타임을 포기하고 Block 상태로 가는 상황이다. 이 상황에서는 모든 스레드가 Block 상태에서 벗어나면 레디큐로 차례차례 줄을 서게 된다. 하지만 특정 스레드의 우선순위를 높인다면? -> 우선순위가 높여진 스레드들은 줄을 서지 않고 바로 CPU에 꽂히게 되므로 기존 스레드들은 레디큐로 빠지게 된다.
        * 여기서 주의할 점은 무조건 적으로 위의 결과로 인해 우선순위가 높아진 스레드가 더 많이 돌거나 CPU 이용률이 높아진다는 것은 아니다. 물론 대부분의 상황이 우선순위가 높아진 스레드가 CPU를 더 많이 선점하는 상황이 될 수도 있지만 말이다.
2. 우선순위 조정에 대한 논의 2
    1) 논의 사항: 네트워크 IO와 게임 로직 중 어떤 우선순위를 높이는 것이 이득인가?
    2) 의견1: 게임 로직 파트의 우선순위를 높이는 경우. 게임 로직은 실질적인 데이터의 처리와 생성이다. 네트워크는 이를 바탕으로 네트워크 송수신이 이루어지는 것이기 때문!
    3) 의견2: 네트워크 파트의 우선순위를 높이는 경우. 송신? 수신? 어느 부분을 높일 것인가? 송신 파트를 높이는 것이 동작에 유리하다. 그 이유는 다음과 같다. 우선 전제는 송수신 동작은 할 일(보낼 혹은 수신할 데이터가 없으면)이 없으면 Block 상태이다. 서버는 서버가 처리할 수 있을 만큼의 부하가 있는 것이 좋다. 이때 수신부 우선순위를 높였을 때 게임 로직 처리가 따라가지 못하게되면 아무런 소용이 없다. 또한 처리가 되었다고 하여도 송신 동작이 되지 않고 메시지 큐에 쌓이게 되면 데이터 손실이 일어나게 된다. 따라서 송신의 우선순위를 높이는 것이 이득이다.
3. 우선순위를 높여볼만한 항목
    1) 데이터베이스: 무조건 우선순위 최상이다.
    2) 정교한 시간 정보를 바탕으로 하는 동작: 모니터링 정보와 같은 항목의 우선순위를 올려볼만하다.
4. IO 혹은 오브젝트 시그널을 기다리는 등의 작업을 마치고 Block에서 레디큐에 올라갈 때 OS는 그 스레드의 우선순위를 2~3을 올린다.

## 기타 키워드
### 강사님 질문
1. 64비트에서 어떻게 스택프레임이 사용되는지?

### 스레드와 동기화 객체
1. 스레드와 동기화 객체 쪽은 자주 바뀐다. 이러한 것들은 문서와 어셈블리 분석이 가장 정확하다.

### 스레드 우선순위 모니터링
1. windows 관리도구(제어판) -> 성능 모니터 -> 그래프에서 카운터 추가 -> Thread 항목 선택

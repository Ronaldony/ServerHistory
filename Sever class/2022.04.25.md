# 2022/04/25 수업내용
## 스레드 프로그래밍
### 최소 단위 오퍼레이션
1. 최소 단위 오퍼레이션의 기준: Core가 명령어를 처리하는 동안 '인터럽트'가 개입될 수 있느냐 될 수 없느냐가 기준이 된다.
2. CPU는 최소 단위 오퍼레이션이 완료될 때마다 인터럽트가 발생하였는지 확인한 후 발생되었다면 인터럽트 핸들러 테이블을 뒤져 바로 튀어간다.

### 인터럽트
1. 컴퓨터는 거의 대부분이 인터럽트로 처리된다.
    1) 인터럽트는 핸들러 방식으로 동작된다. Core는 각각의 인터럽트를 가진다.
        * OS는 IO, 메모리, 스레드 등에 대한 스케줄링을 담당해야 하는데 Polling 방식으로 동작한다는 것은 말이 안된다! 때문에 인터럽트의 신호를 사용한 핸들러 방식으로 동작되는 것이다. 그래서 OS의 가장 기본적인 기능 중 하나가 바로 인터럽트이다!
    2) 윈도우 98부터 기본적인 인터럽트는 번호가 지정되어 있고 타이머 0번, 키보드 6번 등... 이더넷, 사운드 카드, 비디오 카드 등 추가적으로 등록하는 것들은 IRQ에 따로 등록이 되어야한다. 또한, 인터럽트 번호가 충돌되면 해당 하드웨어는 작동하지 않는다.
    * 윈도우에서는 인증받지 않은 드라이버가 아닌 소프트웨어에 하드웨어 인터럽트를 막아 놓았다.(위험)
2. 인터럽트와 컨텍스트 스위칭
    1) 우리 코드 입장에서 인터럽트에 의해 인터럽트 핸들러(코드)로 가는 것은 컨텍스트 스위칭이라고 보지 않는다.
        * 스레드 실행 중 인터럽트가 개입되면 핸들러로 튀어갈텐데 이때는 우리의 스레드가 정지 상태가 된다.(Block 상태를 의미하지는 않음) 이 정지된 시간동안 인터럽트가 소비한 시간을 스레드의 퀀텀 타임에서 빼지 않는다. 핸들러 동작이 끝난 후 스레드의 퀀텀 타임이 다시 흘러간다.
    2) 옛날 OS 인터럽트 핸들러: 레지스터 백업과 복원 그리고 컨텍스트 스위칭의 작업까지 인터럽트 코드가 책임진다.
    3) 최근 OS 인터럽트 핸들러: 레지스터의 백업과 복원까지만 수행하고 컨텍스트 스위칭 작업(가상 메모리 테이블 전환 등)은 수행하지 않는다.
    4) 기본적으로 인터럽트 코드에서는 많은 시간을 소비하지 않게끔 설계되어야 한다. 이 때문에 MS에서는 드라이버 제조사들이 이러한 요구사항을 충족하지 못하면 등록시키지 못한다.(=설치가 안됨)
3. 인터럽트에서 접근하는 메모리가 항상 Non-Paged Pool이어야 하는 이유
    1) Atomic 연산자를 처리하는 것 조차도 Interrupt로 시작해서 Interrupt로 끝나기 때문에. 인터럽트 코드에서 메모리 참조 오류가 나면 해당 인터럽트를 처리해줄 수 있는 놈이 없다.
    2) 인터럽트를 처리하는 과정 중 메모리 참조 오류가 발생되어 Page Fault 인터럽트가 발생되면 이를 해결할 놈이 없다. 그래서 블루스크린이 떠버린다.

### CPU가 변수에 접근하는 과정(인터럽트와 관련된 내용)
1. 예시: MOV 3, [a]
    1) Lx 캐시 메모리의 TLB에서 a의 가상 주소를 뒤져본다. 
    2) TLB에 있다면, 바로 캐시 히트.
    3) L3의 TLB까지 없다면 가상메모리 테이블(Page Table, 이는 커널 메모리에 저장되어 있다.)을 뒤져본다.
    4) 가상메모리 테이블에 프레임 정보(가상메모리가 물리 메모리에 매핑된 단위)가 있다면 Page In, 없다면 Page Out된 상태이다.
    5) 만약 Page Out 상태라면 스레드는 더 이상 할 일이 없다. 예외를 던져 MMU가 Page Fault(인터럽트)가 발생된다.
    6) OS가 인터럽트(Page Fault)를 감지하여 스레드를 중지시키고 이 인터럽트에 대한 처리를 하게 된다. 이때 Disk에서 해당 프레임을 Page In 하는게 아니라 준비 동작만 하는 것이다!!!
    7) OS는 스레드를 Block 상태로 전환시키고 page In 작업을 한다.

### 인터럽트 디스페처
1. 인터럽트 또한 우선순위를 갖는다. 이 우선순위와 기타 등의 기준으로 어떤 인터럽트를 처리할 지 어느 코어에 배정해줄지 결정하는 것이 '인터럽트 디스페처'이다.
    * 인터럽트는 스레드처럼 처리되는 중에 우선순위가 높은 인터럽트가 끼어들지는 못한다.

### 스케줄러와 디스패처
1. 스케줄러의 정체: 각 코어들을 관리하는 무언가가 있는게 아니라 CPU 자신이다. 스레드 스케줄링을 목적으로하는 인터럽트(타이머 인터럽트) 처리가 발생하였을 때 코어 각자가 알아서 자신이 수행할 스레드를 스케줄링한다. 타이머 인터럽트가 발생했을 때 스케줄러 핸들러는 자신의 코어를 확인하여 스케줄링 대상을 선정한다.
    * 스레드 스케줄링의 경우 각 코어들 각자의 타이머 인터럽트로 처리되고 키보드, 사운드 카드 등의 요소들은 다수의 코어들 중 하나의 Core가 수행해야 한다. 
2. 스케줄러
    1) 스케줄러의 역할은 시간 확인 까지이다. 뺄까 말까를 고민하는 것
    2) 만약 스레드를 빼야하는 상황이라면 디스패처를 발생시킨다.
3. 디스패처 인터럽트(소프트웨어 인터럽트)
    1) 실질적인 컨텍스트 스위칭 작업은 디스패처가 수행한다.
    2) 실질적인 작업
        * 1: IO 작업이 완료되거나 퀀텀 타일을 모두 소비한 상태가 된 스레드를 어느 레디큐(코어)에 넣을지 고민
        * 2: 현재 관리 대상 스레드의 우선순위가 코어에서 돌고있는 스레드의 우선순위보다 높다면 레디큐를 쳐다보지도 않고 바로 CPU에 꽂아버림 => 이 말은 즉 스케줄링이 레디큐에 있는 스레드들을 항상 감시되며 작동되는 것이 아니라는 얘기가 된다. 시간 복잡도 또한 1!!!!!!!!
    3) 인터럽트 발생시점: 스레드가 Block 상태에서 해체됐을 때, 스케줄러가 발생시킨 경우
    * 윈도우는 기본적으로 방금 돌던 코어 또는 하이퍼 스레드라면 0,2,4,6...등 현재 돌던 실제 코어와 다른 코어에 스레드를 배정시키는 것을 선호도로 한다.
4. 디스패처는 관리 대상 스레드의 우선순위와 '현재' CPU에 돌고있는 스레드의 우선순위를 비교한 후 요청된 스레드의 우선순위가 높다면 바로 CPU에 꽂아버리고(레디큐를 보지도 않는다.) 돌았던 스레드를 레디큐에 어디에 넣을지 파악하여 꽂아 넣는다. => 이때는 퀀텀 타임의 조건은 볼 조건이 아니다. 새로 생성되거나 Block을 마친 스레드를 대상으로 이러한 동작을 수행한다.

### 컨텍스트 스위칭
1. 스레드가 퀀텀 타임 만료 후 같은 코어에서 바로 스케줄링되면 이것은 컨텍스트 스위칭이라 보지 않는다.

### 레디큐
1. 현재는 코어들이 각자의 레디큐를 들고있지만 최근 여러 코어 그룹이 하나의 레디큐를 공유하는 방식으로 바뀌고 있다.
2. 동기화 객체 또한 설계가 바뀌었다.. (수정)

### 선호도
1. 오히려 많은 스레드를 돌리고 있는 시스템에서 선호도를 설정하면 해당 CPU가 바쁘다면 오히려 더 성능 저하가 이루어진다.
    1) 클라이언트 측에서는 애초에 멀티 스레드에서 얻어질 효과가 적다. 왜냐하면 렌더링 GPU 쪽으로 부하가 치우쳐져 있기 때문이다. 때문에 코어 개수와 스레드 개수를 맞춰 선호도를 지정하고 컨텍스트 스위칭이 일어나지 않게끔 한다.

### 상호 배제와 교착 상태(Deadlock)
1. 동기화
    1) 코드 수준에서 구조적으로 동기화 객체와 같은 요소를 사용하여 배타적인 실행 영역을 제한하는 기법이다. (최소 단위 오퍼레이션과는 상관 없음)
        * 이것은 어떠한 규칙이다.
2. 교착 상태
    1) 상황: PlayerLock과 ItemLock이 있을 때 두 스레드가 두개의 Lock을 서로 교차하여 사용한 상황. => 애초에 설계가 잘못된 상황, 해결할 문제가 아니다.
    * 교착 상태 4대 요소 외우기
    * 다수 자원의 소유와 대기: 적어도 하나의 스레드는 자원에 대한 소유권을 갖고, 다른 스레드가 해당 공유 자원을 획득하려고 해야함
    * 상호 배제: 자원의 소유권은 한번에 하나의 스레드만 소유 가능
    * 무선점: 자원의 소유권을 뺏을 수 없음
    * 순환 대기: 둘 이상의 스레드가 자원에 대해 대기하고 있어야 한다.

## 기타
### TLB(Translation Lookaside Buffer)
1. 기생하고 있는 캐시 메모리에 들어있는 캐시라인의 물리주소 변환 테이블을 저장하고 있다. 캐시 히트될 대상이라면 TLB에 들어있을 것이고 아니라면 없을 것이다.
    * MMU의 일부로, L1~L3 각각에 붙어 있고 가상메모리를 물리메모리 주소로 변환한 값들이 캐시화 되어 있다.
2. 흔히 MMU MMU 거리지만 MMU는 하나의 유닛형태로 되어있지 않고 CPU 내부 여기저기에 걸쳐있다. TLB도 그 중 일부이다.

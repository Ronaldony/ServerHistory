# 2021.12.17 수업필기
## C++
### 다형성
1. 부모 타입의 포인터로 자식 객체 객체 저장 (이는 구조체에서도 가능)
    * 예제
    <pre><code>
    Parent* per = new chile();
    Parent* per = new chile[10];
    </code></pre>
2. 포인터를 이용한 연산의 가능성 여부를 판단할 때, 포인터이 자료형을 기준으로 하지(RTTI 예외) 가리키는 객체의 자료형을 기준으로 판단하지 않는다.
    * 예제1
    <pre><code>
    Parent* per = new chile();  // 컴파일 OK
    per->childFunc();           // 컴파일 에러, 해당 명령문의 경우 Parent::childFunc()로 인식되어 컴파일 에러가 발생한다.
    </code></pre>
    * 예제2
    <pre><code>
    Parent* per = new chile();    // 컴파일 OK
    Child* chd = new Parent();    // 컴파일 에러
    </code></pre>
    * 예제3
    <pre><code>
    Parent* per = new chile();  // 컴파일 OK
    Child* chd = per;           // 컴파일 에러
    </code></pre>
3. 최근 오버라이딩의 재정의: 부모의 virtual 함수만 재정의한 것을 오버라이딩이라 부르는 추세다.
4. *문제: 상속, 오버로딩, 오법라이딩을 섞어놓고 어느 함수가 호출되는지*
5. 다형성의 의미: 모습은 같은데 형태는 다르다. 문장은 같은데 결과는 다르다.

### 가상함수
1. 가상 함수는 부모 타입 포인터로 자식 객체의 멤버함수를 호출할 수 없는 것을 해결하는 것이 가상함수이다.
2. 멤버함수에 virtual 키워드를 붙이면 부모 타입 포인터로 자식 객체의 멤버함수를 호출할 수 있다.
    * 예제1
    <pre><code>
    Parent* per = new chile();  // 컴파일 OK
    per->childFunc();           // 컴파일 OK, 단 chile 클래스 내 childFunc 함수는 virtual로 정의되어 있어야한다.
    </code></pre>
3. 가상함수 테이블 포인터 (테스트 필요)
    1) 객체 최상단에 포인터가 하나 존재하는데 이는 가상함수 테이블의 첫 번째 주소를 가리킨다. 클래스 타입별로 생성된다.(아래 예제에서는 총 3개)
    2) 가상함수 테이블 포인터에는 각각 순서대로 가상함수에 대한 정보가 들어간다. 
    * 예제
    <pre><code>
    A class 정의: F1(), virtual F2, virtual F3(), F4()
    B class 정의: F1(), F2, F3()
    C class 정의: F1()
    
    A 클래스 가상함수 테이블 포인터: [0]: A::F2, [1]: A::F3
    B 클래스 가상함수 테이블 포인터: [0]: B::F2, [1]: B::F3
    C 클래스 가상함수 테이블 포인터: [0]: B::F2, [1]: B::F3
    </code></pre>
    * 이러한 테이블을 거쳐야하기 때문에 가상함수 사용시 성능이 떨어진다.
    * 때문에 가상함수를 포함한 클래스는 포인터인 4byte(64bit에서는 8byte)를 기본 크기로 잡는다.
4. 멤버함수를 호출하였는데 오류가 난다면 반드시 가상함수 참조간 문제가 발생한 것이다. 따라서 클래스별 각 가상함수 테이블 포인터, 테이블이 정확한 값인지 확인해야 한다.
5. 가상 테이블 포인터가 사용되는 경우와 아닌 경우
    1) 사용되지 않는 경우: 객체를 정적 할당으로 생성하여 사용하는 경우, 가상함수를 호출하더라도 가상함수 테이블 포인터를 참조하지 않는다.
    2) 사용되는 경우: 객체를 동적 할당으로 생성하거나 포인터로 다른 객체를 지정한 경우 가상함수 테이블 포인터를 참조한다. 
    * 이 내용은 본 repositories의 Research/C++ 폴더에서 가상함수 주제로 한 번 더 다룸

### 소멸자 가상함수
1. 다른 두 경우
    1) Case 1 (소멸자를 virtual로 정의하지 않 경우)
    <pre><code>
    Parent* p = new child;
    delete p;               // Parent 클래스의 소멸자가 호출됨(child x)
    </code></pre>
    2) Case 2 (소멸자를 virtual로 정의한 경우)
    <pre><code>
    Parent* p = new child;
    delete p;               // child 클래스의 소멸자가 호출됨
    </code></pre>

### 가상함수의 활용
1. 하나의 조상 BaseObject 클래스를 정의하고 내부에는 가상함수(Update, run, render 등)를 정의한다. 이를 인터페이스라 한다.(접두어 I) 이후 각 컨텐츠별로 BaseObject를 상속하는 클래스를 정의하여 virtual 함수들을 오버라이딩하여 사용한다.

### 가상함수 오류
1. 두 가지 경우 재현하여 정리하기 (본 repositories의 ResiResearch/C++ 폴더에서 가상함수 주제로 다룸)
    
### 멤버함수가 없을 때
1. 멤버함수가 없을 때 클래스의 크기는 1이다. 이는 this를 표현하기 위함인데 실제로는 아무 의미없는 값이다. 단지, this가 있다라고만 하는 의미이다.

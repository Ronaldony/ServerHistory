# 2022/07/13 수업내용
# 네트워크 라이브러리
## Release와 SendPacket
### 락프리 큐
1. 현재 Lan 에코서버에 락프리 큐를 SendQ에 적용하여도 문제가 일어나지 않는다. 그 이유는 EnQ와 DeQ를 하는 스레드가 각각 하나로 제한되어있기 때문이다.

### 문제 상황
1. 우리가 우려했던 상황
    1) Release를 하는 도중에 SendPacekt을 하는 경우
    2) SendPacket 중에 Release를 하는 경우
    3) 위 문제들은 IO Count가 0이 되고 난 후에도 외부에서 세션에 접근하려는 상황이 만들어지기 때문에 걱정했던 것이다.
2. 현재는 위 우려 사항은 일어나지 않는다. 그 이유는 다음과 같다. 
    1) SendPacket의 호출 시점이 수신 완료 통지가 완전히 처리되기 이전에 호출되기 때문이다. (OnRecv -> SendPacket)
        * 즉 수신 완료 통지가 물고있는 IO Count가 차감되기 이전에 호출되기 때문이다.
        * 이 얘기는 Release가 호출되는 시점에는 세션에 대한 접근이 어느 곳에서도 없는 상황이 되는 것이다.

## 스마트 포인터와 세션의 IO Count
### 스마트 포인터
1. 스마트 포인터의 동작
    1) 
2. 스마트 포인터 사용
    <pre><code>
    {
        Smarptr<int> p = new int;   // 이 메모리에 참조 카운트가 붙어야 한다.
        *p = 0;
        a = *p;

        Smarptr<int> p2 = p;    // p 참조 카운트 2

        A(p2);                  // p 참조 카운트 3
    }
    
    A(Smarptr<int> x)       // 이 시점에서 참조 카운트가 증가됨
    {
        ...
        // 소멸자가 호출되며 참조카운트 차감
    }
    </code></pre>
3. 스마트 포인터 구조
    <pre><code>
    Smarptr<T> 
    {
        T *_ptr;        // 포인터
        int *_refCnt;   // 참조 카운트(동적 할당)
        
        생성자(T*);    // 여기서 참조 카운트를 생성해야 한다.
        복사 생성자(Smartptr<T>& A)
        {
            InterlockIncrement(_refCnt);
        }
        ~소멸자()     // 참조 카운트 차감, 0이라면 delete
        {
            InterlockDecrement(_refCnt);
            if (*_refCnt == 0)
                delete _ptr;
        }
    }
    </code></pre>
4. 스마트 포인터의 단점
    1) 복사 생성자, 대입 연산자에서 Interlocked이 시도때도 없이 이루어진다.
        * 만약 우리가 직접 참조 카운트를 설계한다면 Interlocked를 사용하는 구간이 조절될 것이다.
    * 따라서 코어, 엔진 단에서는 스마트 포인터를 사용하지 않는다. 절때!!

### 차이점
1. 우리는 현재 IO Count를 세션에 대한 참조 카운트로 사용하고 있다. 스마트 포인터 또한 해당 객체에 대한 참조 카운트를 카운팅하여 해제 시점을 결정한다. 그러나 스마트 포인터는 우리와 같은 문제가 일어나지 않는다. 그 이유는 무엇일까?
    1) 우리와 같은 문제: 위에서 언급한 Release와 SendPacket의 문제
    2) 스마트 포인터는 이미 있다는 보장을 받고 참조 카운트에 접근하여 증가, 차감을 시키는 구조이다. 그러나 우리가 사용하는 IO Count는 세션 ID를 검색하여 있을지도 모른다는 가정을 하고 IO Count에 접근한다.
    3) 
        * 즉 스마트 포인터는 정말로 이미 참조하고 있는 대상으로부터 바통을 이어받아 참조 카운트를 사용하는 것이다.
2. 그럼 우리가 스마트 포인터와 같이 IO Count를 사용하고자 한다면 어떤 디자인이 나와야 하는가
    1) 세션을 바라보는 세션 스마트 포인터 객체를 생성하여 관리한다. (컨텐츠 측에는 세션 스마트 포인터 객체를 전달해주어야 한다.)
        * 이런 디자인에서는 세션이 끊겨서 사용하지 못하게 하는 것과 스마트 포인터가 삭제되는 것이 일괄적으로 이루어져야 한다.
        * 이렇게 되면 세션 ID가 Key가 되고 세션 스마트 포인터 객체가 Value가 되는 형태가 된다.
        
## 로그인 패킷
### 동작
1. OnClientJoin 내부에서 서버측에서 로그인 패킷을 보낸다.

## 기타
### 인터뷰
1. 내가 만든 락프리 큐를 사용할 수 있느냐 없느냐? 그 이유는 무엇인가?
    1) 충분히 테스트를 했고 발견했던 문제에 대해서는 명확히 파악하고 문제를 해결했다. 그러나 생각하지 못한 문제가 발생될 수 있기 때문에 사용하지 못한다. 이는 이 코드에 대해 완벽하게 이해하지 못하고 만들었기 때문에 발생하는 문제이다.
2. 포트폴리오 자료를 직접 만들고 테스트한 결과인가?
    1) 면접관이 의심하는 부분: 프로카데미도 모르고 코드를 어디서 따왔는지 모른다는 의심 때문이다.
    2) 테스트 결과, 문제에 대하여 완벽하게 설명할 수 있어야 한다.

# 2022/05/20 수업내용
## 멀티 스레드
### 멀티 스레드 설계(IOCP x)
1. 길 찾기의 멀티 스레드
    1) 만약 게임 로직 스레드가 길 찾기 스레드 requst 큐에 넣어 병렬로 가져갈 때 길 찾기의 스레드가 몇개이든 request 큐를 하나만 가져가야 한다. 
2. 애초에 헤테로 구조라면 데이터 경합이 일어나지 않도록 가져가는 것이 좋은 설계이다.
3. 네트워크 IO와 게임 로직 스레드를 멀티 스레드로 가져가는 상황
    1) 게임 로직의 request 큐가 하나인 상황: 게임 로직 스레드들이 동시에 
    2) 게임 로직의 request 큐 스레드마다 있는 상황: 게임 로직들이 request 큐마다
        * 유저 매칭 밸런스: 라운드 로빈, 큐 부하 등을 측정하여 밸런스를 맞춰 큐에 인큐
        * 이 
4. 컨텐츠 메시지 처리를 멀티 스레드로 가져가는 경우 무조건 분리할만한 요소가 있기 때문에
5. 맵, 필드, 던전 등의 요소로 분리하는 경우
    1) 호모 지니어스 입장에서 공유 자원에 대한 동기화 경합의 비율을 고려해야 한다. 만약 게임 로직 스레드가 10개이고 던전 스레드가 500개라면 경합의 비율은 적을 것이다.
        * 하지만 던전 스레드가 50개로 줄어든다면 경합의 비율이 증가할 것이다. 이런 경우 게임 로직 스레드를 늘리는 방법을 택할 수 있다. => 컨텍스트 스위칭의 비용이 증가한다. => 그래서 나온 게 IOCP이다.
6. 프레임 처리
    1) 프레임을 관리해 줄 스레드가 나와야 한다. 그래서 앞서 언급한 게임 로직 스레드들은 수신 메시지 처리만 하는 스레드들이 되고 실제 프레임 관리 스레드가 전체적인 로직을 맡아야 한다.
        * 만약 프레임 스레드를 분리시키는 경우 각각 맵/던전/필드 등의 기능별로 역할이 정해져 있어야 한다.
7. Network IO 스레드가 Worker 스레드의 request 큐에 넣고 처리하는 것(1번 방법)과 Network IO 스레드가 메시지를 수신하고 바로 처리하는 것(2번 방법)의 차이 또는 문제점
    1) 1번 방법: Network IO보다 게임 로직이 느린 경우 request 큐에 데이터가 쌓일 수 있다. 
    2) 2번 방법: 
        * 강사님은 이 방법을 선호한다. 그 이유는 게임 로직의 처리가 우선이기 때문이다.
    * 그림 추가
    * Worker 스레드는 수신한 메시지를 처리하는 
8. Networkd

### IOCP
1. 효과적인 스레드 풀 관리를 가능하게 해준다.
2. IOCP

### 서버의 분리
1. 예전에 했던 지역적, 기능별로 물리적으로 분리를 하는 것은 스레드를 분리하는 것과 같은 모양새이다.

### 계층
1. 나중에는 네트워크와 게임 로직 부분을 완전히 다른 계층으로 나눌 것이다.

## 기타 키워드
### IO 바운드, CPU 바운드
1. IO 바운드: IO를 기다리는 시간을 의미한다. IO를 위해 Block이 걸렸다는 것이다. 대표적으로 Network IO가 IO 바운드 덩어리이다.
2. CPU 바운드: CPU를 사용하는 시간을 의미한다. 대표적으로 게임 로직이 CPU 바운드 덩어리이다.
3. IO 바운드와 CPU 바운드 중 어떤 것을 최소한으로 하는 게 중점적으로 보아야 하는가?
    1) 이 질문은
    2) 로직, 스레드 단위로 어떤 것이 중요한 지 
    3) IO 바운드가 많아진다는 것은 많이 논다는 것이다. 이런 스레드들은 많이 있을 이유가 없다.
5. 프레임 스레드, 로직 스레드는 IO 바운드를 제거해야 한다.

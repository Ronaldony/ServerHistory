# 2022/03/04 수업내용(복습 완료)
## 네트워크 설계
### 링버퍼 설계
1. 링버퍼가 가득찬 기준을 rear와 front가 만나는 형태로 설계하면 멀티스레드 방식에서 문제가 생길 수 있음. 따라서 rear와 front가 안 만나게 1byte 남기게끔 설계해야 한다.
2. DirectEnqueueSize와 DirectDequeueSize의 설계
    1) DirectEnqueueSize: Rear에서 실제 버퍼의 끝까지(원형 반영x) 한 방에 EnQ 할 수 있는 길이
    2) DirectDequeueSize: Front에서 실제 버퍼의 끝까지(원형 반영x) 한 방에 DeQ 할 수 있는 길이
3. 최종적으로는 멀티스레드 환경에서 링버퍼에 Lock을 걸지않고 EnQ와 DeQ를 정상적으로 구현하는 것이 목표이다.

### 메시지 처리
1. 메시지를 수신한 자리에서 처리할 수 있는 메시지와 없는 메시지로 구분할 수 있다.
    * 예를 들면 FPS 게임에서 사격 시 레이캐스팅하여 바로 충돌처리 할 것인가, 총알을 생성하여 총알이 지나가는 경로에 대해 일일히 충돌처리를 할 것인가.(한조 활)
    * 경로마다 충돌 처리: 3D에서는 키 프레임 중간 중간에 다른 객체와 충돌 여부가 있는지 확인해야 한다.
    * 타겟팅 충돌 처리: 메시지 정보(메시지 도착 시간, 공격 위치, 공격 대상)를 저장한 상태에서 Logic에서 이 메시지에 대한 처리가 이루어진다.
2. 공격에 대한 처리
    1) 기획자와 얘기할 때 공격 투사체를 발사하는 경우 중간에 끼어드는 객체에 대해서도 충돌처리를 해야되는 것인지 아닌지만 결정하면 된다. 이는 매 프레임 공격 투사체가 날아가는 동안 다른 객체와의 처리가 이루어져야 하는지의 여부가 달려있기 때문

### 서버의 설계
1. 기본적인 멀티스레드 설계
    1) IO: 네트워크 IO 등..
    2) 프레임 처리: 메시지 처리, AI, 게임 컨텐츠 등.. 
2. 설계
    1) 기본적인 설계
        <pre><code>
        while(1)
        {
            network
               recv
               send
            logic
                send 용 데이터 생성 // 이렇게 설계된 경우 지금 Logic 처리된 데이터가 다음 프레임에 클라에게 넘어가게 된다. 이것 때문에 RTT가 생긴다.
            Sleep(n)
        }
        </code></pre>
    2) 배그 데디케이티드 설계 예시
        <pre><code>
        while(1)
        {
            network
               recv                  // 클라에게 send할 첫 번째 데이터 생성
               send
            logic
                send 용 데이터 생성   // 클라에게 send할 두 번째 데이터 생성
            network
               send
            Sleep(n)
        }
        // 이러한 방식은 반응성은 좋아지지만 서버의 부담은 커진다.
        </code></pre>
        * <img width=500 src="https://user-images.githubusercontent.com/95362065/156685727-6da153d3-147b-41af-a8de-c254bad9f245.jpg">
3. RPC(Remote Procedure Calls): 다른 공간(클라이언트)에서 함수를 호출했을때 다른 공간(서버)에서 특정 함수가 호출되는 개념
    * 이는 단순히 생각하면 클라이언트가 메시지를 보냈을 때 서버가 해당 메시지를 수신하고 이에 대한 처리(함수 호출 등)을 하는 것이다.

## TCP 소켓 프로그래밍
### WSAAsyncSelect 모델(이벤트 방식)
1. 윈도우 메시지로 전달되는 형태의 모델이기 때문에 윈도우 창이 있어야 함(WinMain)
2. MS는 WSAAsyncSelect 모델 대신 EventSelect 모델을 사용하라고 권장한다. 하지만 클라이언트에서는 아직도 현역이다.
3. WSAAsyncSelect 함수에 입력된 소켓은 함수 내부적으로 논블로킹 모드로 전환시킨다.
4. WSAAsyncSelect을 서버에서 사용하는 경우에는 SOCKET을 Key로 세션(Value)정보를 찾아야 한다.

### WSAAsyncSelect 모델의 송수신 이벤트
1. FD_WRITE: 최초 연결된 직후, 보낼 수 없는 상태에서 보내는 상황 혹은 그 반대의 상황에서만 이벤트가 발생한다.
    * WriteEvent에서는 성능에 피해가 가더라도 일단 sendQ에 꽂고 sendQ에 있는 것을 send하자!
2. FD_READ: 최초 연결된 직후, FD_READ에 대응해서 recv()를 호출하는 경우에만 이벤트가 발생한다. FD_READ가 발생하였는데 recv()를 호출하지 않으면 다시는 발생하지 않는다.
   
### 윈도우 메시지
1. WM_USER: 윈도우 메시지의 최댓 값
2. wParam: 네트워크 이벤트가 발생한 소켓이 들어온다. SOCKET으로 형변환하여 사용하면 됨
3. lParam: 상위 16비트에는 에러 코드, 하위 16비트에는 네트워크 이벤트(FD_WRITE, FD_READ 등)가 들어온다. 우선적으로 에러 코드를 검사하여 처리해야 한다.

## 기타 키워드
### 네트워크 코드
1. 서버 개발자는 클라이언트 네트워크 코드를 짜서 클라이언트 개발자가 API 처럼 사용할 수 있도록 해야한다. 클라이언트 개발자는 네트워크 지식이 0이라고 봐야한다.

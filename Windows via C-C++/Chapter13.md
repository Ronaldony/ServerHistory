# Chapter13 윈도우 메모리의 구조
## Section01 프로세스의 가상 주소 공간
### 가상 주소
1. 애플리케이션에서 접근 예외를 유발하지 않고 성공적으로 데이터에 접근하기 위해서는 접근하고자 하는 주소 공간에 물리적 저장소가 할당되거나 매핑되어 있어야만 한다.

## Section02 가상 주소 공간의 분할
### 가상 주소 공간
1. 각 프로세스의 가상 주소 공간은 분할되어 있으며, 각각의 분할 공간을 파티션이라고 한다.
2. 프로세스 주소 공간의 분할
    |파티션|x86 32비트 윈도우|x86 64비트 윈도우|
    |------|---|---|
    |NULL 포인터 할당|0x0 ~ 0xFFFF|0x0 ~ 0xFFFF|
    |유저 모드|0x10000 ~ 0x7FFEFFFF(2GB)|0x10000 ~ 0x7FF FFFEFFFF(8192GB)|
    |64KB 접근 금지|0x7FFF0000 ~ 0x7FFFFFFF|0x7FF FFFF0000 ~ 0x7FF FFFFFFFF|
    |커널 모드|0x80000000 ~ 0xFFFFFFFF|0x800 00000000 ~ 0xFFFFFFFF FFFFFFFF|
    1) NULL 포인터 할당 파티션: 프로그래머가 NULL 포인터 할당 연산을 수행할 경우를 대비하기 위해 준비된 영역이다. 이 파티션에 대해 읽거나 쓰기를 시도하게 되면 접근위반이 발생하며, 프로세스는 종료된다.
    2) 유저 모드 파티션: 프로그래머가 접근 가능한 주소 영역이다. 이 주소 공간에는 힙, 스택, 코드, 데이터 영역의 데이터가 저장된다. DLL과 메모리 맵 파일이 이 파티션에 로드된다. 
    3) 커널 모드 파티션: 운영체제를 구성하는 코드들이 위치한다. 스레드 스케줄링, 메모리 관리, 파일시스템 지원, 네트워크 지원 등을 구현하는 코드와 모든 디바이스 드라이버들이 이 파티션에 로드된다.

## Section03 주소 공간 내의 영역
### 주소 공간 예약
1. 주소 공간을 Reserve 시 **시작 주소**는 할당 단위 경계 상에 위치해야 한다. (본 책에서는 당시 할당 단위는 64KB이어서 시작 주소를 64KB로 나누어 떨어지는 위치로 지정해야 한다고 언급)
2. 주소 공간을 Reserve 시 **예약할 크기**는 반드시 시스템의 **페이지 크기**의 배수로 설정해야 한다.
    * 페이지란 운영체제가 메모리를 관리할 때 사용하는 최소 단위를 말한다.

## section05 물리적 저장소와 페이징 파일
### 페이징 파일
1. OS는 디스크 공간을 메모리처럼 활용할 수 있는 기능을 지원하는데, 디스크 상에 존재하는 이러한 파일을 Paging file 이라고 한다.
2. 시스템의 페이징 파일의 크기는 애플리케이션에서 사용할 수 있는 물리적 저장소의 크기를 결정하는 가장 중요한 요소가 되며, 실제 램의 크기는 크게 영향을 주지 못한다.

### 가상 주소->물리적 주소 변경
1. 다이어그램
    * <img width=600 src="https://user-images.githubusercontent.com/95362065/157368324-0a9fc2ea-4bfd-46db-8806-0f40bb73ded3.png">
2. 데이터를 램->페이징 파일 혹은 페이징 파일->램으로 가져오는 작업이 많아지면 많아질수록 발생하는 디스크 트레쉬(Disk thrash)가 생기고 이는 시스템의 수행 속도를 점점 더 느려지게 한다.
    * 트레슁: OS가 프로그램을 수행하지 못하고 대부분의 시간을 페이지 파일과 램 사이의 스와핑에 소비하는 현상
    * 컴퓨터에 추가적으로 램을 설치하면 트레슁의 정도가 감소하여 시스템의 성능이 개선된다. 실제로도 대부분의 상황에서 CPU를 교체하는 것보다 추가적으로 램을 설치하는 것이 좀 더 큰 성능 개선을 가져온다.

### 페이지 파일 내에 유지되지 않는 물리적 저장소
1. 어플리케이션을 수행하면 시스템은 .exe 파일을 열어 코드와 데이터의 크기를 얻어낸다. 이후 가상 주소 공간에 얻어낸 크기만큼의 영역을 예약하고, 이 영역에 대한 커밋된 물리적 저장소를 .exe 파일 자체라고 설정한다. 시스템은 페이징 파일에 공간을 할당하는 대신 가상 주소 공간에 예약된 영역을 이처럼 활용함으로써 좀 더 빠르게 어플리케이션을 로딩할 수 있다.

## Section07 모두 함께 모아
### 메모리 영역 타입(가상 주소 공간)
1. 메모리 영역 타입
    |타입|설명|
    |---|---|
    |프리(Free)|어떠한 저장소로도 매핑되지 않은 상태이다. 애플리케이션에 의해 이 영역의 시작 주소나 영역 내의 아무 주소 값으로라도 예약을 수행할 수 있다.|
    |프라이비트(Private)|시스템의 페이징 파일에 매핑되어 있는 주소|
    |이미지(Image)|이해가 잘 안됨, 책 다시 볼 것|
    |맵(Mapped)|이해가 잘 안됨, 책 다시 볼 것|

## Section08 데이터 정렬의 중요성
### 데이터 정렬
1. 데이터 정렬의 문제는 메모리 구조보다는 CPU의 구조와 관련되어 있다. CPU는 데이터가 적절하게 정렬되어 있을 때 더욱 효율적으로 접근할 수 있다.
2. 데이터가 저장되어 있는 메모리의 주소 값을 데이터의 크기로 나누었을 때 나머지가 0인 경우 데이터가 정렬되어 있다고 한다.
    1) 이는 구조체의 요소들이 자신의 크기에 맞춰 주소가 정렬되는 특성과 관련이 있다.
3. 정렬되지 않은 데이터 주소가 사용되는 경우
    1) CPU가 정렬되지 않은 데이터를 읽어오려 하면 두 가지 중 한 가지 작업이 수행된다. 첫째는 예외를 유발하는 것이고, 둘째는 정렬된 위치들을 여러 번 읽어서 정렬되지 않은 데이터를 모두 읽을 때까지 반복한다.
    2) 정렬된 데이터를 가져오기 위한 메모리 접근 횟수의 2배만큼 반복하여 메모리에 접근해야 하며, 실제 소요되는 시간은 2배 이상이다.
4. 예외 발생
    1) x86 CPU는 EFLAGS 레지스터 상에 AC(Alignment check) 플래그를 기본적으로 0 값으로 set 한다. 이 값이 0이면 CPU가 정렬되지 않은 데이터에 접근하는 경우에도 값을 얻기 위해 수행해야 하는 추가적인 작업들을 자동적으로 수행한다. x86 버전의 윈도우는 항상 이 값이 0이기 때문에 데이터 비정렬 예외가 발생할 가능성이 전혀 없다.
    2) 반면 IA-64 CPU의 경우 

### 비정렬 폴트 관련 함수
1. 윈도우즈는 IA-64와 같은 CPU에서 발생하는 비정렬 폴트를 EXCEPTION_DATATYPE_MISALIGNMENT 예외로 전환시켜준다. 하지만 이 예외를 자동적으로 처리하기 위해서는 다음의 함수를 호출하여 윈도우즈가 자동적으로 비정렬 데이터 접근 문제를 해결하게 해야 한다.
    <pre><code>
    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);
    </code></pre>
    * 해당 기능은 같은 프로세스 내에 있는 스레드들에게만 일괄 적용된다.

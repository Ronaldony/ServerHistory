# 2022/07/20 수업내용(복습완료)
# 네트워크 라이브러리
## 스레드
### 스레드와 메모리풀
1. 스레드 생성 시 런타임 라이브러리가 각 스레드마다 PTD와 같은 전용 공간을 마련하여 관리한다.
2. 스레드의 종료
    1) exitThread는 권장되지 않는다. 런타임 라이브러리가 해당 스레드를 정리할 기회가 없기 때문
    2) return과 endThread는 자원을 정리하 기회가 주어진다.
3. 우리는 메모리풀을 스레드마다 관리할 것이다. 정성적으로 한다면 스레드마다 관리되는 자원에 대해 동적으로 파괴되어 정리하는 입장이 된다면 우리는 런타임 라이브러리와 같은 구조로 스레드가 생성되자마자 메모리풀을 스레드에 붙이느 방식이 되어야 한다.
    1) 그러나 메모리풀 때문에 이런 과도한 구현은 손해스럽다.
4. 우리의 메모리풀은 스레드의 종료 시점에 자원의 정리에 대한 동작은 고려하지 않을 것이다.

## 메모리풀
### TLS 메모리풀
1. 정의: 각 스레드 풀을 관리하는 메인 메모리풀 역할을 하는 클래스를 TLS 메모리풀이라 명칭할 것이다.
2. 현재는 Alloc 혹은 Free가 호출되었을 때 수동으로 스레드 ID를 확인하여 Pool을 관리하지만 추후에는 TLS로 전환하여 관리할 것이다.
3. TLS 메모리풀은 청크 단위로 노드를 다루고 스레드 메모리풀들은 노드 단위로 노드를 다루어야 한다.
4. 우리가 TLS라는 용어를 사용할 때는 프로그램을 공부했다면 각 스레드마다 데이터가 관리되는 것이구나 라고 알아 듣는다. 멀티 스레드에서 스레드마다 독립적으로 관리해서 동기화 시간을 최소화하는 것들을 우리는 TLS라고 말할 것이다.
    1) 또한 어떠한 TLS를 설계할 때는 사용법을 심플하게 가야 한다. 사용자측에서 스레드가 몇개니, 몇개의 데이터를 생성하냐느니 같은 자질구레한 것들으 빠져야 한다는 얘기이다. TLS가 모두 알아서 하는 것이다.
5. Placement new
    1) 풀TLS와 스레드 풀에서 생성자가 중복 호출되거나 아예 호출되지 않는 경우가 생길 수 있으므로 어떻게 설계할 지 고민해보아야 하는 사항이다.

### 락프리 스택
1. 입출력에 대한 순서가 상관없다면 우리는 가장 간단한 자료구조인 스택을 선택할 것이다.
    1) 간단한 구조라면 코드가 간결하고 코드가 적다. 간결하고 적은 코드라는 것은 로직 자체에서도 캐시히트율을 높일 수 있는 상황이 만들어진다.
2. 비교: 락프리 큐와 스택은 상황마다 성능이 누가 나은지 장담은 할 수 없다. 그러나 각 상황에서는 이득이 되는 구조는 확실하게 정해진다. 락프리를 완벽히 이해했다면 정확하게 정할 수 있을 것이다.
    1) 공용 스택이나 큐를 두고 경합이 많이 벌어지는 상황에서는 큐의 방식이 나을 수 있다. 스택은 Pop과 Push 둘 다 Top만을 바라보지만 큐는 Tail과 Head 두개를 바라보기 때문이다.
    2) 

### 청크 관리
1. 메모리풀 내부에서 Pool의 Max 치를 넘으면 Chunk 포인터에 쌓아두면서 

## TLS(스레드 지역 저장소)
### 관련 함수
1. SetWindowWord, SetWindowsLong: 윈도우(창) 핸들마다 별도로 보관되는 공간이다. Extrabyte라는 공간에 저장되는 정보
    1) 하나의 윈도우 프로시저(코드)로 여러개의 윈도우를 생성하다보니 어느 것이 어떤 윈도우인지 구분할 수 없게 된다. 윈도우에서 같은 클래스를 가지고 여러개의 윈도우를 만들게 되면 동일한 윈도우 프로시저가 나온다.(똑같은 코드가 된다.) 이렇게 되면 해당 코드에서 내가 어떤 윈도우인지 구별할 수 없게 된다. 이때는 앞서 언급한 SetWindowsWord 말고도 윈도우 핸들을 가지고 매핑 테이블을 만들어 윈도우를 구분할 수도 있다.

### 런타임 라이브러리
1. 런타임 라이브러리는 TLS 기능을 FLS의 이름으로 바꾸어 호출한다.
    1) 이유: 범용적으로 Fiver에 대해서도 지원해야 하기 떄문에 이러한 이름으로 되어 있다.
    2) 우리는 Fiver를 쓰지 않기 때문에 TLS로 사용될 것이다.
2. Fiver(파이버)
    1) 유저 모드의 스레드 (경량 스레드)

### DLL
1. DLL은 TLS에 의존적이다. DLL을 사용하는 어플리케이션의 환경이 싱글 스레드일지 멀티 스레드일지 알 수 없기 때문이다.

### 동적 TLS
1. OS에서 제공해줘야하는 기능이다. 오로지 윈도우 API 차원에서 제공된다.
    1) 스레드를 만들때 기본적으로 생성되고 안 쓰면 낭비가 되는 대상이다.
    2) 쓰레드마다 TLS라는 void* 타입의 배열을 제공한다. 현재는 몇백개를 제공하여 준다.
2. 함수
    1) TlsGetValue
        * Index 입력하면 해당 인자의 TLS 공간에 저장된 값을 가져올 수 있다.
    2) TlsSetValue
        * Index 입력하면 해당 인자의 TLS 공간에 저장된 값을 가져올 수 있다.
    3) TlsAlloc
        * 현재 사용되지 않는 Index를 반환해준다. TLS_OUT_OF_INDEXES 반환 시 인덱스 초과로 예외 처리가 필요하다.
        * 같은 프로젝트 코드에서 TLS의 Index가 중복되어 사용되면 덮어써져버리는 문제가 발생한다. 따라서 Index 또한 따로 할당을 받아 사용하자! 는 아이디어에서 이 함수가 나왔다.
        * 프로세스에서 별도의 플래그를 사용하여 TLS 공간들을 관리한다.
    4) TlsFree
        * 입력한 Index의 TLS공간이 반환된다. 즉 사용하지 않는 
3. TLS Index
    1) TlsAlloc 시 제공되는 Index는 해당 프로세스에 종속된다. 즉 스레드 1에서 TlsAlloc을 하여 0번 Index를 얻게되면 스레드 2에서 TlsAlloc을 호출하게되면 0번 이외 사용되지 않는 Index를 반환한다.
4. TLS 공간은 최초 0으로 초기화하는 것을 보장한다.
    1) 우리는 여기에 의존한 코드를 짤 것이다.

### 정적 TLS
1. OS에서 제공해줘야하는 기능이다. 윈도우 API와 약간의 언어적인 차원에서도 제공을 하는 방식이다.
    1) 동적 TLS와는 다르게 기본적으로 없는 TLS이다. 따라서 안써도 무방한 TLS이다.
2. __declspec(thread) 키워드
    1) 정적이나 전역 변수에 키워드로 사용하면 해당 변수는 TLS 공간이 된다. (지역은 불가능)
    2) 변수의 이름을 접두어에 static은 st_변수이름, 전역은 gt_변수이름으로 하는 것을 권장한다.
    3) C++ 컴파일러에 한정되는 한정사이다.
3. __declspec(thread)가 붙은 변수들이 TLS라는 섹션에 배치되고 스레드가 생성될 때마다 해당 스레드에 이 섹션이 붙게된다.

### 값의 초기화
1. 지역변수는 왜 초기화되지 않을까?
    1) 이유 1: 함수는 내가 원할 때 호출하는 방식이기 때문이다. 따라서 처음 사용에 대한 보장을 내 스스로가 할 수 있다.
    2) 이유 2: 반복 호출로 인한 성능 문제
2. 전역변수는 왜 0으로 초기화될까?
    1) 처음 사용된다는 시점을 보장하기 위하여

## 포트폴리오
### 락프리 큐와 스택
1. 큐와 스택이 어느 상황에서 이득이 될 수 있는지를 조사하고 적용하여 결과를 포트폴리오에 작성하면 좋다. 

## 기타
### 동적 메모리 할당
1. 고성능을 요구하는 시스템에서는 malloc을 사용하지 않는다. 동기화가 들어가기 때문에
2. 각 회사별 동적 할당 라이브러리: JeMalloc(페이스북, 파이어폭스), TcMalloc(구글)
    1) 이들은 모두 FreeList를 활용한다. Pool은 사실 좀 애매하다.
    2) 이 라이브러리들은 모두 사이즈 별로 나누어 동적 할당이 이루어진다. 우리 힙도 사실 마찬가지이다.(LFH)

### C++ 20
1. C++ 20에서 코루틴을 유저 모드 스레드를 정식 표준으로 채택했다.
2. C++이 윈도우의 Fiver를 쓸 줄 알았지만 코루틴을 선택했다. C++에서야 외형적인 문법만 표준으로 정의하고 있는 것이고 실직적인 구현은 해당 컴파일러 제조사가 알아서 할 일이다.
    1) Fiver를 선택하지 않고 C++이 직접적으로 코루틴을 정의한 부분이다.

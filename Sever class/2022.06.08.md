# 2022/06/08 수업내용
# IOCP
## 서버
### 세션 
1. 세션의 재설계
    <pre><code>
    Session
    {
        // ... 
        SendFlag    // 
        RecvFlag
        LockObj
    }
    </code></pre>
2. 세션의 종료
    1) 동기화 객체여도 완료 통지에 있는 세션에 대한 작업을 동기화 시키지는 못한다.
3. 세션마다 동기화 객체를 추가하여 워커 스레드 작업을 할 것이다.

### IO COUNT
1. IO Count와 완료 통지의 관계
    1) 완료 통지의 특성:동기던 비동기던 WSARecv나 WSASend가 지금 당장 완료할 수 있다면 해당 함수가 끝나기도 전에 완료통지가 온다.
    2) IOCount의 목적
        * 1: 다른 작업이 Session에 대한 작업을 하고 있을 때 
        * 동시에 Session에 접근하지 못하게 하는 것은 동기화 객체의 역할이다. IOCount의 역할은 아니다.
    3) 증가의 시점
        * 완료 통지의 특성으로 인해 WSASend, WSARecv를 호출하기 전에 IOCount를 증가시켜야 한다. 만약 호출 후에 증가를 시키게 된다면
2. IO Count와 세션 종료의 관계
    1) 세션 종료(IO Count가 0이 되는 순간)를 해야 하는 순간은 IO Count가 차감되는 순간이다. (GQCS 이후 절대 독립적으로 0을 판단하는 코드는 있을 수 없다.)
    2) 차감의 시점
        * Recvpost 혹은 sendpost 이후 차감 (이전에 한다면 0이 되는 시점이 있을 수 있다.)
        * 따라서 차감 시점은 워커 스레드의 가장 최하단에 배치해야한다.
    3) 위 차감의 시점을 고려하여 세션의 종료 코드의 위치
        * 기본적으로 모든 차감 구간에 세션 종료 코드를 위치시켜야 한다.
        * 시점1: 워커 스레드의 최하단
        * 시점2: Recvpost, Sendpost 에러 발생 시점
    4) 세션 종료의 핵심은 어떠한 완료 통지이던 간에 세션에 대한 가장 마지막 완료 통지가 처리되는 순간에 세션을 릴리즈(종료)하는 것이다!!!!!!!

### GQCS
1. 결과에 대한 판단
    1) GQCS 반환 값
        * 우리는 성공과 실패 여부를 판단하지 않을 것이다. 성공은 IO 작업에 성공했다라는 것이고 실패는 IO 작업에 실패했다라는 것이다. 우리는 딱히 이부분에 대해 판단할 필요가 없다. 이것을 가지고 우리가 할 수 있는게 없기 때문이다.
        * 그러나 실패 시 GetLastError()를 확인하여 어떤 에러 코드인지 확인해야 한다.(로그만을 위해서)
    2) transferred
        * 특이 사례: 작업 중 세션이 끊겼다라면 send를 요청한 값보다 작은 값이 나올 것이다.
        * 우리에게 send 요청 값보다 작은 값이 나온다면 연결이 끊긴 것으로 판단할 것이다. 그러나 작은 값에 대한 처리는 따로 하지 않을 것이다.(이렇게되면 
        * transferred가 0이 나왔을 때 Send와 Recv인지에 대한 동작을 구분하지 않고 종료되었다고 판단할 것이다.
    3) Overlapped(확장된 OVERLAPPED 구조체)
        * Overlapped는 스레드 종료, recv 혹은 send에 대한 작업 판단을 하는데에만 사용할 것이다.

### 완료 통지
1. WSARecv, WSASend 요청에 성공한 경우 IO 작업에 실패하여도 GQCS로부터 완료통지가 전달된다.(Overlapped가 NULL이 아니다.)
2. Overlapped가 NULL이 나오는 경우
    1) IOCP 문제
    2) Timeout
    3) 스레드 종료를 위한 PostQueued.. 호출

### 함수
1. SendMessage
    1) 기능: 입력된 메시지를 SendQ에 인큐하는 작업
2. Sendpost
    1) 기능: SendFlag를 확인하여 WSASend 호출 여부를 결정

### 디버깅
1. 파일, 콘솔에 로깅을 하는 것은 동기화를 먹어버리기 때문에 멀티스레드의 디버깅 대상이 아니다.
    * 따라서 최대한 빠르게 메모리에 로깅(흔적)을 남기는 방향으로 디버깅해야 한다.
2. 멀티스레드의 가장 큰 해결점은 디버깅하는 감을 잡는 것이다.

## 기타 키워드
### IOCP 에코 서버
1. transferred가 0이면 closesocket만해서 코드
2. 지금 우리 에코 서버의 경우에는 세션에 대한 동기화가 없어도 정상적을 돌아가야 한다.
3. 클라이언트 더미에서 Echo STOP을 하면 모니터링 정보 Wait Echo Count가 0이 되어야 한다.
4. 실제로 세션 종료가 어디서 이루어지는지 로그로 남기어 디버깅 감각을 키울 것

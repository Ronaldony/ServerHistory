# 2022/07/08 수업내용
# 락프리
## 락프리 큐
### 디버깅
1. DeQ에서 Size가 0보다 큰 것을 확인하고 들어갔는데 Head->next 가 NULL인 상황
    1) 문제 원인1: A 스레드가 DeQ에 진입하여 지역 Head를 저장하고 멈춘 후 B스레드에서 해당 Head 노드를 대상으로 DeQ->EnQ가 되어 tail이 된다. 그 순간 A 스레드가 다시 깨어나 Head의 next를 바라봤을 때 Null 상태가 되는 것이다.
    2) 문제 원인2: Head가 Tail을 역전한 뒤 Tail이 가리키고 있던 노드가 DeQ로 해제되면서 발생되는 문제
        * <img width=600 height=700 src="https://user-images.githubusercontent.com/95362065/177923027-74aaede3-a812-4a25-b348-0d185b9b47f9.png">

### DeQ의 정책
1. 큐 상태에 대한 기준
    1) 큐에 데이터가 없는 것을 처리하는 기준
        * 1: Size를 기준으로 0 이상이면 DeQ를 하겠다.
        * 2: Head->next가 Null이면 큐가 비어있는 상황으로 판단하고 DeQ를 안 하고 끝내겠다. 
    2) Size가 DeQ 기준인 상황
        * 외부에서 Size를 확인하고 DeQ 작업에 들어왔을 때 next가 Null인 상황은 반드시 생긴다.
    3) next가 null일 때 기준인 상황
        * 폴링으로 DeQ를 하는 상황: DeQ를 Polling 로직으로 동작하고 있다면 굳이 문제될 것은 없다. 그러나 우리는 Polling 방식으로 메시지 큐를 계속해서 확인하지는 않을 것 같다.
        * 이벤트로 DeQ 시점을 알리는 상황: DeQ가 가능하다고 판단되어 DeQ하는 스레드를 이벤트로 깨우는 로직 상황이다. 이 상황에서 DeQ를 하는 스레드측에서 Out of ordering으로 인해 next가 Null이라고 판단하는 상황이 된다면 이 상황은 문제가 될 수 있다. 이 이후에 아무런 DeQ 작업을 하는 스레드가 없다면..
2. Q의 처리
    1) 우리 입장에서 큐의 메시지와 스레드를 깨우는 것을 1:1로 매핑되게 할 수 없다. 즉 IOCP와 같은 동작을 구현할 수가 없다는 것이다. 이게 가능하려면 커널 쪽의 개입이 있어야하기 때문이다.
        * 우리가 이전에 큐에 메시지를 넣고 워커 스레드를 깨우는 방식에서 문제됐던 상황은, EnQ 스레드 쪽에서 이벤트 객체를 Signaled로 바꾸었을 때 워커 스레드가 작업중이라면 이 Signaled 신호가 씹힐 수가 있는 것이었다. 이벤트는 SuspendThread 처럼 Counting 되지 않기 때문이다.
3. 정책
    1) 문제1: 위에서 언급한 것과 같이 1:1로 매핑할 수 없기 때문에, 멀티스레드에서 DeQ 진입 전 Size를 확인하고 진입하는, 즉 Size에 의존한 코드는 믿을 수 없는 상황이 된다.
    2) 문제2: Head->next가 Null인 것을 확인하여 큐가 비었다고 판단하는 것은 이벤트 로직 방식에서 문제가 되었다.
    3) 락프리 큐를 활용하는 입장에서 Size를 검사하고 DeQ로 진입하는 것이던, 일단 DeQ로 들어가 next로 큐가 비어있다는 것을 확인하는 것이던 활용 입장에선 어차피 오판이 일어난다. Lock을 걸지 않은 이상..(오판: 비어있지 않은데 비어있다고 판단)
    4) 따라서 제작자가 큐에 대한 정책을 세워서 사용자 측에서 이 정책에 따른 사용법을 따라야 한다.
        * 예시: Size에 의존한 코드라면 DeQ하는 스레드는 하나여야만 한다.
    5) 락프리의 목적을 생각하고 정책을 세워야 한다. 락프리는 누구든 먼저 할 수 있으면 무조건 하는 것이다.

### 테스트
1. 제한 시간 내에 EnQ, DeQ
2. 스핀락과 락프리
    1) 스핀락 최악의 시나리오: 코어보다 스레드가 많은 경우 최악의 상황이 벌어질 수 있다. 그 이유로 자원을 할당한 스레드가 멈춘 상태에서 다른 스레드들이 자원을 할당하기 위해서 계속해서 뺑뺑이도는 상황이 벌어진다.
    2) 락프리: 코어보다 스레드가 많은 경우에도 스핀락과는 다른 상황이 벌어진다. 먼저 EnQ 혹은 DeQ 작업에 들어간 스레드가 있다 하여도 늦게 시작한 다른 스레드가 먼저 성공하는 상황이 나타나기 때문이다. 
    3) 스레드들이 많아진다는 것은 
3. 만약 다른 스레드들이 다른 일을 하는 것은 없애고 
    1) EnQ와 DeQ와 전혀 다른 일을 하는 스레드를 늘리는 것은 코어 개수를 줄이는 효과를 줄 수 있다. 
    
### 실무
1. 사용하지 않는 이유
    1) 자신이 만든 락프리 큐를 믿지 못한다.
    2) 제대로 알지 못한다. 어떤 상황에서 사용하여야 할 지 효과가 얼마나 좋은지 등..
        
## 기타
### 

## 게임 프로그래밍 구조
### 적군 생성 방법
1. 객체지향
	* 동적 할당 추구 -> why? 보통 클라이언트가 객체지향을 사용하는데, 클라이언트는 화면 상에 존재하는 요소들만이 객체로 존재하면 되기 때문에 화면 전환 시 객체를 동적으로 생성 및 삭제하는 것이 유리하다.
2. 절차지향
	* 고정 할당 추구 -> why? 보통 서버가 절차지향을 선호하는데, 서버는 접속된 유저의 정보를 모두 저장하고 있어야 한다. 때문에 동적으로 생성되고 삭제되는 객체 형식보다는 절차적으로 처리해 항상 고정적인 프레임을 보장하게 하는 것이 적절한 동작이다. 

### 게임 프로그램 구조
1. 로직
	1) 적군 배치 및 이동
		* 생존 상태 플래그: 가장 접근을 많이하는 변수라면 구조체의 첫 요소로 배치(Offset 계산이 없어짐)
		* 적군에 대한 AI처리 시 최대치만큼 순회하며 처리하는 것은 문제가 되지 않는다. (2.의 2) 특성과 관계 있음)
		* 적군의 필요한 요소: 좌표, 방향, 이동 반경, 특성(type), 생성 좌표에 대한 정보를 가져야 한다.
	2) 공격 구현
		* 공격 횟수, 갯수에 대한 제한을 둔다. (FPS 게임 총알에 대한 탄피의 경우 무한히 증가하지 않는다.)
		* 공격 구조체(객체)를 따로 생성하여 아군 혹은 적군에 대한 소유권을 부여하여 이동 방향, 타격 판정 등의 동작을 수행한다.
		* 충돌 판정은 공격 투사체 기준 혹은 유닛 기준으로 나뉠 수 있다.
	3) 외부 데이터로 빼야하는 요소들
		* 컨텐츠 요소 정보(스테이지, 몹의 스폰위치, 종류, 공격 패턴, 이동 패턴 등)은 하드 코딩하지 않고 외부로(파일 등) 무조건 빼야한다.
			* ex: Stage의 경우 StageList를 생성하여 관리한다.
		* Tool을 만들어 외부데이터에 대한 정보를 기획자에게 제공하여 소통하는 것이 좋다. 
			* 유의할 점: 기획자에게 Tool 제공 시 시각적인 그래픽의 형태로 제공하는 것이 좋다.
2. 클라이언트와 서버의 입장
	1) 클라이언트: 가시적인 게임 요소 변화에 따라 메모리 사용량이나 속도가 합리적으로 보여야 한다. (ex: 유저 수가 많으면 렉이 걸림)
	2) 서버: 유저수가 많든 적든 일정한 메모리 사용량, 속도를 유지하는 것이 이상적인 구조이다.
		* 정한 동접자 수가 가득찼을 때 원활하게 게임 진행이 되는 것이 이상적
3. for문 안에서 중복 if 문을 사용할 때 if-continue로 대체하는 것이 코드가 간결하다.
	* ex) if(cond1) { if(cond2) ... } -> if (!cond1) continue; if (cond2)...

# 2022/02/25 수업내용(복습 완료)
# 소켓 프로그래밍
## Chapter10 소켓 입출력 모델(1)
### 소켓 함수 오류
1. 논 블로킹 소켓 사용 시 모든 소켓 함수의 결과가 WOULDBLOCK인지 확인해야 한다. (WOULDBLOCK이면 PASS 에러가 아님!)
2. send 함수의 오류
    1) send 시 WOULDBLOCK 나오는 경우는 송신 버퍼 소켓이 가득찬 경우이다.
    2) 송신 요청 크기보다 작은 값을 반환하는 경우
        * 송신 버퍼에 복사를 하려고 스레드가 블로킹되어 있는 상태에서 해당 연결이 끊어진 경우이다.
    * 따라서, send 호출 시 위 두 가지 경우에 대한 대비 코드가 있어야 한다.
3. send 함수 테스트
    1) 실제로 위 "send 함수의 오류"에 대한 실험 내용이다.
    2) 확인이 필요한 부분
        * 첫 번째: 수신측이 제로 윈도우인 상태에서 closesocket을 호출하면 RST 패킷이 날아감(LINGER 옵션 건드리지 않음)
        * 두 번째: 송신측에서 첫 번째 send 호출 시 아무리 큰 숫자여도 블로킹이 되지 않는다. 그리고나서 두 번째 send 호출 시에 1 크기만 send 하여도 블로킹이 된다.
    <pre><code>
    // ----------------------
    // 송신측----------------
    // ----------------------
    // 소켓 옵션: SO_SNDBUF를 2000으로 설정
    ret=send(1000000);  // 블로킹이 되지 않는다. (무조건 send 요청 크기만큼 값이 반환됨)
    if(ret==SOCKET_ERROR){...} // 진입하지 않음
    ret=send(10);       // 블로킹됨, 이 시점에서 수신측에서 closesocket을 호출한다. (확인이 필요한 부분 두 번째 항목에 해당)
    if(ret==SOCKET_ERROR){...} // 진입
    
    결과: 두 번째 send 결과에서 SOCKET_ERROR 반환되고 GetLastError()에서 10054가 반환된다.   
    
    // ----------------------
    // 수신측----------------
    // ----------------------
    // 소켓 옵션: SO_RCVBUF를 2000으로 설정
    
    // 소켓 초기화 및 연결
    // recv는 하지 않음
    
    closesocket(sock);  // 이때 송신측은 두 번째 send를 요청하여 블로킹된 상황
    </code></pre>

### 소켓 모드의 종류
1. **논블로킹 소켓 사용**시 accept, send, recv는 지금 당장 작업을 수행하지 못하면 에러를 뱉어낸다. 하지만 connect는 3 handshake가 L4에서 비동기적으로 이루어지기 때문에 무조건 에러를 뱉어낸다.
    * GetLastError를 호출하여 에러 코드를 확인해야 한다. 대개 WOULDBLOCK이다.
    * 위와 같은 connect의 특성 때문에 연결 결과 여부를 따로 확인해야 한다. (하지만 우린 다른 방법으로 이 작업을 대체한다. 그 내용은 스스로 아래에서 찾아볼 것!)
2. ioctlsocket
    1) 소켓의 I/O 모드를 제어하는 함수
    2) FIONBIO 옵션: 논블로킹 소켓으로 지정
3. 실제 서버에서는 Overlapped I/O를 활용한 Completion Port 모델을 사용하게 된다.
    * 그렇다고 Select 모델이 무시할 대상은 아니다. 아직도 현역임 (언리얼 데디케이트 서버 등..)

### Select 모델
1. 소켓 셋
    1) 읽기 셋: 수신된 것들에 대한 반응을 확인하는 용도 (listen socket-백로그 큐, 일반 socket-수신 버퍼 공간 있느냐 등..)
    2) 쓰기 셋: 송신 버퍼에 대한 반응을 확인하는 용도 (일반 socekt-송신 버퍼 공간 있느냐 등)
    3) 예외 셋: OOB, 연결 에러 상태 등의 정보(ex: connect 이후 예외 셋이 set되면 오류), 우린 잘 사용하지 않을 것
        * 연결이라는 과정이 편한 것은 select 모델이 편한다. 이때 예외 셋을 활용하게 된다.
2. 각 소켓 셋의 최대 개수는 64개이다.
    * 더 늘릴수는 있지만 우리는 기본 값인 64개를 사용한다. 초과하여 사용 시 어떠한 문제가 발생할 수 있는 가능성이 있기 때문(이건 명확히 언급하진 않으심)
3. 소켓 셋 사용 절차
    1) 검사하고자하는 소켓 셋을 준비
    2) select 호출
    3) 반응이 있던 소켓 셋만 남게됨
4. 예외 셋을 쓰지않고 쓰기 셋만으로 연결 여부 확인
    1) 아래 그림과 같이 쓰기 셋은 connect 성공 여부도 확인해주기 때문에 예외 셋을 따로 구분할 필요가 없다. 이는 연결이 되어야만 다음 단계로 넘어가는 상황이라면 사용할 수 있지만 우리의 입장에서는 필요가 없다. 쓰기 셋이 이렇게 동작하는 이유는 연결 성공 시 거의 대부분의 경우 송신 버퍼는 항상 준비되어 있기 때문이라고 생각된다. (즉, 송신 버퍼가 가득 차는 경우가 거의 없다.)
    2) 우리는 쓰기 셋에 반응이 오지않으면 send를 하지 않는 코드를 짤 것이다.
    * <img width=600 src="https://user-images.githubusercontent.com/95362065/155718345-35a0b6a7-8673-4990-9b2c-79b440479426.jpg">

### select 함수
1. 함수 원형
    <pre><code>
    int WSAAPI select(
        int           nfds,
        fd_set        *readfds,
        fd_set        *writefds,
        fd_set        *exceptfds,
        const timeval *timeout      // timeout 이내 소켓 셋에 반응이 오면 함수 반환, NULL: 소켓 셋 중 반응이 하나라도 오면 함수 반환
    );
    </code></pre>
2. 입력 인자
    1) fd_set: 소켓 셋, 원칙적으로 이 구조체는 숨겨진 구조체이다.
        <pre><code>
        typedef struct fd_set {
            u_int  fd_count;                // 확인하고자하는 소켓 셋 갯수
            SOCKET fd_array[FD_SETSIZE];
        } fd_set, FD_SET, *PFD_SET, *LPFD_SET;
        </code></pre>
    2) timeval 구조체
3. 반환 값
    1) 양수: 반응을 보인 소켓 셋 갯수
    2) SOCKET_ERROR: 소켓이 아닌 것을 넣는 경우 (생성하지 않은 소켓 혹은 이미 closesocket이 이루어진 소켓)
        * 이후에 생길 수 있는 상황: 만약 소켓 번호가 재사용되는 경우 엉뚱한 유저에게 다른 유저의 정보를 주고받게 된다.
    * 보통 우리는 0 이상인 경우와 SOCKET_ERROR를 확인한다.
4. fd_set 매크로
    1) FD_ZERO: 소켓 셋을 비운다.
    2) FD_SET: 입력한 소켓을 소켓 셋에 등록
    3) FD_CLR: 입력한 소켓을 소켓 셋에서 삭제
    4) FD_ISSET: 이 소켓이 fd_set에 있는지 확인(fd_set에 소켓을 등록할 때 먼저 이미 등록되어있는지 확인하는 용도)
    * fd_set 구조체를 직접적으로 건드리는 것은 좋지않은 접근이다. 원칙적으로 fd_set은 가려진 형태이기 때문에 언제든 바뀔 수 있기 때문이다.
5. select 모델임에도 Non-Block 소켓을 사용해야하는 이유
    1) send의 특성
        * send의 경우 송신 조건을 명확히(남은 버퍼 크기) 알려주지 않아 Non-block 소켓을 사용하여야 한다.

### 세션
1. 세션의 단위
    1) 컨텐츠: 유저, 플레이어 클라이언트
    2) 네트워크: 세션(연결)
2. L7에서의 송수신 버퍼(TCP에 제한함)
    1) L7 수신 버퍼 존재의 이유: TCP에서 쪼개지거나 뭉쳐서 올 수 있기 때문에 그에 대비하기 위함
    2) L7 송신 버퍼 존재의 이유
        1) send를 하였어도 송신 버퍼가 꽉 차 못 보낼 때를 대비하기 위함(Non-Block 이기 때문)
        2) 매번 보내고자 할 때마다 보내는 것이 아닌 모아서 보내기 위함 (소켓 함수 중 send가 제일 느림)
        * send 함수는 느리다.
    3) L7 송수신 버퍼 구조 시 링버퍼로 만들어야 한다. 이는 TCP의 스트림 방식으로 인하여 생겨난 구조이다.
        * 스트림은 짤려 나가거나 들어올 수 있기 때문에 수신된 데이터가 완성된 메시지인지 구분해야하기 때문 

### 서버 입장에서의 select
1. 소켓 셋
    1) write 셋의 경우 대부분 반응이 오기 때문에 write 셋을 통해 send를 하지 않는다.
        * write 셋의 반응이 오지 않는 경우 정상적인 상태가 아니다!(소켓 송신 버퍼가 가득찼다는 뜻이기 때문)
        * send 시도 시 요청 크기보다 작은 값이 반환되거나 에러가 나는경우 비정상 상태!
        * 사용하는 시점: L7 송신 버퍼에 보낼 데이터가 존재하는 경우에 send 이전 write 셋 등록하여 확인(write 셋은 모든 소켓 대상이 아님!!!)
    2) read 셋은 모든 소켓에 등록하여야 한다.(언제 클라측에서 데이터가 들어올지 모름)

### recv 함수의 반환값
1. recv 호출 시 요청한 크기보다 작은 크기가 반환되는 경우(데이터가 조각남)
    1) 요청 크기를 10 byte 라고 가정
    2) 송신측이 send(10)을 하였는데 수신측에서 제로 윈도우가 발생한 시점 직전 수신 버퍼 공간 5만큼 남은 경우 
    3) 송신측 송신 버퍼의 남은 공간이 10 보다 작은 경우(MSS만큼 차기 직전)
    * 그러나 보통 조각나는 건은 없다.

## 기타 키워드
### 에러 발생
1. WSA_NO_BUFFER
    * 이론적으로 모든 환경에서 자원의 부족으로 인해 발생하는 경우가 많음(물리메모리, NP 풀 등..)
2. DISK 에러: 하드웨어적인 문제
3. 서버에서 아무런 흔적도 없이 먹통이 되어버렸을 때 거의 대부분 NP 풀의 비이상적인 증가가 뒤따른다.(강사님 경험)

### UDP
1. UDP의 경우 L7 차원에서의 수신 버퍼가 필요 없다.(통신이 데이터그램 단위이기 때문)

### select 모델의 한계
1. 언리얼 데디케이트 서버와 같이 하나의 게임만 관장한다면 select 모델이 효율적이지만, 여러개의 게임을 관장하며 

### 과제
1. select 모델을 사용한 Echo 서버-클라 만들기

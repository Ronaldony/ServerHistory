# 2022/06/13 수업내용(복습 완료)
# 네트워크 라이브러리
    * 본 수업내용은 네트워크 라이브러리 설계에 대한 내용을 다룬다.
## 에코 서버
### 디버깅
1. 문제가 의심되는 것의 명확한 이유를 찾기 위하여 증명을 하는 코드를 넣어 자료로 확인해야 한다.
    * 예를 들어 내가 겪은 문제 중 특정 세션이 Release를 안 타는 문제 상황에 대한 원인(워커 스레드 최하단에서 IO count가 차감되지 않는 경우)이 의심될 때, 해당 원인 부분에 로깅을 하여 증거를 남기고 이유 또한 추적해야 한다. 

## 네트워크 라이브러리
### 동기화
1. 이전 시간에 세션의 메모리가 해제되었을 때 발생하는 구조적 복잡성과 문제를 해결하기 위하여 메모리풀을 사용한 방법은 아래와 같다.
    1) 문제점1: Release 함수 내부에서 세션이 삭제되면서 동기화 객체도 같이 메모리가 삭제되어 다른 스레드에서 해당 동기화 객체를 대상으로 Lock을 한 경우 문제가 생긴다.
    2) 문제점2: 문제점1을 발생시키지 않게하기 위하여 복잡한 구조로 SendPacket(=SendMessage)과 Disconnect 함수가 구조되었다.
    3) 메모리풀 사용에 따른 문제점1 해결: 해제 후에도 실제 동기화 객체는 삭제되지 않아 다른 스레드에서 Lock을 한 상태여도 문제되지 않는다.
    4) 메모리풀 사용에 따른 문제점2 해결: 복잡한 구조를 아래와 같이 개선시킬 수 있음
        <pre><code>
        // 새로운 코드
        SendPacket 함수
        {
            세션Map.Lock();
            세션Map.검색();
            세션Map.Unlock();

            세션.Lock();
            if (세션 ID 확인) => 위 세션Map에서 검색한 세션에 접근하여 현재 ID를 확인
            세션.Unlock();
        }

        Diconnect 함수
        {
            세션Map.Lock();
            세션Map.검색();
            세션Map.erase();
            세션Map.Unlock();

            세션.Lock();
            // 고민사항1
            세션 ID 초기화
            세션 삭제(메모리풀)
            세션.Unlock();
        }
        </code></pre>
        * 고민사항1: 여기서도 SendPacket과 유사하게 삭제시킬 대상이 바뀌는 상황을 우려하여 세션 ID를 확인하는 코드가 들어가야 하나? => 결론적으로 아니다. 그 이유는 두 스레드 이상이 만약 같은 세션에 대해 삭제를 하기위하여 Diconnect 함수 내부에 들어왔다고 가정하자. 가장 먼저 들어간 스레드가 세션Map에서 해당 세션을 지울 것이다. 이후 다른 스레드들은 모두 세션Map.검색에 실패할 것이다.
2. 멀티스레드에서 동기화 문제가 발생하였을 때 원인으로 볼 수 있는 2가지(크게 봤을 때)
    1) 해당 메모리 자체가 사라져 버리는 문제 => 이 문제는 삭제만 안 되게하면 해결된다.
    2) 해당 메모리가 내가 접근한 시점에 예상했던 용도가 아닌 다른 용도로 재사용이 되고 있는 경우이다. => 이로 인해 의도했던대로 동작하지 않는다.
    * C, C++은 직접적으로 메모리를 다룰 수 있기 때문에 이러한 사항을 문제점으로 볼 수 있다.
3. 동기화 객체 삭제에 관한 고찰
    1) 상황: 동적으로 할당된 동기화 객체가 삭제되었다.(메모리 해제) 그런데 이미 다른 곳에서 Lock을 건 상태이다.
    2) 커널 동기화 객체 시점
        * 예상 문제 1: 
    3) 유저 동기화 객체 시점
        * 문제 1: 이미 Lock을 건 스레드가 데드락에 빠진다.
        * 문제 2: 동기화 객체의 메모리 번지가 해제된 후 해당 메모리 번지로 다른 용도로 동적 할당이 이루어졌다면 해당 동기화 객체를 대상으로 Lock, Unlock의 행동들이 모두 예상할 수 없는 동작으로 수행된다.

### 메모리풀과 게임 구조
1. 요즘 MMORPG들은 인스턴스 던전이 주 서버가 된다. (예시: WOW, 로스트아크)
2. 인던과 메모리풀의 관계
    1) 우리는 유저로부터 메시지 수신 -> 유저확인 및 인던 ID 검색(인던Map 컨테이너 Lock) => 인던 처리(인던 컨테이너 Lock)
        * 문제점: 인던 ID를 검색하거나 삭제할 때 인던Map 컨테이너를 통해 작업할 것이다. 이때 인던이 동적으로 할당 및 해제된다면 앞서 언급했던 세션 메모리가 삭제되는 건으로 인한 문제와 똑같은 사항이 발생한다.
        * 따라서 메모리풀과 같이 해제되지 않는 메모리를 사용하여 구현하는 방법밖에는 답이 없다.
3. 어설프게 C++을 한 사람들이 스마트 포인터로 이 문제를 해결할 수 있다고 한다.
    1) C++의 표준으로 제공되는 스마트 포인터들은 해당 메모리의 Reference count(해당 포인터를 바라보고 있는 개수)가 0이 되는 순간 해당 메모리를 해제해버린다.
    * 따라서 스마트 포인터를 사용하여 위 문제를 해결한다는 것은 개념이 없는 발언임

### 세션
1. 세션이 삭제되고 세션이 새로 생성되는 것을 막느다는 것은 매우 힘든 선택이다.(모든 것에 대해 Lock을 걸자라는 것이니까)

### 함수 재설계
1. Recv 완료통지 내부
    1) 구조
        <pre><code>
        if (Overlaaped ==Recv 완료 통지)
        {
            Recv.EnQ...
            while(1)
            {
                // 이 부분에서는 메시지(하나의 패킷)가 완료되었는지에 대한 여부를 확인하고
                // 건당건당 직렬화 버퍼에 삽입 후 메시지에 대한 처리를 할 것이다. 
                고정 헤더 수신 완료 확인
                헤더 길이만큼 확인하여 메시지 완료 확인, 즉 하나의 완성된 패킷이 수신되었는지 확인
                직렬화 버퍼에 수신 메시지 삽입(PayLoad만)
                OnRecv(세션, &직렬화 버퍼);
            }
        }
        </code></pre>
2. OnRecv 함수
    1) 기능: 인자로 입력받은 메시지(컨텐츠)에 대한 처리(해당 메시지로 할 일)를 하고 새로 생성된 메시지를 SendPacket에 전달하는 역할을 한다.
    2) 기능2: 어떤 사용자로부터 이런 메시지가 왔습니다. 이때 메시지는 건당건당이 전달받게 된다.
    3) 구조
        <pre><code>
        OnRecv(세션, CPacket* recvPacket)
        {
            // 현재는 에코 
            int64 Echo;
            recvPacket >> Echo;
            
            CPacket SndCPacket;
            SndCPacket << Echo;
            SendPacket(세션ID, &SndCPacket);
        }
        </code></pre>
    4) 주의점: 실질적인 컨텐츠 역할을 하는 것은 OnRecv 안에만 들어가야 한다. 다른 네트워크 함수에서들은 몰라야 한다.
3. SendPacket
    1) 기능: 네트워크 라이브러리 헤더를 생성하여 컨텐츠 메시지에 붙여 클라에게 전송하는 역할
    2) 구조
        <pre><code>
        SendPakcet(세션ID, CPacket* 메시지)
        {
            헤더 생성
            SendQ.EnQueue(헤더);  // 여기서 이 헤더는 네트웤 라이브러리 것이다.
            SendQ.EnQueue(메시지);
        }
        </code></pre>
        * 헤더의 특징: Payload와 달리 고정 길이
    3) 고민 사항: SendQ 인큐를 2번하는 것을 개선하는 방법을 생각해보자. 해결 방법은 애초에 직렬화 버퍼 앞쪽에 헤더만큼 빈 공간을 두는 것이다.
        * 애초에 직렬화 버퍼는 네트워크 라이브러리를 위하여 만들어진 클래스이다. 따라서 컨텐츠 파트에서 삽입할 떄는 네트워크 라이브러리 헤더 만큼을 비우고 사용하게 함으로서 해결할 수 있다.
        * 구현 방법: 일반적인 public 지정자로는 제공해서는 안 된다. private 지정자로 숨겨놓고 네트워크 라이브러리 내부에서만 사용하게끔 해야한다.
4. 우리가 이렇게 함수들을 재구조하는 것은 컨텐츠 파트와 네트워크 파트의 계층을 분리시키기 위함이다.

### 헤더
1. 네트워크와 컨텐츠 헤더 분리
    1) 네트워크 헤더: 메시지 길이, 
    2) 컨텐츠 헤더: 메시지 타입, 

### 성능과 네트워크 라이브러리
1. 흔히 네트워크 엔진 성능을 말할 때 에코 서버를 예시로 든다. 그러나!! 이는 정확한 성능 측정 방법이 아니다. 그 이유는 위 OnRecv 함수에서 입력받은 recvPacket를 바로 SendPacket에 꽂아버리기 때문에, 실질적으로 컨텐츠 처리를 하여 생성된 메시지를 직렬화 버퍼에 넣고 전달해야하는 상황에서도 같은 성능이 절대 나올 수 없기 때문이다.

## 기타
### 서버
1. 일단 세션 할당 및 해제를 메모리풀로 구현해볼 것
2. 패킷 헤더 종류
    1) 2btye 헤더: 메시지 길이 정보만 들어있는 헤더
    2) 5byte 헤더: 2byte + 안정장치
3. 우리의 네트워크 라이브러리 제작 목적은 성능을 높이는데 있는 것이 아니다. 멀티스레드의 문제점을 극단적으로 파악하기 위한데 그 목적이 있다.
    1) 우리는 동기화 객체, 세션 컨테이너를 없앨 것이다.
    2) 동기화 문제에 관해서는 성능에 대한 논의를 하지 않을 것이다.

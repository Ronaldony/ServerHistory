# 2022/05/30 수업내용
# 과제 분석
## 잡 워커 스레드
### 메시지
1. 애초에 메시지를 짤리는 형태로(분리되어) 
2. 이벤트 객체로 워커스레드가 제어되는 경우, 한 번 깨어났을 때 모든 메시지를 처리해야 한다. 메시지의 개수가 많아지면(처리 되지 않으면) 이벤트 발생으로 인해 스레드가 
    1) 아쉬운 점: 개발자 입장에서는 메시지 큐에 많이 쌓여있다면 기대했던 여러개의 스레드가 메시지를 처리하는 형태가 아닌 하나의 스레드가 모든 메시지를 처리할 것이다.

## 코드 디버깅
### 힙
1. 힙 오류
    1) 힙 영역이 오염됨
    2) Debug 모드: 해제 시 문제가 될 수 있음.
    3) Release 모드:

### Lock

### 스레드 종료
1. 실제 스레드 핸들이 3개인데 WaitForMultipleObjects 함수 인자에 4개를 넣어 WAIT_FAILED가 반환된다. 이는 WaitForMultipleObjects 내부에서 핸들 배열의 4번째 요소까지 확인하다가 유효하지 않은 핸들이라고 판단되어 함수가 실패함

### 실무
1. 코어와 컨텐츠 파트
    1) 코어 파트는 굉장히 크리티컬하고 어려운 부분이기 때문에 소수로 간다. 그래서 확실하고 안전한 방법으로 동기화를 걸어 버린다. (같은 자원에 대해 어디를 빼고 어디를 걸고하는 방식이 아닌 통째로 걸어버리는 방법) 

# 비동기 IO
## IOCP
### IOCP
1. 프로세스 공유 목적이 아니라 SECURITY_ATTRIBUTES를 입력하는 인자가 없다.
2. 입출력 완료 포트: IOCP가 관리하는 완료 통지 결과, 입출력 완료 패킷가 쌓여있는 큐. 완료 통지 개수에 대한 제한이 없다.
    1) 어떤 Overlapped
3. IOCP의 스레드 풀(IOCP의 가장 큰 특징이다.)
    1) 작업자 스레드 중 대기(GQCS를 호출), 러닝, 블락 상태인 스레드들을 실시간으로 관리한다.
    2) 작업자 스레드 중 블락 걸린 스레드가 있다면 대기->러닝로 스레드를 깨워준다. (CPU를 놀리지 않겠다.) => 이 상황에서 블락된 스레드가 러닝 상태로 전환이 되면 그 순간 만큼은 NumberOfConcurrentThreads를 초과하여 스레드가 수행될 수 있다.
    3) Stack 방식으로 스레드를 깨운다. (컨텍스트 스위칭과 캐시 히트율을 높이기 위함)

### 워커 스레드
1. GetQueuedCompletionStatus(GQCS)를 한 번 이상 호출한 경우 IOCP의 워커 스레드로 지정된다. (즉, IOCP 객체가 관리한다는 의미)
2. 워커 스레드 내부에서는 비동기 IO를 걸어도 되고 안 걸어도 된다.
3. 워커 스레드에는 OVERLAPPED 구조체와 Key 값이 전달되는 것을 가지고 어떤 IO 작업인지를 판단할 수 있다.
4. 설계
    1) 최대한 IO 바운드를 하단부로 짜는 것이 좋다. (CPU를 최대한 사용 후 IO에 들어가는 것이기 때문)

### 함수
1. CreateIoCompletionPort
    1) 기능: IOCP 객체를 생성하고 디바이스를 IOCP에 등록하는 기능 두 가지가 있다. (소켓이라면 모든 소켓을 등록)
    2) 구조
        <pre><code>
        HANDLE WINAPI CreateIoCompletionPort(
            _In_     HANDLE    FileHandle,
            _In_opt_ HANDLE    ExistingCompletionPort,
            _In_     ULONG_PTR CompletionKey,           // 
            _In_     DWORD     NumberOfConcurrentThreads
        );
        </code></pre>
        * CompletionKey: 소켓마다 Key를 등록하여 찾을 수 있다.
        * NumberOfConcurrentThreads: 동시에 실행할 수 있는 최대 작업자 스레드 개수.
    3) 인자 NumberOfConcurrentThreads
        * 0을 지정한 경우 CPU 개수와 같은 수로 설정된다 => 논리 프로세서 
    4) 스레드의 생성 개수와 NumberOfConcurrentThreads 개수
        * NumberOfConcurrentThreads는 코어 개수 이하로 지정하는 것이 맞다. (왜인지 잘 고민해볼 것)
        * 스레드의 생성 개수: 답은 없다. 그러나 워커 스레드가 블락 걸릴 일이 많다면 워커 스레드를 애초에 많이 생성하는 방법을 생각할 수 있다.
2. GetQueuedCompletionStatus
    1) 구조 
        <pre><code>
        BOOL GetQueuedCompletionStatus(
            [in]  HANDLE       CompletionPort,
            [out] LPDWORD      lpNumberOfBytesTransferred,
            [out] PULONG_PTR   lpCompletionKey,
            [out] LPOVERLAPPED *lpOverlapped,
            [in]  DWORD        dwMilliseconds
        );
        </code></pre>
        * FALSE 상황: 디큐잉을 실패한 경우와 작업이 실패한 경우에 FALSE가 반환된다. 중간에 연결이 끊겼을 때는 lpNumberOfBytesTransferred가 0 이어도 TRUE를 반환한다.
3. PostQueuedCompletionStatus
    1) 
    2) 워커 스레드에 함수 종료 값으로써 0,0,0을 전달해주는 역할을 할 수 있다.

## 소켓 프로그래밍 도서
### 예제 분석
1. 보통 소켓에 대한 작업의 Key를 소켓으로 하지 않는다.
2. WSARecv에서의 lpNumberOfBytesRecvd에 대한 논의 recv, send에 대한 반환 크기
    1) Overlapped IO로 사용되는 경우 NULL을 입력하여도 된다.
        * 그러나! NULL을 입력하지 않게되면 또 다른 문제가 발생한다. 이는 추후에 설명해주신다 함
3. GetQueuedCompletionStatus
    1) dwMilliseconds를 INFINITE가 아닌 timeout 처리를 해놓았다면 문제가 생길 수가 있다.
        * 문제: out 파라미터인 lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped는 IO 완료 통지로 디큐잉 됐을 때 값이 반환된다. 디큐잉이 되지 않았다라면 혹은 실패했다면 값이 변경되지 않는다. 즉, 아예~ 건드리지를 않는다. Overlapped가 NULL이라면 디큐잉이 되지 않는 것이다.(MSDN 문서 참조할 것)
        * 그래서 lpNumberOfBytesTransferred, lpCompletionKey를 무조건 초기화(값 0)으로
        * 따라서 GetQueuedCompletionStatus 호출 시 함수의 리턴 값이 아닌 lpOverlapped가 NULL인지 아닌지를 검사하여 작업의 완료 여부와 소켓 여부를 판단할 것이다.(?!)
4. 테스트 방식
    1) 스레드들이 Block 되었을 때 실제로 대기 상태의 스레드가 Running 상태가 되는지 확인
    2) 깨어나는 스레드가 어떤 스레드가 되는지

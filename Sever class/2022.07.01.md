# 2022/07/01 수업내용
# 락프리
## 메모리풀
### ABA 문제(ABA problem)
1. ABA 문제: 현재는 메모리의 주소를 재활용하는 상태이다. 때문에 주소값만 가지고 판단을 했을때 이것이 예전에 내가 알던 그 데이터가 맞는지 아니면 누군가가 해제 후에 다시 새롭게 할당되어있는 상태인지 알 수가 없는 문제
    1) 현재 우리의 ABA의 대상은 Stack의 TOP이다. 예를 들어 POP의 경우 다음의 ABA 문제가 발생한다.
        <pre><code>
        // 수도 코드
        pop()
        {
            t = top
            next = t->next
            // 지점 1
            if (t == top)
                top = next; // 지점 2
        }
        </code></pre>
        * 문제: 스레드 A가 지점 1에서 멈춘 상태에서 다른 스레드가 같은 top을 해제하고 next까지 해제한 후에 다시 동일 top을 할당한 상태일 때, 스레드 A가 다시 스위칭되었을 때 이 top은 스레드가 A가 알던 그 top이 아니다.(의미를 잘 생각해보자) 이미 스레드 A가 알던 next는 이미 해제된 상태인 문제가 발생한다.
    2) PUSH에서는 이와 같은 문제는 발생하지 않는다. PUSH 하고자하는 NewNode의 대상은 현재 나만 들고있는 상태이기 때문이다. 즉 Stack에는 존재하지 않는 요소이다.
        <pre><code>
        // 수도코드
        push()
        {
            t = top
            NewNode = xx
            NewNode->next = t

            if (t == top)
                top = NewNode;
        }
        </code></pre>
2. 현재 락프리 스택, 큐에서 문제되는 상황에 대하여 완벽히 이해하고 판단하여야 한다. 그 이유는 다음과 같다.
    1) 공개된 소스 외 나의 상황과 맞게 스스로 구조를 변경할 수 있어야 한다.
3. ABA 문제 해결
    1) 고민거리: 포인터 주소 비교 하나로는 과거에 내가 알던 그 상태의 주소인지 알 수 없다. 따라서 다른 부가적인 요소를 더하여 판단이 되어야 한다. 이 요소는 고유하여야 한다.(그 이유는 잘 생각해보자)
        * 유니크하지 않고 사용한다, 안 한다의 상태만 고려한다면 ... 문제가 발생한다.
        * 우리는 지역적으로만 검사하여도 문제가 없을 것이다.
    2) 방법1
        * Double CAS(Compare-And-Swap): 16byte(32bit 시스템에서는 8byte) 구조체를 만들어 8byte를 주소 값, 8byte는 유니크한 Count값으로 구성한다. 이 구조체를 _InterlockedCompareExchange128(32bit 에서는 CAS64) 명령을 사용하여 기본 레지스터 2배 크기만큼을 Atomic하게 동작하게 한다. 그러나 이 방법은 엄청 느리다.
    3) 방법2
        * 지역적으로 포인터 값을 고유한 상태를 만들어 판단할 수 있게 만드는 상황을 만들어보자!
        * 사용되지 않는 주소 bit를 사용: 주소 값으로 사용되지 않는 최상위부터 17bit(64bit 시스템)를 활용하여 노드의 사용여부를 검사하는 방법. 우리는 이 방법을 사용할 것이다. 하지만 이 방법은 OS 버전에 따라 미사용 범위가 달라질 수 있기 때문에 조심스럽다.
        * Count 교체 시기: CAS 이전
        <pre><code>
        ??
        {
            t = top;        // 현재 Count가 10
            newTop = node;  // push였다라면 새로넣을 NewNode, pop이라면 t->next
            newTop.Count++; // Count를 1증가시켜 11로 만든다.
        }
        </code></pre>
    4) 방법3
        * 메모리풀 내부에서 애초에 VirtualAlloc할 때 일부 상위 비트를 비워버리는 방법
    5) 방법4
        * SYSTEM_INFO 구조체의 lpMaximumApplicationAddress 값을 확인하여 Double CAS로 동작하게 하던가 아니면 동작을 아예 하지 않게 하던가(오작동이 아니다.)

## 락프리 큐
### 일반 큐
1. Head와 Tail
    1) 데이터 노드가 없을 때 Null을 찌르는 형태와 Head와 Tail 각각 더미노드를 가지고있는 형태 두 가지로 나누었다. 이 중 우리는 처음이나 끝인지 굳이 확인하는 코드를 넣지 않기 위하여 더미노드를 가지는 형태를 선택하였다.

### 설계 시 문제점
1. 싱글 링크드 리스트에서 Head와 Tail에 대하여 고민해보자
    1) Head와 Tail을 둘 다 포인터일 때의 상황: 말이 안 된다. 처음 노드를 삽입할 때 혹은 마지막 노드가 빠져나갈 때 Head와 Tail 동시에 Atomic하게 바꿔야하는데 말이 안 되는 상황이다.
    2) Tail은 더미노드로 두었을 때의 상황의 문제: 구현될 수 없다. Tail이 더미 노드라면 EnQ 동작 시 Tail 이전의 노드의 next에 새로운 노드를 찌르고 새로운 노드가 Tail 더미 노드를 찔러야 한다. 이때 next를 얻기 위해서는 Head로부터 추적해야 한다. 그래서 Tail은 무조건 포인터여야만 한다.
    3) Head는 더미 노드일 이유가 없다. 포인터일 때와의 차이점이 없기 때문이다. 더미인 경우 항상 더미의 next의 데이터를 DeQ하고, 포인터인 경우 내가 가리키는 노드를 DeQ(Null인지 하는 것은 아래를 참조)
    4) Tail과 Head가 포인터인 상황의 문제: 만약 마지막 노드를 대상으로 DeQ 동작이 될 때 Head는 노드를 제거하면서 null로 바꿔주면 된다. 하지만 Tail은? Tail도 같이 Atomic하게 Null로 바뀌어야 하는데 불가능하다. 따라서 우리는 노드가 '모두' 없어지는 상황을 없애야 한다.
    5) 결론: 위 문제 사항들을 모두 해결할 수 있는 방법은 무조건 더미 노드 하나를 두는 것이다. 큐가 생성됨과 동시 그리고 모든 데이터가 DeQ된 상태에서도 하나의 더미 노드는 항상 있다.
        * 더미 노드를 둔다고해서 Head와 Tail이 더미노드되는 것이 아니다. 그냥 더미 노드가 하나 있는 것이다.
2. DeQ와 EnQ
    1) DeQ의 동작
        * 최초에 더미 노드가 하나 기본적으로 생성된다.
        * DeQ 동작: Head가 가리키는 더미의 next로 이동하여 데이터를 사용하고 더미를 삭제한다. 그 후 next를 더미로 변경한다.
    2) EnQ의 동작과 Push 동작의 차이점
        * 방향이 다르다. Push는 새로운 노드를 만들고 이 노드가 Stack을 바라보게 만들어 기존의 Stack에 전혀 영향이 없다. Top을 NewNode로 교체하는 것으로 한 방에 해결된다.
        * EnQ는 새로운 노드를 만들고 Q가 이 노드를 바라보게 해야한다. EnQ는 Push와 달리 2가지의 동작이 이루어져야 한다. 아래와 같다.
    3) EnQ의 동작과 문제점
        * 1번 동작: tail이 가리키는 노드의 next를 새로운 node를 가리키기
        * 2번 동작: tail의 위치를 새로운 node로 옮기는 것
        * 우리는 1번 동작만 성공하더라고 EnQ가 마무리되는 것으로 볼 것이다. 락프리 큐에서는 2번은 보조적인 역할로 볼 것이다. 1번이 성공하고 2번이 실패했더라도 돌이킬 수 있는 방법이 없다. 되던 안 되던 해결할 방법이 없다. 여기서 잘못 생각하여 1번과 2번을 묶어서 실행하겠다하여 스핀락 구조로 생각이 갈 수 있다.
        * tail이 가리키는 노드의 next가 null이 아니라면 재시도 할 것이다.

## Inetrlocked
### 성능
1. Interlocked는 생각보다 무거운 명령이다.
2. IneterlockedCompareExchangePointer는 시스템 bit에 따라 달라지는 포인터 크기에 맞게 연산 크기가 변환된다.
3. Interlocked 관련 함수에 뒤에 아무것도 붙지 않은 것은 32bit 기준이고 8,16,32,64 등은 각 비트수에 맞는 것이다.

# 기타
## 메모리
1. 64bit에서 윈도우가 허용하는 메모리 범위는 16EB(상위 21bit를 사용하지 못함)이다. 이중에 윈도우 10 초반까지는 커널 8TB, 유저 8TB 까지이다. 지금은 달라졌다.
    1) 현재는 커널 128TB, 유저 128TB가 유저영역이 되었다. (0x10000 ~ 0x00007FFF'FFFEFFFF) 최상위 17bit가 비어있다.
        * GetSystemInfo 함수를 통한 SYSTEM_INFO 구조체의 lpMaximumApplicationAddress 요소로 최대 주소 값을 확인해보면 볼 수 있다.

## Double CAS
1. AVX, SIMD: 하나의 명령인데 여러개의 명령을 처리하는 기법(레지스터의 2배 크기를 다룬다)
    1) 과거에는 mmx였다.
2. 우리 CPU 설계 자체가 기본 레지스터 크기가 한계치가 아니다. 그거의 2배치를 약간 특별하게 커버할 수 있는 기능을 만들어놓은 상태이다.

## 락프리 큐 과제
1. DeQ할 때 비어있는지의 여부를 Size로 검사할 것. 그 이유는 락프리 큐의 문제점을 경험하기 위해서이다. 이 문제는 정확히 파악하여 기록으로 남긴다.
2. 강사님이 전달한 코드의 문제점을 분석하여 기록으로 남겨놓기(포트폴리오 작성할 것)
3. 일단 락프리 스택에서 발생한 ABA 문제에 대한 해결 코드는 넣고 시작할 것
4. 테스트 방법
    1) EnQ 끼리 DeQ 끼리의 문제를 테스트하기 위해서는 Head, Tail을 많이 벌려놓고 테스트 해야한다.
    2) EnQ, DeQ 간의 문제를 발견하기 위해서는 삽입 삭제 갯수를 굉장히 작게 간다. Head와 Tail이 만나야 하기 때문이다.

# 내용 추가
1. 더블 카스에 대한 궁금증. 기본 레지스터 크기의 2배를 Atomic하게 해주는 연산.
2. 확장 레지스터
3. ABA 문제 자세히

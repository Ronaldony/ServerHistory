# 2022/07/18 수업내용
# LAN 서버
## 링버퍼
### 락프리 큐로 전환
1. Peek
    1) 락프리 큐는 Peek 동작이 애매하다. 따라서 구현하지 않는다.
        * 문제는 Send할 때이다. Send할 때는 바로 DeQ를 하여 DeQ한 버퍼를 따로 저장해두어야 한다.

### 메모리풀
1. 멀티 스레드에서 안전하고 동기화  게 만들었다면 이론적으로 Alloc을 하나의 스레드가 하던 여러개의 스레드가 하던 Alloc 개수는 같아야 한다.
2. 네트워크 라이브러리에 메모리풀을 적용한 경우
    1) 스레드마다 Pool을 두자!
        * 문제점: 세션들이 매번 다른 스레드에서 돌 수 있기 때문에 Alloc 받은 위치와 Free 하는 위치가 달라질 수 있다. 
        * 해결 방법(1): 특정 Pool에서 Alloc한 메모리는 나의 스레드의 Pool에 Free를 하도록 하자
    2) 위에서 언급한 스레드마다 Pool을 두기 위해 각자에 맞는 Pool에 Free를 하는 메모리풀들을 일괄적으로 관리하는 또 하나의 메인 메모리풀이 나와야 한다.
        * 문제점: 여기서 또 경합의 상황이 발생한다.
        * 해결 방법: 동기화의 빈도를 낮추자!
        * 메인 메모리풀은 청크를 다루는 모양새가 된다.
3. 동기화의 빈도를 낮추는 방법 1
    1) Alloc: 단위를 크게크게 한 뭉치로 메인 메모리풀로부터 노드를 가져온다. (한 뭉치 = 한 청크)
    2) Free: 나의 Pool에 반환된 노드 청크가 일정 크기 이상 된다면 메인 메모리풀에 반환한다.
    * 이 방법이 가장 효율적이다.
4. 동기화의 빈도를 낮추는 방법 2
    1) Alloc 청크와 Free 청크를 나누어 노드를 재활용 하지 않는다. 이렇게 되면 각 Pool들은 Free된 노드를 재사용하지 않게된다.
    2) Free가 될 시 해당 스레드의 Pool의 청크에 반환된다.
    * 코드는 심플해지지만 효율적인 방법이 아니다.
5. 동기화의 빈도를 낮추는 방법 3
    1) Alloc 청크와 Free 청크를 나누어 노드를 재활용 하지 않는다. 이렇게 되면 각 Pool들은 Free된 노드를 재사용하지 않게된다.
    2) Free가 될 때 해당 노드가 속해있던 Pool의 청크에 
    3) 문제점: Pool에서 청크에 대한 재활용도 없고 해당 Pool에만 Free가 되어야 한다면 굳이 노드를 할당하고 해제하는 동작이 들어가야 하느냐? => 따라서 우리는 해당 노드 껍데기에 표시만 할 것이다.
    4) 메인 메모리풀을 대상으로 Alloc과 Free가 호출되어야 한다. 이렇게 되면 
    * 코드는 심플해지지만 효율적인 방법이 아니다.
6. 사용 방법
    1) 사용자 측에서는 어떤 스레드가 어떤 Pool을 사용하는지에 대한 고민은 없어야 한다.
    2) 따라서 내부적으로 스레드 ID를 확인하여 각자에 맞는 Pool에 대한 행동이 들어가야 한다.

## 세션
### 세션 찾기와 빈 세션 찾기
1. 현재는 뺑뺑이로 찾고 있지만 성능 테스트 후 개선한 사항을 적용해서 테스트 할 것이다.

## 기타
### 라이브러리 제작
1. 라이브러리를 제작할 때 사용자의 입장에서 사용하는 방법부터 고민해보기
2. 기술적인 것 부터 

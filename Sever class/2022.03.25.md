# 2022/03/25 수업 내용
## 트리
### 포트폴리오
1. 검증하는 절차와 결과를 포함하여 포트폴리오에 기술한다.

### 사용처
1. STL 라이브러리인 Map이 레드블랙트리로 구현되어 있기 때문에 공부하는 것

## Pool(풀)
### 메모리 풀
1. 풀의 정의: 미리 할당된 공간(객체 등)을 필요할 때 해당 공간을 사용하는 방법
2. 목적: 힙보다 빠르게 메모리를 할당받기 위한 것이 목적이다.
    * 하지만 힙도 어떻게 보면 메모리 풀이다. 이유는 우리가 malloc 혹은 new 시 HeapAlloc으로 디폴트 힙에서 할당 받기 때문이다. 힙은 사용자가 요청 시마다 크기를 측정하여 연속적으로 
    * 힙의 단점을 보완하기 위하여 오브젝트 풀(=메모리 풀과 유사)을 사용하여 구현한다.

### 오브젝트 풀
1. 미리 타입 크기로 나누어 메모리를 할당하는 형태 
    * 나중에는 직렬화 버퍼도 오브젝트 풀로 구현할 것이다.
2. 방법   
    1) Alloc()과 Free()를 내부적으로 Queue로 구현
        * 유니티는 이 방법을 사용한다. 멀티스레드 환경에서는 이 방법이 성능면에서 나아질 수 있다. 이유는 Alloc()과 Free()에서 서로 다른 주소의 공간을 가리키고 있기 때문
    2) Alloc()과 Free()를 내부적으로 Stack으로 구현
        * 장점: Queue보다 캐시히트율이 높아질 확률이 높다.
    * 둘 모두 가변적인 길이의 List 자료구조 형태를 기반으로 만들어진다.
    * List 할당 시에는 VirutalAlloc을 사용하여 구현. (VirutalAlloc 사용 시 페이지 락을 걸수도 있다. 하지만 강사님은 사용하지 않음. 이유는 정말 쓰지않는 메모리이기 때문에 페이지 아웃되었기 때문에)
3. Alloc과 Free 설계
    1) Alloc: Stack의 Top에 있는 NODE를 반환하고 
    2) Free
        * 잘못된 매개변수 대비: 입력된 매개변수가 만약 잘못된 주소를 반환하는 경우를 대비해야 한다. 추가적으로 NODE에 검사 코드와 같은 것을 삽입하여 확인할 수 있다.
        * Underflow, Overflow 대비: NODE 앞과 뒤에 특정 데이터를 추가하여 Underflow, Overflow 검사
4. 우리의 목표: new, malloc~ 보다 10배 성능
5. 오브젝트 풀이 해제될 때 NODE List에 대한 정리를 해야 한다면? => NODE List 생성 시 모든 주소를 저장해두고 소멸자에서 모두 해제
6. 오브젝트 풀을 사용하는 것을 꺼려하는 개발자가 있다. 클래스가 너무 많이 있으면 풀이 너무 많이 생성되기 때문이다. => 강사님은 오브젝트 풀을 선호하심(메모리 관리 측면에서 좋기 때문) 
* Garbage Collector를 구현하면 더 멋있음. Garbage Collector를 하는 시점에 대한 연구가 필요하다. (간단히는 Alloc 혹은 Free 시점, 복잡하게는 시간 계산 기준)

### 오브젝트 풀과 Stack
1. List는 Data와 next 포인터(다음 NODE를 가리키는)가 분리된 형태로 관리한다. 하지만 우리가 사용할 방법은 NODE 자체(next 포함)를 풀에 할당하여 사용할 것이다.
    * NODE 자체를 하나의 덩어리로 본다면 NODE를 동적으로 해제 및 할당하지 않아도 되기 때문이다.
2. Placement new에 대한 대비를 해주어야 한다.
    1) Alloc(): 생성자에서 bPlacementNew 매개변수를 두어 사용자가 원하는 경우 Alloc 할 때마다 항상 생성자가 호출할 수 있도록 설계되어야 한다.
        * 만약 사용자가 PlacementNew를 원한다면 처음부터 NDOE에는 생성자 호출이 일어나지 않은 객체가 있어야 한다.
    2) Free: Free에서는 무조건 소멸자 호출
    
    
### Free List
1. Free List: 반환된 것을 보관하고 있다가 재사용하자! (Pool과의 차이점: Free List는 처음부터 메모리를 만들지 않음)
    * Pool의 경우 할당 개수를 지정하는게 애매하다. 항상 사용자 수가 다르기 때문이다. 강사님은 Free List를 선호한다. 이유는 처음 Free List의 성능 저하는 몇십초 내에 정리되기 때문이다.

## 기타 키워드
### 힙
1. 최소 힙, 최대 힙

### 메모리 풀
1. 구글, 페이스북에서는 tcmalloc. jemalloc이 있다.
